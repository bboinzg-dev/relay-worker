diff --git a/src/ingest/mpn-exploder.js b/src/ingest/mpn-exploder.js
index d2ffac69349f42d7f4089f5e5cbde306c801ca2d..22b9238c80d069ee3602286bf89ac4fef9e9b0ab 100644
--- a/src/ingest/mpn-exploder.js
+++ b/src/ingest/mpn-exploder.js
@@ -90,93 +90,92 @@ function dedupeByBrandCode(rows = []) {
     let code = row.code;
     if (code == null || code === '') continue;
     code = String(code).trim();
     if (!code) continue;
     const codeNorm = (row.code_norm || code.toLowerCase());
     const brandNorm = String(row.brand_norm || row.brand || '').trim().toLowerCase();
     const key = `${brandNorm}::${codeNorm}`;
     if (seen.has(key)) continue;
     if (!row.code_norm) row.code_norm = codeNorm;
     seen.add(key);
     out.push(row);
   }
   return out;
 }
 
 /**
  * @param {object} blueprint - { ingest_options: { variant_keys, pn_template }, ... }
  * @param {Array<object>} rows - 추출된 행(스펙행). 각 행은 { series, series_code, ..., field:value }
  * @returns {Array<object>} - 변형 축을 모두 풀어낸 행들. code/code_norm 포함
  */
 function explodeToRows(blueprint, rows = [], options = {}) {
   const ingest = blueprint?.ingest_options || blueprint?.ingestOptions || {};
   const variantKeys = Array.isArray(ingest.variant_keys) ? ingest.variant_keys : [];
   const tpl = ingest.pn_template || ingest.pnTemplate || null;
 
- const parseVariantsFromCode = typeof options.parseVariantsFromCode === 'function'
+  const parseVariantsFromCode = typeof options.parseVariantsFromCode === 'function'
     ? options.parseVariantsFromCode
     : null;
 
   const baseRows = rows.length ? rows : [{}];
+  const candidateRows = [];
+  const expandedRows = [];
+
   for (const row0 of baseRows) {
-    const baseFields = { ...(row0 || {}) };
-    const candidates = collectCandidates(baseFields);
-    stripCandidateFields(baseFields);
+    const row = { ...(row0 || {}) };
+    const candidates = collectCandidates(row);
+    stripCandidateFields(row);
 
     if (Array.isArray(candidates) && candidates.length) {
-      const out = [];
       const seen = new Set();
       for (const raw of candidates) {
         const code = String(raw || '').trim();
         if (!code) continue;
         const norm = code.toLowerCase();
         if (seen.has(norm)) continue;
         seen.add(norm);
 
         const v = parseVariantsFromCode
           ? parseVariantsFromCode(code, blueprint?.code_rules || {})
           : {};
-        out.push({
-          ...baseFields,
+
+        candidateRows.push({
+          ...row,
           ...v,
           code,
           code_norm: norm,
         });
       }
-      return out;
+      continue;
     }
-  }
 
-  const expandedRows = [];
-
-  for (const row0 of baseRows) {
-    const row = { ...(row0 || {}) };
     const series = row.series_code || row.series || '';
 
-    const lists = variantKeys.map(k => {
+    const lists = variantKeys.map((k) => {
       const v = row[k];
       const list = normalizeList(v);
-        return list.length ? list : [null];
+      return list.length ? list : [null];
     });
 
     const combos = lists.length ? cartesian(lists) : [[]];
     for (const combo of combos) {
       const r = { ...row };
       variantKeys.forEach((k, i) => { r[k] = combo[i]; });
 
       let code = tpl
         ? renderTemplate(tpl, { ...r, series })
-        : [series, ...variantKeys.map(k => r[k]).filter(Boolean)].join('');
+        : [series, ...variantKeys.map((k) => r[k]).filter(Boolean)].join('');
 
       code = String(code).replace(/\s+/g, '').trim();
-        if (!code) continue;
+      if (!code) continue;
 
       r.code = code;
       r.code_norm = code.toLowerCase();
-       expandedRows.push(r);
+      expandedRows.push(r);
     }
   }
 
-  return dedupeByBrandCode(expandedRows);
+  const rowsOut = candidateRows.length ? candidateRows : expandedRows;
+  return dedupeByBrandCode(rowsOut);
 }
 
 module.exports = { explodeToRows, renderTemplate, normalizeList, cartesian };
