diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index 84fc4b79ec65a2d5c4c93fe338688666af5f74eb..429befd43d4702915a0206db54d62aec24519304 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -130,51 +130,53 @@ function parseListOrRange(s) {
   if (!raw) return [];
   const volts = parseVoltageList(raw);
   if (volts.length) return volts;
   if (/[;,、\/\s]/.test(raw)) return raw.split(/[;,、\/\s]+/).map(x => x.trim()).filter(Boolean);
   return [raw];
 }
 
 // 분할 여부: PN 후보≥2 또는 variant 열거형 곱≥2 이면 분할
 function decideSplit({ pnCandidates = [], seriesCandidates = [], variantKeys = [], specs = {} }) {
   if ((pnCandidates?.length || 0) >= 2) return true;
   if ((seriesCandidates?.length || 0) >= 2) return true;
   if (Array.isArray(variantKeys) && variantKeys.length) {
     let count = 1;
     for (const k of variantKeys) {
       const vals = parseListOrRange(specs[k]);
       const n = vals.length || (specs[k] != null ? 1 : 0);
       count *= Math.max(1, n);
     }
     if (count >= 2) return true;
   }
   return false;
 }
 
 // variant_keys 교차곱으로 base/specs 병합 배열 생성
 function explodeVariants(base = {}, specs = {}, bp = {}) {
-  const keys = Array.isArray(bp.variant_keys) ? bp.variant_keys : [];
+  const keys = Array.isArray(bp?.ingestOptions?.variant_keys)
+    ? bp.ingestOptions.variant_keys.map((k) => String(k).toLowerCase())
+    : (Array.isArray(bp.variant_keys) ? bp.variant_keys : []);
   if (!keys.length) return [{ ...base, ...specs }];
   const lists = keys.map(k => {
     const arr = parseListOrRange(specs[k]);
     if (arr.length) return arr;
     return (specs[k] != null ? [specs[k]] : []);
   });
   if (!lists.length || lists.some(a => !a.length)) return [{ ...base, ...specs }];
   const out = [];
   const dfs = (i, cur) => {
     if (i === keys.length) { out.push({ ...base, ...cur }); return; }
     const key = keys[i];
     for (const v of lists[i]) dfs(i + 1, { ...cur, [key]: v });
   };
   dfs(0, { ...specs });
   return out;
 }
 
 // pn_template 로 개별 MPN 조립
 function buildMpn(rec, bp) {
   const t = bp?.pn_template || bp?.ingestOptions?.pn_template;
   if (!t) return rec.code;
   return t.replace(/\$\{(\w+)\}/g, (_, k) => String(rec[k] ?? ''));
 }
 
 function pickSkuListFromTables(extracted = {}) {
diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index 84fc4b79ec65a2d5c4c93fe338688666af5f74eb..429befd43d4702915a0206db54d62aec24519304 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -544,51 +546,53 @@ async function runAutoIngest({
      // ★ 강제 보정: 제목/본문에 Signal Relay가 있으면 무조건 signal로
      if (/subminiature\s+signal\s+relay|signal\s+relay/i.test(text)) family = 'relay_signal';
    } catch { family = 'relay_power'; }
   }
 
   // 목적 테이블
   const reg = await db.query(
     `SELECT specs_table FROM public.component_registry WHERE family_slug=$1 LIMIT 1`,
     [family]
   );
   const table = reg.rows[0]?.specs_table || 'relay_power_specs';
   const qualified = table.startsWith('public.')? table : `public.${table}`;
 
   // 스키마 보장 (DB 함수) + 컬럼셋 확보
     if (!/^(1|true|on)$/i.test(process.env.NO_SCHEMA_ENSURE || '0')) {
     await ensureSpecsTableByFamily(family);
   }
   const colsSet = new Set([
     ...await getTableColumns(qualified)
   ].map((c) => String(c || '').toLowerCase()));
   const colTypes = await getColumnTypes(qualified);
 
   // 블루프린트 허용 키
   const blueprint = await getBlueprint(family);
   const allowedKeys = blueprint?.allowedKeys || [];
-  const variantKeys = Array.isArray(blueprint?.variant_keys) ? blueprint.variant_keys : [];
+  const variantKeys = Array.isArray(blueprint?.ingestOptions?.variant_keys)
+    ? blueprint.ingestOptions.variant_keys.map((k) => String(k).toLowerCase())
+    : [];
 
   // -------- 공용 강제정규화 유틸 --------
 
   if (code && !/\d/.test(String(code))) {
     // "AGN","TQ" 처럼 숫자 없는 시리즈는 series로 넘기고 code는 비움
     series = code; code = null;
   }
 
 
   // ❶ PDF 텍스트 일부에서 품번 후보 우선 확보
   let previewText = '';
   try { previewText = await readText(gcsUri, PREVIEW_BYTES) || ''; } catch {}
   let candidates = [];
   try {
     candidates = await extractPartNumbersFromText(previewText, { series: series || code });
   } catch { candidates = []; }
 
   // PDF → 품번/스펙 추출
   let extracted = { brand: brand || 'unknown', rows: [] };
   if (!brand || !code) {
     try {
       if (FAST) {
         // 텍스트만 빠르게 읽어 블루프린트 기반 추출
         let raw = previewText;
         if (!raw) {
