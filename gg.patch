diff --git a/src/pipeline/persist.js b/src/pipeline/persist.js
index f07b74464aee9f0599ac52af13a9848f859388da..407f40ccba9b12afc1426dd476e5c5485d649e8c 100644
--- a/src/pipeline/persist.js
+++ b/src/pipeline/persist.js
@@ -276,61 +276,69 @@ function hasCoreSpecValue(value) {
 
 function hasCoreSpec(row, keys = [], candidateKeys = []) {
   const primary = Array.isArray(keys) ? keys.filter(Boolean) : [];
   const fallback = Array.isArray(candidateKeys) ? candidateKeys.filter(Boolean) : [];
   const list = primary.length ? primary : fallback;
   if (!list.length) {
     for (const key of Object.keys(row || {})) {
       const norm = normKey(key);
       if (!norm || META_KEYS.has(norm)) continue;
       if (hasCoreSpecValue(row[norm] ?? row[key])) return true;
     }
     return false;
   }
   for (const key of list) {
     const norm = normKey(key);
     if (!norm) continue;
     if (hasCoreSpecValue(row[norm] ?? row[key])) return true;
   }
   return false;
 }
 
 function shouldInsert(row, { coreSpecKeys, candidateSpecKeys } = {}) {
   if (!row || typeof row !== 'object') {
     return { ok: false, reason: 'empty_row' };
   }
+
+  const brand = String(row.brand || '').trim().toLowerCase();
+  if (!brand || brand === 'unknown') {
+    row.last_error = 'missing_brand';
+    return { ok: false, reason: 'missing_brand' };
+  }
+
   let pn = String(row.pn || row.code || '').trim();
   const allowMinimal = /^(1|true|on)$/i.test(process.env.ALLOW_MINIMAL_INSERT || '0');
   if (!isValidPnValue(pn) || FORBIDDEN_RE.test(pn)) {
     const fixed = repairPn(pn);
     if (fixed && isValidPnValue(fixed)) {
+      console.warn('[persist] pn repaired', { original: pn, fixed });
       row.last_error = row.last_error || 'invalid_code_fixed';
       pn = fixed;
     } else if (allowMinimal) {
-      const fallback = String(row.series || row.code || '').trim();
-      const fallbackPn = repairPn(fallback);
+      const fallbackPn = repairPn(String(row.series || row.code || ''));
       if (fallbackPn && fallbackPn.length >= 3) {
+        console.warn('[persist] pn fallback applied', { original: pn, fallback: fallbackPn });
         pn = fallbackPn;
         row.last_error = row.last_error || 'invalid_code_fallback';
       } else {
         row.last_error = 'invalid_code';
         return { ok: false, reason: 'invalid_code' };
       }
     } else {
       row.last_error = 'invalid_code';
       return { ok: false, reason: 'invalid_code' };
     }
   }
   row.pn = pn;
   if (row.code == null || String(row.code).trim() === '') row.code = pn;
   if (!hasCoreSpec(row, coreSpecKeys, candidateSpecKeys) && !allowMinimal) {
     return { ok: false, reason: 'missing_core_spec' };
   }
   return { ok: true };
 }
 
 async function getColumnTypes(targetTable) {
   const [schema, table] = targetTable.includes('.')
     ? targetTable.split('.', 2)
     : ['public', targetTable];
 
   const { rows } = await pool.query(
