'use strict';

const db = require('../utils/db');
const { extractDataset } = require('../utils/extract');

async function runAutoIngest({ gcsUri, filename, family_slug, brand, code, series, display_name }) {
  const t0 = Date.now();

  // 1) 데이터셋 추출 (DocAI → 부족 시 Vertex)
  const ds = await extractDataset({
    gcsUri,
    filename,
    maxInlinePages: +(process.env.MAX_DOC_PAGES_INLINE || 15),
    brandHint: brand,
    codeHint: code,
    seriesHint: series,
  });

  // 2) 패밀리 결정
  const fam = family_slug || ds.family || 'relay_power';

  // 3) 스펙 테이블 보장
  await ensureRelayPowerTable();

  // 4) 업서트 (중복 제거)
  const rows = dedupeRows(ds.rows);
  let inserted = 0;
  for (const row of rows) {
    await db.query(
      `insert into public.relay_power_specs
         (brand, brand_norm, code, code_norm, family_slug, series, displayname, datasheet_uri, verified_in_doc, created_at)
       values ($1,$2,$3,$4,$5,$6,$7,$8,$9, now())
       on conflict (brand_norm, code_norm, family_slug) do nothing`,
      [
        ds.brand || null,
        norm(ds.brand),
        row.code,
        norm(row.code),
        family,
        row.series || ds.series || null,
        display_name || row.displayname || row.code,
        gcsUri,
        JSON.stringify(row.verifiedPages || ds.verifiedPages || []),
      ]
    );
    inserted++;
  }

  // 5) 요약 로그(선택)
  await db.query(
    `create table if not exists public.doc_ingest_log (
      id uuid default gen_random_uuid() primary key,
      task text, gcs_uri text not null, filename text, brand text, family_slug text,
      series_hint text, page_count integer, rows integer, ms integer, note text,
      created_at timestamptz default now()
    )`
  );
  await db.query(
    `insert into public.doc_ingest_log (task,gcs_uri,filename,brand,family_slug,series_hint,page_count,rows,ms,note)
     values ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10)`,
    ['relay_power', gcsUri, filename || null, ds.brand || null, family, ds.series || series || null, null, inserted, Date.now()-t0, ds.note || null]
  );

  return {
    ok: true,
    brand: ds.brand || null,
    family,
    series: ds.series || null,
    rows: inserted,
    codes: rows.map(r => r.code),
    datasheet_uri: gcsUri,
    specs_table: 'public.relay_power_specs',
    ms: Date.now() - t0,
  };
}

function dedupeRows(rows = []) {
  const seen = new Set();
  const out = [];
  for (const r of rows) {
    const c = String(r?.code || '').trim();
    if (!c) continue;
    const key = c.toLowerCase();
    if (seen.has(key)) continue;
    seen.add(key);
    out.push({ ...r, code: c });
  }
  return out;
}
function norm(x) { return (x || '').toLowerCase().trim() || null; }
function guessFamilyByBrand(brand='') {
  const b = (brand || '').toLowerCase();
  if (!b) return 'relay_power';
  if (b.includes('panasonic')) return 'relay_power';
  if (b.includes('omron'))     return 'relay_power';
  if (b.includes('te connectivity')) return 'relay_power';
  if (b.includes('finder'))    return 'relay_power';
  if (b.includes('hongfa'))    return 'relay_power';
  return 'relay_power';
}
async function ensureRelayPowerTable() {
  await db.query(`
    create table if not exists public.relay_power_specs (
      id uuid default gen_random_uuid() primary key,
      brand text, brand_norm text, code text, code_norm text,
      family_slug text, series text, displayname text,
      datasheet_uri text, verified_in_doc jsonb default '[]'::jsonb,
      created_at timestamptz default now()
    );
    do $$
    begin
      if not exists (
        select 1 from pg_indexes where schemaname='public' and indexname='ux_rps_bcn'
      ) then
        execute 'create unique index ux_rps_bcn on public.relay_power_specs (brand_norm, code_norm, family_slug)';
      end if;
    end $$;
  `);
}

module.exports = { runAutoIngest };
