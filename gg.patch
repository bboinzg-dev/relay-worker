diff --git a/src/pipeline/persist.js b/src/pipeline/persist.js
index b9985b3d690d846ea1684cdfb4455ce42c27a50e..ac37d4f3a1849d91ab76eba2d69b5cc4b96a6daa 100644
--- a/src/pipeline/persist.js
+++ b/src/pipeline/persist.js
@@ -763,70 +763,75 @@ const renderPnTemplate =
   typeof renderPnTemplateFromOrdering === 'function' ? renderPnTemplateFromOrdering : renderPnTemplateLocal;
 
 function buildPnIfMissing(record = {}, pnTemplate) {
   const existing = String(record.pn || '').trim();
   if (existing) return;
   const fromTemplate = renderPnTemplate(pnTemplate, record);
   // 본문 검증: 템플릿 결과가 실제 문서 텍스트에 존재할 때만 채택
   const ctxText = String(record._doc_text || record.doc_text || '');
   if (fromTemplate && ctxText) {
     const normalizedContext = norm(ctxText);
     const normalizedTemplate = norm(fromTemplate);
     if (normalizedTemplate && normalizedContext.includes(normalizedTemplate)) {
       record.pn = fromTemplate;
       if (!record.code) record.code = fromTemplate;
       return;
     }
   }
   const code = String(record.code || '').trim();
   if (code) record.pn = code;
 }
 
 function buildBestIdentifiers(family, spec = {}, blueprint) {
   if (!spec || typeof spec !== 'object') return spec;
 
   let codeCandidate = null;
-  if (blueprint?.pn_template) {
+  const localTemplate = blueprint?.pn_template || spec?._pn_template || null;
+  if (localTemplate) {
     try {
-      codeCandidate = renderPnTemplate(blueprint.pn_template, spec);
+      codeCandidate = renderPnTemplate(localTemplate, spec);
     } catch (_) {}
   }
 
   if (!codeCandidate && family === 'relay_signal') {
     codeCandidate = codeForRelaySignal(spec);
   }
 
   const docText = String(spec._doc_text || spec.doc_text || '');
   if (codeCandidate && norm(docText).includes(norm(codeCandidate))) {
     spec.pn = codeCandidate;
     spec.code = codeCandidate;
     spec.verified_in_doc = true;
   } else {
     spec.code = spec.pn;
     if (!STRICT_CODE_RULES) spec._warn_invalid_code = true;
   }
 
+  if (Object.prototype.hasOwnProperty.call(spec, '_pn_template')) {
+    delete spec._pn_template;
+  }
+
   return spec;
 }
 
 function hasCoreSpecValue(value) {
   if (value == null) return false;
   if (Array.isArray(value)) return value.some((v) => hasCoreSpecValue(v));
   if (typeof value === 'boolean') return true;
   if (typeof value === 'number') return Number.isFinite(value);
   const str = String(value).trim();
   return Boolean(str);
 }
 
 function hasCoreSpec(row, keys = [], candidateKeys = []) {
   const primary = Array.isArray(keys) ? keys.filter(Boolean) : [];
   const fallback = Array.isArray(candidateKeys) ? candidateKeys.filter(Boolean) : [];
   const list = primary.length ? primary : fallback;
   if (!list.length) {
     for (const key of Object.keys(row || {})) {
       const norm = normKey(key);
       if (!norm || META_KEYS.has(norm)) continue;
       if (hasCoreSpecValue(row[norm] ?? row[key])) return true;
     }
     return false;
   }
   for (const key of list) {