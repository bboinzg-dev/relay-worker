diff --git a/src/pipeline/persist.js b/src/pipeline/persist.js
index 2478747ad00f60932e3d925ea261d6b9fdebeab8..15d6bd33187075ceb269b820ee858c5162bf445e 100644
--- a/src/pipeline/persist.js
+++ b/src/pipeline/persist.js
@@ -779,50 +779,57 @@ async function saveExtractedSpecs(targetTable, familySlug, rows = [], options =
         const fallbackPn = `pdf:${base}#${rowIndex + 1}`;
         rec.pn = fallbackPn;
         if (!rec.code || !isValidCode(rec.code)) {
           rec.code = fallbackPn;
         }
         if (physicalCols.has('last_error')) {
           rec.last_error = rec.last_error || 'invalid_code_fallback';
         }
         warnings.add('minimal_pn_fallback');
       }
 
       if (!isValidCode(rec.pn)) {
         rec.pn = null;
       }
 
       if (!rec.pn && rec.code) {
         rec.pn = rec.code;
       }
 
       buildPnIfMissing(rec, pnTemplate);
 
       if (!isValidCode(rec.pn) && isValidCode(rec.code)) {
         rec.pn = rec.code;
       }
 
+      // üîπ ÌÖúÌîåÎ¶ø ÎØ∏ÏπòÌôò Ï∞®Îã®: ÏïÑÏßÅ { } Í∞Ä ÎÇ®ÏïÑÏûàÎã§Î©¥ Ïú†Ìö® PN ÏïÑÎãò
+      if (looksLikeTemplate(rec.pn) || looksLikeTemplate(rec.code)) {
+        if (physicalCols.has('last_error')) rec.last_error = 'template_unresolved';
+        result.skipped.push({ reason: 'invalid_code', detail: 'template_unresolved' });
+        continue;
+      }
+
       const pnMissing = !isValidCode(rec.pn);
       if (pnMissing && (pnWasTemplate || codeWasTemplate)) {
         if (physicalCols.has('last_error')) rec.last_error = 'template_render_failed';
         result.skipped.push({ reason: 'invalid_code', detail: 'template_render_failed' });
         continue;
       }
 
       if (!isValidCode(rec.code) && isValidCode(rec.pn)) {
         rec.code = rec.pn;
       }
 
       const guard = shouldInsert(rec, { coreSpecKeys: guardKeys, candidateSpecKeys });
       if (!guard.ok) {
         const skip = { reason: guard.reason, detail: guard.detail || null };
         if (rec.last_error) skip.last_error = rec.last_error;
         result.skipped.push(skip);
         continue;
       }
 
       const pnValue = String(rec.pn || rec.code || '').trim();
       const pnIsFallback = isMinimalFallbackPn(pnValue);
       if (!pnValue || !isValidCode(pnValue) || (!pnIsFallback && FORBIDDEN_RE.test(pnValue))) {
         const skippedCode = pnValue || String(rec.code || rec.pn || '').trim() || '(no-code)';
         if (physicalCols.has('last_error')) rec.last_error = 'invalid_code';
         result.skipped.push({ reason: 'invalid_code', code: skippedCode, last_error: 'invalid_code' });
