diff --git a/server.js b/server.js
index a2cae8edc13afca520c9ec21f59e18ce86251fb7..361363ae6b8c35c88ba7093ecfb0dd024364e122 100644
--- a/server.js
+++ b/server.js
@@ -106,74 +106,98 @@ const PROJECT_ID       = process.env.GCP_PROJECT_ID || process.env.GOOGLE_CLOUD_
 const TASKS_LOCATION   = process.env.TASKS_LOCATION   || 'asia-northeast3';
 const QUEUE_NAME       = process.env.QUEUE_NAME       || 'ingest-queue';
 // step 라우트 폐지 → ingest 하나로 통일
 const WORKER_TASK_URL = process.env.WORKER_TASK_URL || process.env.WORKER_STEP_URL || 'https://<YOUR-RUN-URL>/api/worker/ingest';
 const TASKS_INVOKER_SA = process.env.TASKS_INVOKER_SA || '';
 
 // ⚠️ 외부 API(예: Vertex/HTTP) 가능성이 있는 부팅 태스크는 가드 안에서만 실행
 //   → 아래 부팅 IIFE 내부의  if (!EXT_CALLS_OFF)  블록으로 이동
 //try { require('./src/tasks/embedFamilies').run().catch(console.error); } catch {}
 
 // lazy init: gRPC 문제 대비 regional endpoint + REST fallback
 let _tasks = null;
 let _queuePath = null;
 function getTasks() {
   if (!_tasks) {
     if (!CloudTasksClient) throw new Error('@google-cloud/tasks unavailable');
     // 지역 엔드포인트 + REST fallback(HTTP/1)
     _tasks = new CloudTasksClient({
       fallback: true,
     });
     _queuePath = _tasks.queuePath(PROJECT_ID, TASKS_LOCATION, QUEUE_NAME);
   }
   return { tasks: _tasks, queuePath: _queuePath };
 }
 
+function resolveWorkerTaskUrl() {
+  const rawUrl = WORKER_TASK_URL;
+  if (!rawUrl || /<YOUR-RUN-URL>/i.test(rawUrl)) {
+    throw new Error('WORKER_TASK_URL not configured');
+  }
+  try {
+    return new URL(rawUrl).toString();
+  } catch (err) {
+    const reason = err?.message || err;
+    throw new Error(`Invalid WORKER_TASK_URL: ${reason}`);
+  }
+}
+
+function resolveWorkerAudience(workerUrl) {
+  if (process.env.WORKER_AUDIENCE) return process.env.WORKER_AUDIENCE;
+  try {
+    return new URL(workerUrl).origin;
+  } catch (err) {
+    const reason = err?.message || err;
+    throw new Error(`Unable to derive WORKER audience: ${reason}`);
+  }
+}
+
 async function enqueueIngestTask(payload = {}) {
   const { tasks, queuePath } = getTasks();
   if (!TASKS_INVOKER_SA) throw new Error('TASKS_INVOKER_SA not set');
-  const audience = process.env.WORKER_AUDIENCE || new URL(WORKER_TASK_URL).origin;
+  const workerUrl = resolveWorkerTaskUrl();
+  const audience = resolveWorkerAudience(workerUrl);
 
   const bodyPayload = {
     fromTasks: true,
     payload,
   };
   const body = Buffer.from(JSON.stringify(bodyPayload), 'utf8').toString('base64');
 
   const nowSeconds = Math.floor(Date.now() / 1000);
   const rawDeadline = Number(process.env.TASKS_DEADLINE_SEC || 900);
   const deadlineSeconds = Math.min(Math.max(Number.isFinite(rawDeadline) ? rawDeadline : 900, 30), 1800);
   const delaySeconds = Number(process.env.TASKS_DELAY_SEC || 5);
   const maxAttempts = Number(process.env.TASKS_MAX_ATTEMPTS || 12);
   const minBackoffSeconds = Number(process.env.TASKS_MIN_BACKOFF_SEC || 1);
   const maxBackoffSeconds = Number(process.env.TASKS_MAX_BACKOFF_SEC || 60);
   const maxDoublings = Number(process.env.TASKS_MAX_DOUBLINGS || 4);
 
   const task = {
     httpRequest: {
       httpMethod: 'POST',
-      url: WORKER_TASK_URL,            // ★ ingest 하나로 통일
+      url: workerUrl,            // ★ ingest 하나로 통일
       headers: { 'Content-Type': 'application/json' },
       body,
       ...(TASKS_INVOKER_SA ? { oidcToken: { serviceAccountEmail: TASKS_INVOKER_SA, audience } } : {}),
     },
     // gRPC Duration 객체 (REST가 아님)
     // Cloud Tasks HTTP deadline: default 15m, clamped to [30s, 30m]
     dispatchDeadline: { seconds: deadlineSeconds, nanos: 0 },
     // 콜드스타트/일시 에러 완충
     scheduleTime: { seconds: nowSeconds + delaySeconds },
     retryConfig: {
       maxAttempts,
       minBackoff: { seconds: minBackoffSeconds },
       maxBackoff: { seconds: maxBackoffSeconds },
       maxDoublings,
     },
   };
 
   try {
     await tasks.createTask({ parent: queuePath, task }, { timeout: 10000 });
   } catch (err) {
     const detail = err?.response?.data || err?.message || String(err);
     console.warn('[tasks.createTask] failed', {
       code: err?.code,
       detail,
       queuePath,
