diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index 759ba3123a0211ea18fe2ced42238d28e9b63205..4c519a79c86dc67650069e7fc7059f2d9df455f0 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -6,50 +6,56 @@ const os = require('node:os');
 const crypto = require('node:crypto');
 const { execFile } = require('node:child_process');
 const { promisify } = require('node:util');
 const execFileP = promisify(execFile);
 
 const db = require('../../db');
 const { storage, parseGcsUri, readText, canonicalCoverPath } = require('../utils/gcs');
 const { extractText } = require('../utils/extract');
 const { getBlueprint } = require('../utils/blueprint');
 const { resolveBrand } = require('../utils/brand');
 const { detectVariantKeys } = require('../utils/ordering');
 const { extractPartsAndSpecsFromPdf } = require('../ai/datasheetExtract');
 const { extractFields } = require('./extractByBlueprint');
 const { aiCanonicalizeKeys } = require('./ai/canonKeys');
 const { saveExtractedSpecs, looksLikeTemplate, renderAnyTemplate } = require('./persist');
 const { explodeToRows } = require('../ingest/mpn-exploder');
 const { splitAndCarryPrefix } = require('../utils/mpn-exploder');
 const { ensureSpecColumnsForBlueprint } = require('./ensure-spec-columns');
 const { inferVariantKeys, normalizeSlug } = require('./variant-keys');
 const { classifyByGcs, extractValuesByGcs } = require('../services/vertex');
 const { processDocument: processDocAi } = require('../services/docai');
 const { rankPartNumbersFromOrderingSections } = require('../utils/ordering-sections');
 
 const HARD_CAP_MS = Number(process.env.EXTRACT_HARD_CAP_MS || 120000);
 
+const USE_CODE_RULES = /^(1|true|on)$/i.test(process.env.USE_CODE_RULES ?? '1');
+const USE_PN_TEMPLATE = /^(1|true|on)$/i.test(process.env.USE_PN_TEMPLATE ?? '1');
+const USE_VARIANT_KEYS = /^(1|true|on)$/i.test(
+  process.env.USE_VARIANT_KEYS ?? (process.env.USE_CODE_RULES ?? '1')
+);
+
 function withDeadline(promise, ms = HARD_CAP_MS, label = 'op') {
   const timeout = Number.isFinite(ms) && ms > 0 ? ms : HARD_CAP_MS;
   return new Promise((resolve, reject) => {
     const timer = setTimeout(() => {
       clearTimeout(timer);
       reject(new Error(`${label}_TIMEOUT`));
     }, timeout);
     Promise.resolve(promise)
       .then((value) => {
         clearTimeout(timer);
         resolve(value);
       })
       .catch((err) => {
         clearTimeout(timer);
         reject(err);
       });
   });
 }
 
 const FAST = String(process.env.INGEST_MODE || '').toUpperCase() === 'FAST' || process.env.FAST_INGEST === '1';
 const FAST_PAGES = [0, 1, -1]; // 첫 페이지, 2페이지, 마지막 페이지만
 
 const META_KEYS = new Set(['variant_keys','pn_template','ingest_options']);
 const BASE_KEYS = new Set([
   'family_slug','brand','code','pn','brand_norm','code_norm','pn_norm','series_code',
diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index 759ba3123a0211ea18fe2ced42238d28e9b63205..4c519a79c86dc67650069e7fc7059f2d9df455f0 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -1068,56 +1074,74 @@ async function doIngestPipeline(input = {}, runIdParam = null) {
   const overrideBrandLog = overridesBrand ?? brand ?? '';
   console.log(`[PATH] overrides.brand=${overrideBrandLog || ''} family=${family} runId=${runId || ''}`);
 
 // 목적 테이블
   const reg = await db.query(
     `SELECT specs_table FROM public.component_registry WHERE family_slug=$1 LIMIT 1`,
     [family]
   );
   const table = reg.rows[0]?.specs_table || 'relay_power_specs';
   const qualified = table.startsWith('public.')? table : `public.${table}`;
 
   let blueprint = await getBlueprint(family);
 
   if (!vertexExtractValues && family) {
     try {
       vertexExtractValues = await extractValuesByGcs(gcsUri, family);
     } catch (err) {
       console.warn('[vertex] extract failed:', err?.message || err);
     }
   }
 
   // 블루프린트 허용 키
   let allowedKeys = Array.isArray(blueprint?.allowedKeys)
     ? [...blueprint.allowedKeys]
     : [];
-  let variantKeys = Array.isArray(blueprint?.ingestOptions?.variant_keys)
-    ? blueprint.ingestOptions.variant_keys.map((k) => String(k || '').trim().toLowerCase()).filter(Boolean)
-    : (Array.isArray(blueprint?.variant_keys)
-      ? blueprint.variant_keys.map((k) => String(k || '').trim().toLowerCase()).filter(Boolean)
-      : []);
-  const pnTemplate = blueprint?.ingestOptions?.pn_template || blueprint?.ingestOptions?.pnTemplate || null;
+  if ((!allowedKeys || !allowedKeys.length) && blueprint?.fields && typeof blueprint.fields === 'object') {
+    allowedKeys = Object.keys(blueprint.fields);
+  }
+  allowedKeys = Array.from(
+    new Set(
+      (allowedKeys || [])
+        .map((k) => String(k || '').trim())
+        .filter(Boolean)
+    )
+  );
+
+  let variantKeys = [];
+  if (USE_VARIANT_KEYS) {
+    variantKeys = Array.isArray(blueprint?.ingestOptions?.variant_keys)
+      ? blueprint.ingestOptions.variant_keys
+      : (Array.isArray(blueprint?.variant_keys) ? blueprint.variant_keys : []);
+    variantKeys = variantKeys
+      .map((k) => String(k || '').trim().toLowerCase())
+      .filter(Boolean);
+  }
+
+  const pnTemplate = USE_PN_TEMPLATE
+    ? (blueprint?.ingestOptions?.pn_template || blueprint?.ingestOptions?.pnTemplate || null)
+    : null;
   const requiredFields = [];
   if (blueprint?.fields && typeof blueprint.fields === 'object') {
     for (const [fieldKey, meta] of Object.entries(blueprint.fields)) {
       const isRequired = meta && typeof meta === 'object' && Boolean(meta.required);
       if (!isRequired) continue;
       const normalized = String(fieldKey || '')
         .trim()
         .toLowerCase()
         .replace(/[^a-z0-9_]/g, '');
       if (normalized && !requiredFields.includes(normalized)) {
         requiredFields.push(normalized);
       }
     }
   }
 
   let colTypes;
   const disableEnsure = /^(1|true|on)$/i.test(process.env.NO_SCHEMA_ENSURE || '0');
 
   // -------- 공용 강제정규화 유틸 --------
 
   if (code && !/\d/.test(String(code))) {
     // "AGN","TQ" 처럼 숫자 없는 시리즈는 series로 넘기고 code는 비움
     series = code; code = null;
   }
 
diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index 759ba3123a0211ea18fe2ced42238d28e9b63205..4c519a79c86dc67650069e7fc7059f2d9df455f0 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -1423,162 +1447,166 @@ async function doIngestPipeline(input = {}, runIdParam = null) {
   } catch (err) {
     console.warn('[brand resolve] failed:', err?.message || err);
   }
 
   const brandEffectiveResolved = pickBrandHint(
     brandResolution?.brand_effective,
     brandHintSeed,
     effectiveBrand,
     extracted?.brand,
     detectedBrand,
   ) || 'unknown';
 
   let brandSource = brandResolution?.source || null;
   if (!brandSource || brandSource === 'none') {
     brandSource = brandHintSeed ? 'hint' : 'none';
   }
   if (!brandEffectiveResolved || brandEffectiveResolved.toLowerCase() === 'unknown') {
     brandSource = 'none';
   }
 
   if (extracted && typeof extracted === 'object') {
     extracted.brand = brandEffectiveResolved;
   }
 
   let runtimeVariantKeys = [];
-  try {
-    runtimeVariantKeys = await detectVariantKeys({
-      rawText: extractedText,
-      family,
-      blueprintVariantKeys: variantKeys,
-    });
-  } catch (err) {
-    console.warn('[variant] runtime detect failed:', err?.message || err);
-    runtimeVariantKeys = Array.isArray(variantKeys) ? [...variantKeys] : [];
+  if (USE_VARIANT_KEYS) {
+    try {
+      runtimeVariantKeys = await detectVariantKeys({
+        rawText: extractedText,
+        family,
+        blueprintVariantKeys: variantKeys,
+      });
+    } catch (err) {
+      console.warn('[variant] runtime detect failed:', err?.message || err);
+      runtimeVariantKeys = Array.isArray(variantKeys) ? [...variantKeys] : [];
+    }
   }
 
   console.log('[PATH] brand resolved', {
     runId,
     family,
     hint: brandHintSeed || null,
     effective: brandEffectiveResolved,
     source: brandSource,
     vkeys_runtime: runtimeVariantKeys,
   });
 
 
   // 커버 추출 비활성(요청에 따라 완전 OFF)
   let coverUri = null;
   if (/^(1|true|on)$/i.test(process.env.COVER_CAPTURE || '0')) {
     try {
       const bForCover = brandEffectiveResolved || 'unknown';
       const cForCover = code || extracted.rows?.[0]?.code || path.parse(fileName).name;
       coverUri = await withTimeout(
         extractCoverToGcs(gcsUri, { family, brand: bForCover, code: cForCover }),
         Math.min(30000, Math.round(BUDGET * 0.15)),
         'cover',
       );
     } catch (e) { console.warn('[cover fail]', e?.message || e); }
   }
 
   if (code) {
     const trimmedCode = String(code || '').trim();
     if (trimmedCode) {
       const norm = normalizeCode(trimmedCode);
       if (!candidates.some((c) => normalizeCode(c) === norm)) {
         candidates = [trimmedCode, ...candidates];
       }
     }
   }
 
   // 레코드 구성
   const records = [];
   const now = new Date();
   const brandName = brandEffectiveResolved || 'unknown';
   const baseSeries = series || code || null;
   const runtimeMeta = {
     brand_source: brandSource ?? null,
     variant_keys_runtime: Array.isArray(runtimeVariantKeys) ? runtimeVariantKeys : [],
   };
   const hasRuntimeMeta =
     runtimeMeta.brand_source != null ||
     (Array.isArray(runtimeMeta.variant_keys_runtime) && runtimeMeta.variant_keys_runtime.length > 0);
 
-  let variantColumnsEnsured = false;
-  try {
-    const { detected: inferredKeys = [], newKeys: freshKeys = [] } = await inferVariantKeys({
-      family,
-      brand: brandName,
-      series: baseSeries,
-      blueprint,
-      extracted,
-    });
+  let variantColumnsEnsured = !USE_VARIANT_KEYS;
+  if (USE_VARIANT_KEYS) {
+    try {
+      const { detected: inferredKeys = [], newKeys: freshKeys = [] } = await inferVariantKeys({
+        family,
+        brand: brandName,
+        series: baseSeries,
+        blueprint,
+        extracted,
+      });
 
-    if (Array.isArray(inferredKeys) && inferredKeys.length) {
-      const brandSlug = normalizeSlug(brandName);
-      const seriesSlug = normalizeSlug(baseSeries);
-      try {
-        await db.query(
-          `SELECT public.upsert_variant_keys($1,$2,$3,$4::jsonb)`,
-          [family, brandSlug, seriesSlug, JSON.stringify(inferredKeys)],
-        );
-      } catch (err) {
-        console.warn('[variant] upsert_variant_keys failed:', err?.message || err);
-      }
+      if (Array.isArray(inferredKeys) && inferredKeys.length) {
+        const brandSlug = normalizeSlug(brandName);
+        const seriesSlug = normalizeSlug(baseSeries);
+        try {
+          await db.query(
+            `SELECT public.upsert_variant_keys($1,$2,$3,$4::jsonb)`,
+            [family, brandSlug, seriesSlug, JSON.stringify(inferredKeys)],
+          );
+        } catch (err) {
+          console.warn('[variant] upsert_variant_keys failed:', err?.message || err);
+        }
 
-      const mergedVariant = new Set(variantKeys);
-      for (const key of inferredKeys) mergedVariant.add(key);
-      variantKeys = Array.from(mergedVariant);
+        const mergedVariant = new Set(variantKeys);
+        for (const key of inferredKeys) mergedVariant.add(key);
+        variantKeys = Array.from(mergedVariant);
 
-      const mergedAllowed = new Set(allowedKeys);
-      for (const key of variantKeys) mergedAllowed.add(key);
-      allowedKeys = Array.from(mergedAllowed);
+        const mergedAllowed = new Set(allowedKeys);
+        for (const key of variantKeys) mergedAllowed.add(key);
+        allowedKeys = Array.from(mergedAllowed);
 
-      if (!blueprint.ingestOptions || typeof blueprint.ingestOptions !== 'object') {
-        blueprint.ingestOptions = {};
-      }
-      blueprint.ingestOptions.variant_keys = variantKeys;
-      blueprint.variant_keys = variantKeys;
-      blueprint.allowedKeys = Array.isArray(blueprint.allowedKeys)
-        ? Array.from(new Set([...blueprint.allowedKeys, ...variantKeys]))
-        : [...allowedKeys];
+        if (!blueprint.ingestOptions || typeof blueprint.ingestOptions !== 'object') {
+          blueprint.ingestOptions = {};
+        }
+        blueprint.ingestOptions.variant_keys = variantKeys;
+        blueprint.variant_keys = variantKeys;
+        blueprint.allowedKeys = Array.isArray(blueprint.allowedKeys)
+          ? Array.from(new Set([...blueprint.allowedKeys, ...variantKeys]))
+          : [...allowedKeys];
 
-      if (!disableEnsure) {
-        try {
-          await ensureBlueprintVariantColumns(family);
-          variantColumnsEnsured = true;
-        } catch (err) {
-          console.warn('[variant] ensure_blueprint_variant_columns failed:', err?.message || err);
+        if (!disableEnsure) {
+          try {
+            await ensureBlueprintVariantColumns(family);
+            variantColumnsEnsured = true;
+          } catch (err) {
+            console.warn('[variant] ensure_blueprint_variant_columns failed:', err?.message || err);
+          }
         }
       }
-    }
 
-    if (Array.isArray(freshKeys) && freshKeys.length) {
-      console.log('[variant] detected new keys', { family, brand: brandName, series: baseSeries, keys: freshKeys });
+      if (Array.isArray(freshKeys) && freshKeys.length) {
+        console.log('[variant] detected new keys', { family, brand: brandName, series: baseSeries, keys: freshKeys });
+      }
+    } catch (err) {
+      console.warn('[variant] inferVariantKeys failed:', err?.message || err);
     }
-  } catch (err) {
-    console.warn('[variant] inferVariantKeys failed:', err?.message || err);
   }
 
   if (!disableEnsure) {
     await ensureSpecsTableByFamily(family);
     if (!variantColumnsEnsured) {
       try {
         await ensureBlueprintVariantColumns(family);
         variantColumnsEnsured = true;
       } catch (err) {
         console.warn('[variant] ensure_blueprint_variant_columns fallback failed:', err?.message || err);
       }
     }
   }
 
   await ensureSpecColumnsForBlueprint(qualified, blueprint);
   colTypes = await getColumnTypes(qualified);
 
   if (process.env.AUTO_FIX_BLUEPRINT_TYPES === '1' && colTypes instanceof Map && colTypes.size && family) {
     const currentFields = blueprint?.fields && typeof blueprint.fields === 'object' ? blueprint.fields : {};
     const patch = {};
     for (const [col, t] of colTypes.entries()) {
       if (t === 'numeric' || t === 'int' || t === 'bool') {
         const now = currentFields[col];
         if (!now || String(now).toLowerCase() === 'text') {
           patch[col] = t === 'int' ? 'int' : t;
diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index 759ba3123a0211ea18fe2ced42238d28e9b63205..4c519a79c86dc67650069e7fc7059f2d9df455f0 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -1719,51 +1747,51 @@ async function doIngestPipeline(input = {}, runIdParam = null) {
 
   const candidateMap = [];
   const candidateNormSet = new Set();
   for (const cand of candidates) {
     const trimmed = typeof cand === 'string' ? cand.trim() : String(cand || '');
     if (!trimmed) continue;
     const norm = normalizeCode(trimmed);
     if (!norm || candidateNormSet.has(norm)) continue;
     candidateNormSet.add(norm);
     candidateMap.push({ raw: trimmed, norm });
   }
 
   const baseRows = (rawRows.length ? rawRows : [{}]).map((row) => {
     const obj = row && typeof row === 'object' ? { ...row } : {};
     if (obj.brand == null) obj.brand = brandName;
     const fallbackSeries = obj.series_code || obj.series || baseSeries || null;
     if (fallbackSeries != null) {
       if (obj.series == null) obj.series = fallbackSeries;
       if (obj.series_code == null) obj.series_code = fallbackSeries;
     }
     if (obj.datasheet_uri == null) obj.datasheet_uri = gcsUri;
     if (coverUri && obj.cover == null) obj.cover = coverUri;
     return obj;
   });
 
-  const explodedRows = explodeToRows(blueprint, baseRows);
+  const explodedRows = USE_CODE_RULES ? explodeToRows(blueprint, baseRows) : baseRows;
   const physicalCols = new Set(colTypes ? [...colTypes.keys()] : []);
   const allowedSet = new Set((allowedKeys || []).map((k) => String(k || '').trim().toLowerCase()).filter(Boolean));
   const variantSet = new Set(variantKeys);
 
   const seenCodes = new Set();
   for (const row of explodedRows) {
     const seeds = [];
     const seenSeed = new Set();
     const pushSeed = (val) => {
       if (val == null) return;
       if (Array.isArray(val)) { val.forEach(pushSeed); return; }
       const str = String(val).trim();
       if (!str) return;
       const parts = splitAndCarryPrefix(str);
       if (parts.length > 1) { parts.forEach(pushSeed); return; }
       const normed = str.toLowerCase();
       if (seenSeed.has(normed)) return;
       seenSeed.add(normed);
       seeds.push(str);
     };
     pushSeed(row.code);
     pushSeed(row.mpn);
     pushSeed(row.part_number);
     pushSeed(row.part_no);
 
diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index 759ba3123a0211ea18fe2ced42238d28e9b63205..4c519a79c86dc67650069e7fc7059f2d9df455f0 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -1804,51 +1832,53 @@ async function doIngestPipeline(input = {}, runIdParam = null) {
     const displayName = row.display_name || row.displayname || `${rec.brand} ${mpn}`;
     rec.display_name = displayName;
     if (rec.displayname == null && displayName != null) rec.displayname = displayName;
     rec.updated_at = now;
     // persist에서 브랜드 정규화할 때 쓰도록 원문 텍스트 전달
     rec._doc_text = extractedText;
     if (hasRuntimeMeta) {
       rec.raw_json = mergeRuntimeMetadata(row.raw_json, runtimeMeta);
     } else if (row.raw_json != null) {
       rec.raw_json = row.raw_json;
     }
 
     for (const [rawKey, rawValue] of Object.entries(row)) {
       const key = String(rawKey || '').trim();
       if (!key) continue;
       const lower = key.toLowerCase();
       if (META_KEYS.has(lower) || BASE_KEYS.has(lower)) continue;
       const mapped = aiCanonicalMap.get(key) || aiCanonicalMapLower.get(lower);
       const target = mapped?.canonical || lower;
       if (!target || META_KEYS.has(target) || BASE_KEYS.has(target)) continue;
       if (physicalCols.has(target) || allowedSet.has(target) || variantSet.has(target)) {
         rec[target] = rawValue;
       }
     }
 
-    if (blueprint?.code_rules) applyCodeRules(rec.code, rec, blueprint.code_rules, colTypes);
+    if (USE_CODE_RULES && blueprint?.code_rules) {
+      applyCodeRules(rec.code, rec, blueprint.code_rules, colTypes);
+    }
     records.push(rec);
   }
 
   if (candidateMap.length) {
     const fallbackSeries = baseSeries || null;
     for (const cand of candidateMap) {
       const norm = cand.norm;
       const naturalKey = `${normLower(brandName)}::${norm}`;
       if (seenCodes.has(naturalKey)) continue;
       seenCodes.add(naturalKey);
       const verified = mpnNormFromDoc.has(norm);
       const rec = {
         family_slug: family,
         brand: brandName,
         pn: cand.raw,
         code: cand.raw,
         series_code: fallbackSeries,
         datasheet_uri: gcsUri,
         image_uri: coverUri || null,
         display_name: `${brandName} ${cand.raw}`,
         verified_in_doc: verified,
         updated_at: now,
       };
       if (coverUri) rec.cover = coverUri;
       if (hasRuntimeMeta) {
diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index 759ba3123a0211ea18fe2ced42238d28e9b63205..4c519a79c86dc67650069e7fc7059f2d9df455f0 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -2250,65 +2280,67 @@ async function persistProcessedData(processed = {}, overrides = {}) {
       } catch (err) {
         console.warn('[brand detect] persist retry failed:', err?.message || err);
       }
     }
 
     if (brandOverride) {
       for (const row of records) {
         if (!row || typeof row !== 'object') continue;
         const current = String(row.brand || '').trim();
         if (!current || current.toLowerCase() === 'unknown') {
           row.brand = brandOverride;
         }
       }
       if (Array.isArray(processedRowsInput) && processedRowsInput !== records) {
         for (const row of processedRowsInput) {
           if (!row || typeof row !== 'object') continue;
           const current = String(row.brand || '').trim();
           if (!current || current.toLowerCase() === 'unknown') {
             row.brand = brandOverride;
           }
         }
       }
     }
 
     let blueprint;
-    let variantKeysSource = Array.isArray(processedVariantKeys) ? processedVariantKeys : null;
-    if ((!Array.isArray(variantKeysSource) || !variantKeysSource.length) && family) {
+    let variantKeysSource = USE_VARIANT_KEYS && Array.isArray(processedVariantKeys)
+      ? processedVariantKeys
+      : null;
+    if (USE_VARIANT_KEYS && (!Array.isArray(variantKeysSource) || !variantKeysSource.length) && family) {
       try {
         blueprint = await getBlueprint(family);
         if (!Array.isArray(variantKeysSource) || !variantKeysSource.length) {
           variantKeysSource = Array.isArray(blueprint?.ingestOptions?.variant_keys)
             ? blueprint.ingestOptions.variant_keys
             : null;
         }
       } catch (err) {
         console.warn('[persist] blueprint fetch failed for variant recovery:', err?.message || err);
       }
     }
 
-    const variantKeys = Array.isArray(variantKeysSource)
+    const variantKeys = USE_VARIANT_KEYS && Array.isArray(variantKeysSource)
       ? variantKeysSource.map((k) => String(k || '').trim()).filter(Boolean)
       : [];
 
     for (const r of records) {
       if (!r || typeof r !== 'object') continue;
       if (!Array.isArray(r.candidates) && Array.isArray(processed?.candidateCodes)) {
         r.candidates = processed.candidateCodes;
       }
       const fixed = recoverCode(r, { pnTemplate, variantKeys });
       if (fixed) {
         if (!r.code) r.code = fixed;
         if (!r.pn) r.pn = fixed;
       }
     }
 
     records = records.filter((r) => isValidCode(r?.pn || r?.code));
     if (!records.length) {
       persistResult.skipped = [{ reason: 'missing_pn' }];
     }
 
     if (records.length) {
       if (colTypes instanceof Map && colTypes.size) {
         for (const rec of records) {
           if (!rec || typeof rec !== 'object') continue;
           for (const [k, v] of Object.entries(rec)) {
