diff --git a/server.js b/server.js
index d31951c5034012b6cad9cdb5dc8c88d651290050..6bad0c41b9803fe544266f0e9e61170d47937f56 100644
--- a/server.js
+++ b/server.js
@@ -426,147 +426,157 @@ app.post('/ingest/bulk', requireSession, async (req, res) => {
 });
 
 app.post('/ingest/auto', requireSession, async (req, res) => {
   try {
     const { gcsUri, gcsPdfUri, gcs_uri, gcs_pdf_uri, brand, code, series, display_name, family_slug } = req.body || {};
     const uri = gcsUri || gcsPdfUri || gcs_uri || gcs_pdf_uri;
     if (!uri) return res.status(400).json({ ok:false, error:'gcsUri required' });
     const result = await runAutoIngest({ gcsUri: uri, family_slug, brand, code, series, display_name });
     res.json(result);
   } catch (e) { console.error(e); res.status(400).json({ ok:false, error:String(e?.message || e) }); }
 });
 
 async function handleWorkerIngest(req, res) {
   const startedAt = Date.now();
   const taskName =
     req.get('X-CloudTasks-TaskName') ||
     req.get('X-Cloud-Tasks-TaskName') ||
     null;
   const retryCnt = Number(
     req.get('X-CloudTasks-TaskRetryCount') ||
     req.get('X-Cloud-Tasks-TaskRetryCount') ||
     0
   );
   const payload = req.body || {};
   const fromTasks = Boolean(taskName);
+  const normalizedGsUri = [
+    payload?.gsUri,
+    payload?.gcsUri,
+    payload?.gcsPdfUri,
+    payload?.uri,
+    payload?.url,
+  ].find((value) => typeof value === 'string' && value.trim()) || null;
+  const gsUri = normalizedGsUri ? normalizedGsUri.trim() : null;
 
   if (!fromTasks) {
     try {
-      const { gcsUri, gcsPdfUri, brand, code, series, display_name, family_slug = null } = payload;
-      const uri = gcsUri || gcsPdfUri;
-      if (!uri || !/^gs:\/\//i.test(uri)) {
+      const { brand, code, series, display_name, family_slug = null } = payload;
+      if (!gsUri || !/^gs:\/\//i.test(gsUri)) {
         await db.query(
           `INSERT INTO public.ingest_run_logs (task_name, retry_count, gcs_uri, status, error_message)
              VALUES ($1,$2,$3,'FAILED',$4)`,
-          [taskName, retryCnt, uri || '', 'gcsUri required (gs://...)']
+          [taskName, retryCnt, gsUri || '', 'gsUri/gcsUri required (gs://...)']
         );
-        return res.status(400).json({ ok:false, error:'gcsUri required (gs://...)' });
+        return res.status(400).json({ ok:false, error:'gsUri/gcsUri required (gs://...)' });
       }
 
       const { rows: logRows } = await db.query(
         `INSERT INTO public.ingest_run_logs (task_name, retry_count, gcs_uri, status)
            VALUES ($1,$2,$3,'PROCESSING') RETURNING id`,
-        [taskName, retryCnt, uri]
+        [taskName, retryCnt, gsUri]
       );
       const runId = logRows[0]?.id;
 
       res.status(202).json({ ok: true, run_id: runId });
 
-      enqueueIngestRun({ runId, gcsUri: uri, brand, code, series, display_name, family_slug })
+      enqueueIngestRun({ runId, gcsUri: gsUri, brand, code, series, display_name, family_slug })
         .catch(async (err) => {
           try {
             await db.query(
               `UPDATE public.ingest_run_logs
                   SET finished_at = now(),
                       duration_ms = $2,
                       status = 'FAILED',
                       error_message = $3
                 WHERE id = $1`,
               [ runId, Date.now() - startedAt, `enqueue failed: ${String(err?.message || err)}` ]
             );
           } catch (_) {}
           console.error('[ingest enqueue failed]', err?.message || err);
         });
     } catch (e) {
       try {
         await db.query(
           `UPDATE public.ingest_run_logs
              SET finished_at = now(),
                  duration_ms = $2,
                  status = 'FAILED',
                  error_message = $3
            WHERE task_name = $1
              AND status = 'PROCESSING'
            ORDER BY started_at DESC
            LIMIT 1`,
           [ taskName, Date.now() - startedAt, String(e?.message || e) ]
         );
       } catch (_) {}
       if (!res.headersSent) {
         console.error('[ingest 500]', { error: e?.message });
         return res.status(500).json({ ok:false, error:String(e?.message || e) });
       }
       console.error('[ingest post-ack error]', e?.message || e);
     }
     return;
   }
 
   const deadlineMs = Number(process.env.INGEST_BUDGET_MS || 120000) + 15000;
   const killer = setTimeout(() => {
     if (!res.headersSent) {
       try { res.status(202).json({ ok: true, timeout: true }); } catch {}
     }
   }, deadlineMs);
   console.log(`[ingest-run] killer armed at ${deadlineMs}ms for runId=${payload?.runId || 'n/a'}`);
 
   try {
-    const { runId, gcsUri, gcsPdfUri, brand, code, series, display_name, family_slug = null } = payload;
-    const uri = gcsUri || gcsPdfUri;
-    if (!runId || !uri) return res.status(400).json({ ok:false, error:'runId & gcsUri required' });
+    const { runId, brand, code, series, display_name, family_slug = null } = payload;
+    if (!runId || !gsUri || !/^gs:\/\//i.test(gsUri)) {
+      const statusCode = fromTasks ? 200 : 400;
+      console.warn('[ingest-run] bad payload', { fromTasks, runId, keys: Object.keys(payload || {}) });
+      return res.status(statusCode).json({ ok:false, error:'runId & gsUri required' });
+    }
 
     const label = `[ingest] ${runId}`;
     console.time(label);
-    const out = await runAutoIngest({ gcsUri: uri, brand, code, series, display_name, family_slug });
+    const out = await runAutoIngest({ gcsUri: gsUri, brand, code, series, display_name, family_slug });
     console.timeEnd(label);
 
     await db.query(
       `UPDATE public.ingest_run_logs
           SET finished_at = now(),
               duration_ms = $2,
               status = 'SUCCEEDED',
               final_table = $3,
               final_family = $4,
               final_brand = $5,
               final_code  = $6,
               final_datasheet = $7
         WHERE id = $1`,
       [ runId, (out?.ms ?? (Date.now() - startedAt)),
         out?.specs_table || null,
         out?.family || out?.family_slug || null,
         out?.brand || null,
         (Array.isArray(out?.codes) ? out.codes[0] : out?.code) || null,
-        out?.datasheet_uri || uri ]
+        out?.datasheet_uri || gsUri ]
     );
 
     return res.json({ ok:true, run_id: runId });
   } catch (e) {
     await db.query(
       `UPDATE public.ingest_run_logs
           SET finished_at = now(), duration_ms = $2, status = 'FAILED', error_message = $3
         WHERE id = $1`,
       [ payload?.runId || null, Date.now() - startedAt, String(e?.message || e) ]
     );
     console.error('[ingest-run failed]', e?.message || e);
     if (!res.headersSent) {
       return res.status(500).json({ ok:false, error:String(e?.message||e) });
     }
     console.warn('[ingest-run post-ACK error]', String(e?.message || e));
     return;
   } finally {
     clearTimeout(killer);
   }
 }
 
 const workerIngestMiddlewares = [requireSession, handleWorkerIngest];
 app.post('/api/worker/ingest', workerIngestMiddlewares);
 app.post('/api/worker/ingest/run', workerIngestMiddlewares);
 
