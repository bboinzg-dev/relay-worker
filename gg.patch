diff --git a/server.js b/server.js
index 7e201762e094f30be4939ba0318ec89ef52a6059..26087f339bced2f7188009ec560f09f911cbc72e 100644
--- a/server.js
+++ b/server.js
@@ -123,51 +123,57 @@ async function enqueueIngestTask(payload = {}) {
   const maxAttempts = Number(process.env.TASKS_MAX_ATTEMPTS || 12);
   const minBackoffSeconds = Number(process.env.TASKS_MIN_BACKOFF_SEC || 1);
   const maxBackoffSeconds = Number(process.env.TASKS_MAX_BACKOFF_SEC || 60);
   const maxDoublings = Number(process.env.TASKS_MAX_DOUBLINGS || 4);
 
   const task = {
     httpRequest: {
       httpMethod: 'POST',
       url: WORKER_TASK_URL,            // ★ ingest 하나로 통일
       headers: { 'Content-Type': 'application/json' },
       body,
       ...(TASKS_INVOKER_SA ? { oidcToken: { serviceAccountEmail: TASKS_INVOKER_SA, audience } } : {}),
     },
     // gRPC Duration 객체 (REST가 아님)
     dispatchDeadline: { seconds: deadlineSeconds, nanos: 0 },
     // 콜드스타트/일시 에러 완충
     scheduleTime: { seconds: nowSeconds + delaySeconds },
     retryConfig: {
       maxAttempts,
       minBackoff: { seconds: minBackoffSeconds },
       maxBackoff: { seconds: maxBackoffSeconds },
       maxDoublings,
     },
   };
 
-  await tasks.createTask({ parent: queuePath, task }, { timeout: 10000 });
+  try {
+    await tasks.createTask({ parent: queuePath, task }, { timeout: 10000 });
+  } catch (err) {
+    const detail = err?.response?.data || err?.message || String(err);
+    console.warn('[tasks.createTask] failed', { code: err?.code, detail, queuePath });
+    throw err;
+  }
 }
 
 
 const app = express();
 
 // ✅ 항상 찍히는 부팅 로그 + 간단 헬스/정보
 console.log('[BOOT] server.js starting', {
   file: __filename,
   node: process.version,
   ROUTE_DEBUG: process.env.ROUTE_DEBUG || null,
   revision: process.env.K_REVISION || null,
 });
 
 // 가장 가벼운 핑
 app.get('/_ping', (_req, res) => res.json({ ok: true, rev: process.env.K_REVISION || null }));
 
 // 현재 실행 중인 엔트리/디렉토리 확인 (정말 server.js가 실행되는지 확인)
 app.get('/_whoami', (_req, res) => {
   try {
     res.json({
       main: require.main && require.main.filename,
       dir: __dirname,
       ROUTE_DEBUG: process.env.ROUTE_DEBUG || null
     });
   } catch (e) {
diff --git a/server.js b/server.js
index 7e201762e094f30be4939ba0318ec89ef52a6059..26087f339bced2f7188009ec560f09f911cbc72e 100644
--- a/server.js
+++ b/server.js
@@ -1031,51 +1037,86 @@ async function handleWorkerIngest(req, res) {
 
         const nextPayload = {
           runId,
           run_id: runId,
           gcsUri,
           gcs_uri: gcsUri,
           family_slug: payload?.family_slug ?? null,
           brand: payload?.brand ?? null,
           code: payload?.code ?? null,
           series: payload?.series ?? null,
           display_name: payload?.display_name ?? null,
           uploader_id: payload?.uploader_id ?? null,
           phase: 'persist',
           processed,
           overrides: nextOverrides,
         };
 
         try {
           await enqueueIngestTask(nextPayload);
         } catch (err) {
           console.error(
             '[enqueue error]',
             err?.code || err?.response?.status || err?.message,
             err?.response?.data ? JSON.stringify(err.response.data) : (err?.details || '')
           );
-          throw new Error(`persist enqueue failed: ${String(err?.message || err)}`);
+          console.warn('[ingest][persist fallback] attempting inline persist', { runId });
+          try {
+            await markPersisting(baseContext);
+            const inlineResult = await getIngest().persistProcessedData(processed || {}, {
+              brand: overrideBrand,
+              code: payload?.code ?? null,
+              series: overrideSeries,
+              display_name: payload?.display_name ?? null,
+            });
+
+            const failureReasons = new Set(Array.isArray(inlineResult?.reject_reasons) ? inlineResult.reject_reasons : []);
+            const warningReasons = new Set(Array.isArray(inlineResult?.warnings) ? inlineResult.warnings : []);
+
+            if (!inlineResult?.ok) {
+              const reasonList = Array.from(new Set([...failureReasons, ...warningReasons]));
+              const message = reasonList.length ? reasonList.join(',') : 'ingest_rejected';
+              await markFailed({
+                ...baseContext,
+                error: message,
+                durationMs: inlineResult?.ms ?? (Date.now() - startedAt),
+              });
+              return;
+            }
+
+            await markSucceeded({
+              ...baseContext,
+              result: inlineResult,
+              gcsUri,
+              durationMs: inlineResult?.ms ?? (Date.now() - startedAt),
+              meta: payload,
+            });
+            return;
+          } catch (fallbackErr) {
+            console.error('[ingest][persist fallback] failed', fallbackErr?.message || fallbackErr);
+            throw new Error(`persist enqueue failed: ${String(err?.message || err)}; fallback failed: ${String(fallbackErr?.message || fallbackErr)}`);
+          }
         }
         return;
       }
 
       if (phase === 'persist') {
         await markPersisting(baseContext);
 
         const overrideBrand = payload?.overrides?.brand ?? payload?.brand ?? null;
         const overrideSeries = payload?.overrides?.series ?? payload?.series ?? null;
 
         const out = await getIngest().persistProcessedData(payload?.processed || {}, {
           brand: overrideBrand,
           code: payload?.code ?? null,
           series: overrideSeries,
           display_name: payload?.display_name ?? null,
         });
 
         const failureReasons = new Set(Array.isArray(out?.reject_reasons) ? out.reject_reasons : []);
         const warningReasons = new Set(Array.isArray(out?.warnings) ? out.warnings : []);
 
         if (!out?.ok) {
           const reasonList = Array.from(new Set([...failureReasons, ...warningReasons]));
           const message = reasonList.length ? reasonList.join(',') : 'ingest_rejected';
           await markFailed({
             ...baseContext,
diff --git a/server.js b/server.js
index 7e201762e094f30be4939ba0318ec89ef52a6059..26087f339bced2f7188009ec560f09f911cbc72e 100644
--- a/server.js
+++ b/server.js
@@ -123,51 +123,57 @@ async function enqueueIngestTask(payload = {}) {
   const maxAttempts = Number(process.env.TASKS_MAX_ATTEMPTS || 12);
   const minBackoffSeconds = Number(process.env.TASKS_MIN_BACKOFF_SEC || 1);
   const maxBackoffSeconds = Number(process.env.TASKS_MAX_BACKOFF_SEC || 60);
   const maxDoublings = Number(process.env.TASKS_MAX_DOUBLINGS || 4);
 
   const task = {
     httpRequest: {
       httpMethod: 'POST',
       url: WORKER_TASK_URL,            // ★ ingest 하나로 통일
       headers: { 'Content-Type': 'application/json' },
       body,
       ...(TASKS_INVOKER_SA ? { oidcToken: { serviceAccountEmail: TASKS_INVOKER_SA, audience } } : {}),
     },
     // gRPC Duration 객체 (REST가 아님)
     dispatchDeadline: { seconds: deadlineSeconds, nanos: 0 },
     // 콜드스타트/일시 에러 완충
     scheduleTime: { seconds: nowSeconds + delaySeconds },
     retryConfig: {
       maxAttempts,
       minBackoff: { seconds: minBackoffSeconds },
       maxBackoff: { seconds: maxBackoffSeconds },
       maxDoublings,
     },
   };
 
-  await tasks.createTask({ parent: queuePath, task }, { timeout: 10000 });
+  try {
+    await tasks.createTask({ parent: queuePath, task }, { timeout: 10000 });
+  } catch (err) {
+    const detail = err?.response?.data || err?.message || String(err);
+    console.warn('[tasks.createTask] failed', { code: err?.code, detail, queuePath });
+    throw err;
+  }
 }
 
 
 const app = express();
 
 // ✅ 항상 찍히는 부팅 로그 + 간단 헬스/정보
 console.log('[BOOT] server.js starting', {
   file: __filename,
   node: process.version,
   ROUTE_DEBUG: process.env.ROUTE_DEBUG || null,
   revision: process.env.K_REVISION || null,
 });
 
 // 가장 가벼운 핑
 app.get('/_ping', (_req, res) => res.json({ ok: true, rev: process.env.K_REVISION || null }));
 
 // 현재 실행 중인 엔트리/디렉토리 확인 (정말 server.js가 실행되는지 확인)
 app.get('/_whoami', (_req, res) => {
   try {
     res.json({
       main: require.main && require.main.filename,
       dir: __dirname,
       ROUTE_DEBUG: process.env.ROUTE_DEBUG || null
     });
   } catch (e) {
diff --git a/server.js b/server.js
index 7e201762e094f30be4939ba0318ec89ef52a6059..26087f339bced2f7188009ec560f09f911cbc72e 100644
--- a/server.js
+++ b/server.js
@@ -1031,51 +1037,86 @@ async function handleWorkerIngest(req, res) {
 
         const nextPayload = {
           runId,
           run_id: runId,
           gcsUri,
           gcs_uri: gcsUri,
           family_slug: payload?.family_slug ?? null,
           brand: payload?.brand ?? null,
           code: payload?.code ?? null,
           series: payload?.series ?? null,
           display_name: payload?.display_name ?? null,
           uploader_id: payload?.uploader_id ?? null,
           phase: 'persist',
           processed,
           overrides: nextOverrides,
         };
 
         try {
           await enqueueIngestTask(nextPayload);
         } catch (err) {
           console.error(
             '[enqueue error]',
             err?.code || err?.response?.status || err?.message,
             err?.response?.data ? JSON.stringify(err.response.data) : (err?.details || '')
           );
-          throw new Error(`persist enqueue failed: ${String(err?.message || err)}`);
+          console.warn('[ingest][persist fallback] attempting inline persist', { runId });
+          try {
+            await markPersisting(baseContext);
+            const inlineResult = await getIngest().persistProcessedData(processed || {}, {
+              brand: overrideBrand,
+              code: payload?.code ?? null,
+              series: overrideSeries,
+              display_name: payload?.display_name ?? null,
+            });
+
+            const failureReasons = new Set(Array.isArray(inlineResult?.reject_reasons) ? inlineResult.reject_reasons : []);
+            const warningReasons = new Set(Array.isArray(inlineResult?.warnings) ? inlineResult.warnings : []);
+
+            if (!inlineResult?.ok) {
+              const reasonList = Array.from(new Set([...failureReasons, ...warningReasons]));
+              const message = reasonList.length ? reasonList.join(',') : 'ingest_rejected';
+              await markFailed({
+                ...baseContext,
+                error: message,
+                durationMs: inlineResult?.ms ?? (Date.now() - startedAt),
+              });
+              return;
+            }
+
+            await markSucceeded({
+              ...baseContext,
+              result: inlineResult,
+              gcsUri,
+              durationMs: inlineResult?.ms ?? (Date.now() - startedAt),
+              meta: payload,
+            });
+            return;
+          } catch (fallbackErr) {
+            console.error('[ingest][persist fallback] failed', fallbackErr?.message || fallbackErr);
+            throw new Error(`persist enqueue failed: ${String(err?.message || err)}; fallback failed: ${String(fallbackErr?.message || fallbackErr)}`);
+          }
         }
         return;
       }
 
       if (phase === 'persist') {
         await markPersisting(baseContext);
 
         const overrideBrand = payload?.overrides?.brand ?? payload?.brand ?? null;
         const overrideSeries = payload?.overrides?.series ?? payload?.series ?? null;
 
         const out = await getIngest().persistProcessedData(payload?.processed || {}, {
           brand: overrideBrand,
           code: payload?.code ?? null,
           series: overrideSeries,
           display_name: payload?.display_name ?? null,
         });
 
         const failureReasons = new Set(Array.isArray(out?.reject_reasons) ? out.reject_reasons : []);
         const warningReasons = new Set(Array.isArray(out?.warnings) ? out.warnings : []);
 
         if (!out?.ok) {
           const reasonList = Array.from(new Set([...failureReasons, ...warningReasons]));
           const message = reasonList.length ? reasonList.join(',') : 'ingest_rejected';
           await markFailed({
             ...baseContext,
