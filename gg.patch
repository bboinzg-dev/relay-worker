diff --git a/src/utils/schema.js b/src/utils/schema.js
index 235f47f909d1999083952ed926f6cbab57cdfe08..8df51be71b6c4a4907e2e4801d954c9c1b472b4b 100644
--- a/src/utils/schema.js
+++ b/src/utils/schema.js
@@ -123,37 +123,43 @@ async function upsertByBrandCode(tableName, values = {}) {
       where table_schema=$1 and table_name=$2`,
     [schema, table],
   );
   const allowed = new Set(meta.rows.map((r) => String(r.column_name).toLowerCase()));
   const generated = new Set(
     meta.rows
       .filter((r) => String(r.is_generated || '').toUpperCase() === 'ALWAYS')
       .map((r) => String(r.column_name).toLowerCase()),
   );
 
   const insertCols = [];
   const insertVals = [];
   for (const col of cols) {
     if (!allowed.has(col)) continue;
     if (generated.has(col)) continue;
     insertCols.push(col);
     insertVals.push(payload[col]);
   }
   if (!insertCols.length) return null;
 
   const params = insertCols.map((_, i) => `$${i + 1}`);
   const updates = insertCols
     .filter((col) => !NO_UPDATE.has(col))
     .map((col) => `${col}=EXCLUDED.${col}`);
 
+  // Spec tables enforce uniqueness via the expression index (lower(brand), lower(pn)).
+  // Prefer targeting the named index when available, but fall back to the raw expression.
+  const conflictByExpr = `ON CONFLICT ((lower(brand)), (lower(pn)))`;
+  const conflictByName = `ON CONFLICT ON CONSTRAINT ux_${table}_brandpn_expr`;
+  const conflict = table ? conflictByName : conflictByExpr;
+
   const sql = `
     insert into ${qualified} (${insertCols.join(',')})
     values (${params.join(',')})
-    on conflict (brand_norm, pn)
+    ${conflict}
     do update set ${updates.length ? `${updates.join(', ')}, ` : ''}updated_at=now()
     returning *`;
 
   const res = await db.query(sql, insertVals);
   return res.rows?.[0] || null;
 }
 
 module.exports = { upsertByBrandCode };
