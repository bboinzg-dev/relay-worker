diff --git a/src/utils/schema.js b/src/utils/schema.js
index 969bc26f529db9171e9bf9901815eb1342c46c36..f8fa56a7dcf1ed727f12756d9ad965d733132cdd 100644
--- a/src/utils/schema.js
+++ b/src/utils/schema.js
@@ -264,51 +264,61 @@ async function upsertByBrandCode(tableName, values = {}) {
   if (!insertCols.length) return null;
 
   const params = insertCols.map((_, i) => `$${i + 1}`);
   const updates = insertCols
     .filter((col) => !NO_UPDATE.has(col))
     .map((col) => `${col}=EXCLUDED.${col}`);
 
   // Spec tables enforce uniqueness via the expression index (lower(brand), lower(pn)).
   // The backing database creates this as an expression index (not a constraint),
   // therefore we must always target the raw expression in ON CONFLICT clauses.
   const conflict = `ON CONFLICT ((lower(brand)), (lower(pn)))`;
 
   const sql = `
     insert into ${qualified} (${insertCols.join(',')})
     values (${params.join(',')})
     ${conflict}
     do update set ${updates.length ? `${updates.join(', ')}, ` : ''}updated_at=now()
     returning *`;
 
   const res = await db.query(sql, insertVals);
   return res.rows?.[0] || null;
 }
 
 async function ensureSpecsFtsIndices() {
   try {
-    const res = await db.query(
-      `SELECT specs_table FROM public.component_registry`
-    );
+    const res = await db.query(`SELECT specs_table FROM public.component_registry`);
     for (const row of res.rows || []) {
       const raw = String(row.specs_table || '').trim();
       if (!raw) continue;
       let parsed;
       try {
         parsed = parseTableName(raw);
       } catch (err) {
         console.warn('[schema] skip FTS index for table', raw, err?.message || err);
         continue;
       }
       const { schema, table, qualified } = parsed;
       const indexName = normalizeIdentifier(`${schema}_${table}_gin_fts`);
       if (!indexName) continue;
+
+      const colsRes = await db.query(
+        `SELECT column_name FROM information_schema.columns
+           WHERE table_schema=$1 AND table_name=$2 AND column_name IN ('series','contact_form')`,
+        [schema || 'public', table]
+      );
+      const have = new Set(colsRes.rows.map((r) => r.column_name));
+      const parts = [`COALESCE(raw_json::text,'')`];
+      if (have.has('series')) parts.push(`COALESCE(series,'')`);
+      if (have.has('contact_form')) parts.push(`COALESCE(contact_form,'')`);
+      const expr = `to_tsvector('simple', ${parts.join("||' '||")})`;
+
       await db.query(
-        `CREATE INDEX IF NOT EXISTS ${indexName} ON ${qualified} USING GIN (to_tsvector('simple', COALESCE(series,'')||' '||COALESCE(contact_form,'')||' '||COALESCE(raw_json::text,'')))`
+        `CREATE INDEX IF NOT EXISTS ${indexName} ON ${qualified} USING GIN (${expr})`
       );
     }
   } catch (err) {
     console.warn('[schema] ensureSpecsFtsIndices failed:', err?.message || err);
   }
 }
 
 module.exports = { ensureSpecsTable, upsertByBrandCode, ensureSpecsFtsIndices };
\ No newline at end of file