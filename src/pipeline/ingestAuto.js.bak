/* src/pipeline/ingestAuto.js */
'use strict';

/**
 * CommonJS( require ) 환경에서 안전하게 동작하도록
 * 모든 await는 async 함수 내부로만 배치했습니다.
 * pdfimages( poppler-utils )가 없으면 cover 추출은 건너뜁니다.
 */

const path = require('node:path');
const os = require('node:os');
const fs = require('node:fs/promises');
const { promisify } = require('node:util');
const { execFile } = require('node:child_process');
const execFileP = promisify(execFile);

const db = require('../../db');
const {
  storage,
  canonicalDatasheetPath,
  canonicalCoverPath,
  moveObject,
} = require('../utils/gcs');

const { ensureSpecsTable, upsertByBrandCode } = require('../utils/schema');

/* ---------------- helpers ---------------- */

// gs://bucket/path → { bucket, name }
function parseGcsUri(gcsUri) {
  const m = /^gs:\/\/([^/]+)\/(.+)$/.exec(String(gcsUri || ''));
  if (!m) throw new Error('INVALID_GCS_URI');
  return { bucket: m[1], name: m[2] };
}

function trimLower(x) { return String(x || '').trim(); }
function safeLower(x) { return trimLower(x).toLowerCase(); }

function randomTempCode() {
  return 'TMP_' + Math.random().toString(16).slice(2, 8).toUpperCase();
}

async function guessSpecsTable(familySlug) {
  if (!familySlug) return null;
  try {
    const { rows } = await db.query(
      `SELECT specs_table
         FROM public.component_registry
        WHERE family_slug = $1
        LIMIT 1`,
      [familySlug]
    );
    return rows[0]?.specs_table || null;
  } catch {
    return null;
  }
}

/**
 * pdfimages로 1~2페이지에서 가장 큰 PNG를 뽑아 GCS 업로드
 * - 실패(미설치/이미지 없음/권한 문제)는 조용히 null 반환
 */
async function tryExtractCover(gcsPdfUri, { family, brand, code }) {
  try {
    const { bucket, name } = parseGcsUri(gcsPdfUri);

    // GCS → 로컬 임시 PDF 저장
    const tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'pp-ds-'));
    const localPdf = path.join(tmpDir, 'doc.pdf');
    const [buf] = await storage.bucket(bucket).file(name).download();
    await fs.writeFile(localPdf, buf);

    // 1~2페이지 이미지 추출
    // pdfimages가 없으면 ENOENT 발생 → catch에서 null
    await execFileP('pdfimages', ['-f', '1', '-l', '2', '-png', localPdf, path.join(tmpDir, 'img')]);

    // 추출된 파일 중 가장 큰 PNG 고르기
    const files = await fs.readdir(tmpDir);
    const pngs = files.filter(f => /^img-\d+-\d+\.png$/i.test(f));
    if (!pngs.length) return null;

    let pick = null, maxSize = -1;
    for (const f of pngs) {
      const st = await fs.stat(path.join(tmpDir, f));
      if (st.size > maxSize) { pick = f; maxSize = st.size; }
    }
    if (!pick) return null;

    // 결과 업로드 경로 구성 (자산 버킷 우선: ASSET_BUCKET → GCS_BUCKET)
    const assetBucket = (process.env.ASSET_BUCKET || process.env.GCS_BUCKET || '').replace(/^gs:\/\//, '');
    if (!assetBucket) return null;

    const coverGsUri = canonicalCoverPath(assetBucket, family, brand, code); // "gs://bucket/..." 형태 반환 가정
    const dst = parseGcsUri(coverGsUri);
    await storage.bucket(dst.bucket).upload(path.join(tmpDir, pick), {
      destination: dst.name, resumable: false, validation: false,
      metadata: { contentType: 'image/png', cacheControl: 'public, max-age=31536000' },
    });

    return coverGsUri;
  } catch {
    return null; // 어떤 실패든 조용히 무시
  }
}

/**
 * family가 주어지지 않았을 때의 폴백:
 *  1) component_registry의 아무거나 쓰지 않고,
 *  2) 안전하게 기존 릴레이 테이블로 폴백
 */
function fallbackFamilyAndTable() {
  return { family: 'relay_power', table: 'public.relay_power_specs' };
}

/* ---------------- main ---------------- */

/**
 * @param {Object} opts
 * @param {string} opts.gcsUri         gs://... 입력 (필수)
 * @param {string} [opts.family_slug]  부품군
 * @param {string} [opts.brand]
 * @param {string} [opts.code]
 * @param {string} [opts.series]
 * @param {string} [opts.display_name]
 */
async function runAutoIngest(opts = {}) {
  const t0 = Date.now();

  const srcUri = String(opts.gcsUri || opts.gcsPdfUri || '');
  if (!/^gs:\/\//i.test(srcUri)) {
    throw new Error('gcsUri required (gs://...)');
  }

  // 입력 정규화
  const familyIn = safeLower(opts.family_slug || '');
  const brandIn  = trimLower(opts.brand || '');
  const codeIn   = trimLower(opts.code || '');

  // family / table 결정
  let family = familyIn || null;
  let table  = null;

  if (family) {
    table = await guessSpecsTable(family);
  }
  if (!table) {
    const fb = fallbackFamilyAndTable();
    family = family || fb.family;
    table  = table  || fb.table;
  }

  // 브랜드/코드 기본값
  const brand = brandIn || 'UNKNOWN';
  const code  = codeIn  || randomTempCode();

  // 데이터시트 정규 경로로 이동(또는 복사)
  let finalDsUri = srcUri;
  try {
    const bucketForDs = (process.env.GCS_BUCKET || process.env.ASSET_BUCKET || '').replace(/^gs:\/\//, '');
    if (bucketForDs) {
      const canonical = canonicalDatasheetPath(bucketForDs, family, brand, code); // "gs://bucket/..." 가정
      finalDsUri = await moveObject(srcUri, canonical); // move 실패해도 catch에서 finalDsUri를 src로 유지
    }
  } catch {
    finalDsUri = srcUri;
  }

  // 테이블 보장 + 업서트
  await ensureSpecsTable(table, {}); // 컬럼 자동 확장 로직이 있다면 {}로 호출 (기존 호환)
  const upsertRow = await upsertByBrandCode(table, {
    brand, code,
    series: opts.series || null,
    display_name: opts.display_name || null,
    family_slug: family,
    datasheet_uri: finalDsUri,
    source_gcs_uri: srcUri,
    raw_json: null, // 나중에 DocAI 연결 시 채움
  });

  // 대표 이미지 시도 (있으면 image_uri / cover 중 존재하는 컬럼만 갱신)
  const coverUri = await tryExtractCover(finalDsUri, { family, brand, code });
  if (coverUri) {
    // 동적 테이블명은 식별자를 안전하게 보장된 값만 사용 (component_registry에서 온 값 + 폴백만 허용)
    // 컬럼 존재 유무에는 의존하지 않도록 개별 try로 감쌈
    const whereArgs = [brand, code, family];
    try {
      await db.query(
        `UPDATE ${table}
            SET image_uri = COALESCE($1, image_uri)
          WHERE brand_norm = lower($2) AND code_norm = lower($3) AND family_slug = $4`,
        [coverUri, ...whereArgs]
      );
    } catch (_) {}
    try {
      await db.query(
        `UPDATE ${table}
            SET cover = COALESCE($1, cover)
          WHERE brand_norm = lower($2) AND code_norm = lower($3) AND family_slug = $4`,
        [coverUri, ...whereArgs]
      );
    } catch (_) {}
  }

  const ms = Date.now() - t0;

  // server.js가 기대하는 키들(호환용) 그대로 반환
  return {
    ok: true,
    ms,
    family,
    family_slug: family,
    specs_table: table,
    brand,
    code,
    codes: [code],
    datasheet_uri: finalDsUri,
    // 디버깅/호환
    rows: 1,
    cover_uri: coverUri || null,
    upsert_row: upsertRow || null,
  };
}

module.exports = { runAutoIngest };
