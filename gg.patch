diff --git a/server.js b/server.js
index 591a4311fe63f7e6db2298c0c9844bc46e1d4c2b..6ec2272d1b10bd10672135ffe6130c1cb308383b 100644
--- a/server.js
+++ b/server.js
@@ -1,40 +1,47 @@
 /* server.js */
 'use strict';
 
 // ───────── 외부콜 차단 플래그 (배포 시 EXT_CALLS_OFF=1 이면 부팅 중 외부 HTTPS 호출 스킵)
 const EXT_CALLS_OFF = process.env.EXT_CALLS_OFF === '1';
+const { randomUUID } = require('node:crypto');
 // ---- run-id safe import (fallback to UUID) ----
 let generateRunId;
 try {
   ({ generateRunId } = require('./src/utils/run-id'));
 } catch (e) {
   console.warn('[BOOT] run-id util missing:', e?.message || e);
 }
-if (typeof generateRunId !== 'function') {
-  const { randomUUID } = require('node:crypto');
-  generateRunId = () => randomUUID(); // uuid v4 → DB ingest_jobs.id(uuid)와도 호환
+// ✅ 어떤 상황에서도 안전하게 runId를 생성하는 래퍼 (정의 유무와 무관)
+function newRunId() {
+  try {
+    // typeof는 미정의 변수에도 안전
+    // eslint-disable-next-line no-undef
+    return (typeof generateRunId === 'function') ? generateRunId() : randomUUID();
+  } catch {
+    return randomUUID();
+  }
 }
 // ----------------------------------------------
 
 process.on('uncaughtException', (e) => {
   console.error('[FATAL][uncaughtException]', e?.message, e?.stack?.split('\n').slice(0, 4).join(' | '));
   process.exit(1);
 });
 process.on('unhandledRejection', (e) => {
   console.error('[FATAL][unhandledRejection]', e);
   process.exit(1);
 });
 
 // 필수 env 스모크 로그(민감값 제외)
 (() => {
   const pick = (k) => (process.env[k] || '').toString();
   console.log('[BOOT env check]', {
     GCP_PROJECT_ID: !!pick('GCP_PROJECT_ID'),
     VERTEX_LOCATION: pick('VERTEX_LOCATION'),
     DOCAI_PROCESSOR_ID: !!pick('DOCAI_PROCESSOR_ID'),
     GCS_BUCKET: pick('GCS_BUCKET'),
     QUEUE_NAME: pick('QUEUE_NAME'),
     TASKS_LOCATION: pick('TASKS_LOCATION'),
     GEMINI_MODEL_CLASSIFY: pick('GEMINI_MODEL_CLASSIFY'),
     GEMINI_MODEL_EXTRACT: pick('GEMINI_MODEL_EXTRACT'),
     JWT_SECRET: !!pick('JWT_SECRET'),
diff --git a/server.js b/server.js
index 591a4311fe63f7e6db2298c0c9844bc46e1d4c2b..6ec2272d1b10bd10672135ffe6130c1cb308383b 100644
--- a/server.js
+++ b/server.js
@@ -932,51 +939,51 @@ async function markSucceeded({ runId, taskName, retryCount, result, gcsUri, dura
         WHERE id = $1`,
       [ runId, ms, taskName || null, safeRetryCount,
         result?.specs_table || null,
         family,
         brand,
         code,
         datasheet ]
     );
   } catch (err) {
     console.error('[ingest markSucceeded]', err?.message || err);
   }
   const sourceUri = gcsUri || result?.datasheet_uri || meta?.datasheet_uri || null;
   const sourceType = detectSourceType(sourceUri);
   await setJobStatus(runId, 'SUCCEEDED', null, sourceType, sourceUri);
 }
 
 async function handleWorkerIngest(req, res) {
   const rawBody = (req.body && typeof req.body === 'object') ? req.body : {};
   const payload = rawBody.fromTasks && rawBody.payload && typeof rawBody.payload === 'object'
     ? rawBody.payload
     : rawBody;
 
   const phaseInput = String(payload.phase || rawBody.phase || 'start').toLowerCase();
   const knownPhases = new Set(['start', 'process', 'persist']);
   const phase = knownPhases.has(phaseInput) ? phaseInput : 'start';
-  const runId = pickFirstString(payload.runId, payload.run_id, rawBody.runId, rawBody.run_id) || generateRunId();
+  const runId = pickFirstString(payload.runId, payload.run_id, rawBody.runId, rawBody.run_id) || newRunId();
   const gcsUri = pickFirstString(
     payload.gcsUri,
     payload.gcs_uri,
     payload.gsUri,
     payload.gcsPdfUri,
     payload.gcs_pdf_uri,
     payload.uri,
     payload.url,
     rawBody.gcsUri,
     rawBody.gcs_uri,
     rawBody.gsUri,
     rawBody.gcsPdfUri,
     rawBody.uri,
     rawBody.url
   );
 
   if (!res.headersSent) {
     res.status(202).json({ ok: true, run_id: runId, runId, phase });
   }
 
   const { taskName, retryCount } = getTaskContext(req, phase);
 
   setImmediate(async () => {
     const startedAt = Date.now();
     const baseContext = { runId, gcsUri, taskName, retryCount };
