diff --git a/src/pipeline/persist.js b/src/pipeline/persist.js
index 35f261c5dc72dca5b9c3b0304c43d2afef1e432d..f1adf3509fd041b1a20713e241b22010142eac86 100644
--- a/src/pipeline/persist.js
+++ b/src/pipeline/persist.js
@@ -832,92 +832,94 @@ function hasCoreSpec(row, keys = [], candidateKeys = []) {
   for (const key of list) {
     const norm = normKey(key);
     if (!norm) continue;
     if (hasCoreSpecValue(row[norm] ?? row[key])) return true;
   }
   return false;
 }
 
 function isMinimalInsertEnabled() {
   return String(process.env.ALLOW_MINIMAL_INSERT || '').trim() === '1';
 }
 
 function shouldInsert(row, { coreSpecKeys, candidateSpecKeys } = {}) {
   if (!row || typeof row !== 'object') {
     return { ok: false, reason: 'empty_row' };
   }
 
   const brand = String(row.brand || '').trim().toLowerCase();
   if (!brand || brand === 'unknown') {
     row.last_error = 'missing_brand';
     return { ok: false, reason: 'missing_brand' };
   }
 
   let pn = String(row.pn || row.code || '').trim();
   const allowMinimal = isMinimalInsertEnabled();
+  const docType = String(row.doc_type || '').trim().toLowerCase();
+  const allowForOrdering = docType === 'ordering' || Boolean(row.verified_in_doc);
   if (!isValidCode(pn)) {
     const rawPn = String(row.pn || '').trim();
     const rawCode = String(row.code || '').trim();
     if ((rawPn && /\{[^}]*\}/.test(rawPn)) || (rawCode && /\{[^}]*\}/.test(rawCode))) {
       row.last_error = 'invalid_code_template_placeholder';
       return { ok: false, reason: 'invalid_code' };
     }
     const fixed = repairPn(pn);
     if (fixed && isValidCode(fixed)) {
       console.warn('[persist] pn repaired', { original: pn, fixed });
       row.last_error = row.last_error || 'invalid_code_fixed';
       pn = fixed;
     } else if (allowMinimal) {
       const fallbackPn = repairPn(String(row.series || row.code || ''));
       if (fallbackPn && isValidCode(fallbackPn)) {
         console.warn('[persist] pn fallback applied', { original: pn, fallback: fallbackPn });
         pn = fallbackPn;
         row.last_error = row.last_error || 'invalid_code_fallback';
       } else {
         row.last_error = 'invalid_code';
         return { ok: false, reason: 'invalid_code' };
       }
     } else {
       row.last_error = 'invalid_code';
       return { ok: false, reason: 'invalid_code' };
     }
   } else {
     if (FORBIDDEN_RE.test(pn) || BANNED_PREFIX.test(pn) || BANNED_EXACT.test(pn)) {
       const fixed = repairPn(pn);
       if (fixed && isValidCode(fixed) && !FORBIDDEN_RE.test(fixed) && !BANNED_PREFIX.test(fixed) && !BANNED_EXACT.test(fixed)) {
         console.warn('[persist] pn repaired', { original: pn, fixed });
         row.last_error = row.last_error || 'invalid_code_fixed';
         pn = fixed;
       } else {
         row.last_error = 'invalid_code';
         return { ok: false, reason: 'invalid_code' };
       }
     }
   }
   row.pn = pn;
   if (row.code == null || String(row.code).trim() === '') row.code = pn;
-  if (!hasCoreSpec(row, coreSpecKeys, candidateSpecKeys) && !allowMinimal) {
+  if (!hasCoreSpec(row, coreSpecKeys, candidateSpecKeys) && !(allowMinimal || allowForOrdering)) {
     return { ok: false, reason: 'missing_core_spec' };
   }
   return { ok: true };
 }
 
 async function getColumnTypes(targetTable) {
   const [schema, table] = targetTable.includes('.')
     ? targetTable.split('.', 2)
     : ['public', targetTable];
 
   const { rows } = await pool.query(
     `SELECT lower(column_name) AS column, data_type
        FROM information_schema.columns
       WHERE table_schema = $1
         AND table_name   = $2`,
     [schema, table],
   );
 
   const map = new Map();
   for (const row of rows) {
     map.set(row.column, String(row.data_type || '').toLowerCase());
   }
   return map;
 }