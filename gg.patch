diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index 65f8783b3236fdc938f68465773b1e9791e1d491..65340b265b6cbc670a628d241e3d2a1104b9a744 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -2403,58 +2403,57 @@ async function persistProcessedData(processed = {}, overrides = {}) {
           variantKeysSource = Array.isArray(blueprint?.ingestOptions?.variant_keys)
             ? blueprint.ingestOptions.variant_keys
             : null;
         }
       } catch (err) {
         console.warn('[persist] blueprint fetch failed for variant recovery:', err?.message || err);
       }
     }
 
     const variantKeys = USE_VARIANT_KEYS && Array.isArray(variantKeysSource)
       ? variantKeysSource.map((k) => String(k || '').trim()).filter(Boolean)
       : [];
 
     for (const r of records) {
       if (!r || typeof r !== 'object') continue;
       if (!Array.isArray(r.candidates) && Array.isArray(processed?.candidateCodes)) {
         r.candidates = processed.candidateCodes;
       }
       const fixed = recoverCode(r, { pnTemplate, variantKeys });
       if (fixed) {
         if (!r.code) r.code = fixed;
         if (!r.pn) r.pn = fixed;
       }
     }
 
-    // 저장 직전 PN 정합성 강화: 템플릿/가짜/링크 토큰 제거
+    // 저장 직전 PN 정합성 강화
     records = records.filter((r) => {
       const pn = String(r?.pn || r?.code || '').trim();
       if (!pn) return false;
-      if (pn.startsWith('pdf:')) return false; // PDF 앵커 토큰 제거
-      if (pn.includes('{') || pn.includes('}')) return false; // 템플릿 잔재 제거
-      if (!PN_STRICT.test(pn)) return false; // 기초 포맷 체크
-      return true;
+      if (pn.startsWith('pdf:')) return false; // PDF 앵커 토큰 컷
+      if (pn.includes('{') || pn.includes('}')) return false; // 템플릿 잔재 컷
+      return PN_STRICT.test(pn); // 기본 포맷 검증
     });
 
     records = records.filter((r) => isValidCode(r?.pn || r?.code));
     if (!records.length) {
       persistResult.skipped = [{ reason: 'missing_pn' }];
     }
 
     if (records.length) {
       if (colTypes instanceof Map && colTypes.size) {
         for (const rec of records) {
           if (!rec || typeof rec !== 'object') continue;
           for (const [k, v] of Object.entries(rec)) {
             const keyLower = String(k || '').toLowerCase();
             const t = colTypes.get(keyLower) || colTypes.get(k);
             if (!t) continue;
             if (t === 'numeric')      rec[k] = coerceNumeric(v);
             else if (t === 'int')     rec[k] = toInt(v);
             else if (t === 'bool')    rec[k] = toBool(v);
           }
         }
       }
       console.log(
         '[DIAG] persist start table=%s family=%s records=%d required=%d',
         table,
         family,
