diff --git a/src/pipeline/persist.js b/src/pipeline/persist.js
index 51d262972e58b1403a747951a04058d286e7c432..fd2903af7844f08d0f8335cdeb1def6d2c8f28dd 100644
--- a/src/pipeline/persist.js
+++ b/src/pipeline/persist.js
@@ -847,52 +847,66 @@ function buildPnIfMissing(record = {}, pnTemplate) {
   if (existing) return;
   const fromTemplate = renderPnTemplate(pnTemplate, record);
   // 본문 검증: 템플릿 결과가 실제 문서 텍스트에 존재할 때만 채택
   const ctxText = String(record._doc_text || record.doc_text || '');
   if (fromTemplate && ctxText && fuzzyContainsPn(ctxText, fromTemplate)) {
     record.pn = fromTemplate;
     if (!record.code) record.code = fromTemplate;
     return;
   }
   const code = String(record.code || '').trim();
   if (code) record.pn = code;
 }
 
 /**
  * @param {string} family
  * @param {import('../types/blueprint').Spec} spec
  * @param {import('../types/blueprint').Blueprint} [blueprint]
  */
 function buildBestIdentifiers(family, spec = {}, blueprint) {
   if (!spec || typeof spec !== 'object') return spec;
 
   let codeCandidate = null;
   const localTemplate = getBlueprintPnTemplate(blueprint || {}, spec);
   if (localTemplate) {
     try {
-      const oi = spec.ordering_info || spec.orderingInfo || spec._ordering_info || null;
-    } catch (_) {}
+      const orderingInfo = spec.ordering_info || spec.orderingInfo || spec._ordering_info || null;
+      const context = { ...spec };
+      if (orderingInfo && typeof orderingInfo === 'object') {
+        context.ordering_info = orderingInfo;
+        context.orderingInfo = orderingInfo;
+        if (context.codes == null && Array.isArray(orderingInfo.codes)) {
+          context.codes = orderingInfo.codes;
+        }
+      }
+      const rendered = renderPnTemplate(localTemplate, context);
+      if (rendered) {
+        codeCandidate = rendered;
+      }
+    } catch (_) {
+      // ignore template rendering errors for identifier derivation
+    }
   }
 
   const docText = String(spec._doc_text || spec.doc_text || '');
   if (!codeCandidate && family === 'relay_signal') {
     const fallback = codeForRelaySignal(spec);
     if (fallback && norm(docText).includes(norm(fallback))) {
       codeCandidate = fallback;
     }
   }
   if (codeCandidate && norm(docText).includes(norm(codeCandidate))) {
     spec.pn = codeCandidate;
     spec.code = codeCandidate;
     spec.verified_in_doc = true;
   } else {
     spec.code = spec.pn;
     if (!STRICT_CODE_RULES) spec._warn_invalid_code = true;
   }
   if (!spec.verified_in_doc) {
     const oi = spec.ordering_info || spec.orderingInfo || null;
     const codes = Array.isArray(oi?.codes) ? oi.codes : null;
     if (codes && codes.length) {
       const me = String(spec.pn || spec.code || '').trim().toUpperCase();
       if (me && codes.some((c) => String(c || '').trim().toUpperCase() === me)) {
         spec.verified_in_doc = true;
       }
