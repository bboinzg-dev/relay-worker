diff --git a/server.retail.import.js b/server.retail.import.js
index 82561041914d81915d7d0cefd78619d910149993..62e01fdd63d9c644b64999e0813b048084516f38 100644
--- a/server.retail.import.js
+++ b/server.retail.import.js
@@ -21,71 +21,83 @@ const BRANCH = process.env.RETAIL_BRANCH ||
 const TEMP_BUCKET = process.env.GCS_TEMP_BUCKET || '';
 
 function createObjectPath() {
   const now = new Date();
   const pad = (n, l = 2) => String(n).padStart(l, '0');
   const timestamp = `${now.getUTCFullYear()}${pad(now.getUTCMonth() + 1)}${pad(now.getUTCDate())}` +
     `${pad(now.getUTCHours())}${pad(now.getUTCMinutes())}${pad(now.getUTCSeconds())}`;
   return `retail/import/products_${timestamp}_${Date.now()}.ndjson`;
 }
 
 router.post('/api/retail/import', async (req, res, next) => {
   if (!BRANCH) {
     res.status(500).json({ done: false, error: 'RETAIL_BRANCH or GCP_PROJECT_NUMBER not configured' });
     return;
   }
   if (!TEMP_BUCKET) {
     res.status(500).json({ done: false, error: 'GCS_TEMP_BUCKET not configured' });
     return;
   }
 
   const dbClient = await pool.connect();
   const objectPath = createObjectPath();
   const bucket = storage.bucket(TEMP_BUCKET);
   const gcsFile = bucket.file(objectPath);
   const gcsUri = `gs://${TEMP_BUCKET}/${objectPath}`;
+  const since = (req.query.since || '').toString().trim();
+  const usePartial = since.length > 0;
 
   try {
-    const query = new QueryStream('SELECT line FROM retail.export_products_ndjson()');
+    const sql = usePartial
+      ? 'SELECT line FROM retail.export_products_ndjson_since($1)'
+      : 'SELECT line FROM retail.export_products_ndjson()';
+    const query = new QueryStream(sql, usePartial ? [since] : []);
     const pgStream = dbClient.query(query);
 
     let count = 0;
     const toNdjson = new Transform({
       objectMode: true,
       transform(row, _enc, callback) {
         count += 1;
         callback(null, `${row.line}\n`);
       },
     });
 
     await new Promise((resolve, reject) => {
       pgStream
         .pipe(toNdjson)
         .pipe(gcsFile.createWriteStream({
           resumable: false,
           contentType: 'application/x-ndjson',
         }))
         .on('finish', resolve)
         .on('error', reject);
     });
 
     const errorsPrefix = process.env.RETAIL_ERRORS_PREFIX || 'retail/errors';
     const [op] = await retail.importProducts({
       parent: BRANCH,
       inputConfig: { gcsSource: { inputUris: [gcsUri] } },
       reconciliationMode: 'INCREMENTAL',
       // ★ 필수: 에러 로그 저장 경로 (gs://버킷/디렉토리)
       errorsConfig: { gcsPrefix: `gs://${TEMP_BUCKET}/${errorsPrefix}` },
     });
     const [resp] = await op.promise();
 
-    res.json({ done: true, result: resp, gcsUri, branch: BRANCH, count });
+    res.json({
+      done: true,
+      result: resp,
+      gcsUri,
+      branch: BRANCH,
+      count,
+      since: usePartial ? since : null,
+    });
   } catch (err) {
     console.error('[retail/import]', err?.message || err);
     // 서버 크래시 방지: 500 JSON으로 돌려보냄
     return res.status(500).json({ done: false, error: String(err?.message || err), gcsUri });
   } finally {
     dbClient.release();
   }
 });
 
 module.exports = router;
\ No newline at end of file
