diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index 8d6a6e42ac6967eca888e68b6af26bdea1ac71a7..28066c641c48f817b4ec653e86304c260c202abd 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -1,42 +1,43 @@
 'use strict';
 
 const path = require('node:path');
 const fs = require('node:fs/promises');
 const os = require('node:os');
 const { execFile } = require('node:child_process');
 const { promisify } = require('node:util');
 const execFileP = promisify(execFile);
 
 const db = require('../../db');
 const { storage, parseGcsUri, readText, canonicalCoverPath } = require('../utils/gcs');
 const { extractText } = require('../utils/extract');
 const { getBlueprint } = require('../utils/blueprint');
 const { resolveBrand } = require('../utils/brand');
 const { detectVariantKeys } = require('../utils/ordering');
 const { extractPartsAndSpecsFromPdf } = require('../ai/datasheetExtract');
 const { extractFields } = require('./extractByBlueprint');
+const { aiCanonicalizeKeys } = require('./ai/canonKeys');
 const { canonicalize } = require('./specKeyMap');
 const { saveExtractedSpecs } = require('./persist');
 const { explodeToRows } = require('../ingest/mpn-exploder');
 const { splitAndCarryPrefix } = require('../utils/mpn-exploder');
 const { ensureSpecColumnsForBlueprint } = require('./ensure-spec-columns');
 const { inferVariantKeys, normalizeSlug } = require('./variant-keys');
 const { classifyByGcs, extractValuesByGcs } = require('../services/vertex');
 const { processDocument: processDocAi } = require('../services/docai');
 
 const HARD_CAP_MS = Number(process.env.EXTRACT_HARD_CAP_MS || 120000);
 
 function withDeadline(promise, ms = HARD_CAP_MS, label = 'op') {
   const timeout = Number.isFinite(ms) && ms > 0 ? ms : HARD_CAP_MS;
   return new Promise((resolve, reject) => {
     const timer = setTimeout(() => {
       clearTimeout(timer);
       reject(new Error(`${label}_TIMEOUT`));
     }, timeout);
     Promise.resolve(promise)
       .then((value) => {
         clearTimeout(timer);
         resolve(value);
       })
       .catch((err) => {
         clearTimeout(timer);
diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index 8d6a6e42ac6967eca888e68b6af26bdea1ac71a7..28066c641c48f817b4ec653e86304c260c202abd 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -51,50 +52,79 @@ const FAST_PAGES = [0, 1, -1]; // 첫 페이지, 2페이지, 마지막 페이지
 const META_KEYS = new Set(['variant_keys','pn_template','ingest_options']);
 const BASE_KEYS = new Set([
   'family_slug','brand','code','pn','brand_norm','code_norm','pn_norm','series_code',
   'datasheet_uri','image_uri','datasheet_url','display_name','displayname',
   'cover','verified_in_doc','updated_at'
 ]);
 const SKIP_SPEC_KEYS = new Set([
   'raw_json',
   'text',
   'tables',
   'mpn_list',
   'mpn',
   'codes',
   'series',
   'series_code',
   'raw_text',
   'raw_specs',
   'rawspecs',
   'raw_table',
   'raw_tables',
 ]);
 
 const PN_CANDIDATE_RE = /[0-9A-Z][0-9A-Z\-_/().]{3,63}[0-9A-Z)]/gi;
 const PN_BLACKLIST_RE = /(pdf|font|xref|object|type0|ffff)/i;
 
+const RESERVED_SPEC_KEYS = new Set([
+  'id',
+  'created_at',
+  'updated_at',
+  'brand',
+  'brand_norm',
+  'pn',
+  'pn_norm',
+  'code',
+  'series',
+  'image_uri',
+  'datasheet_uri',
+]);
+
+function normalizeSpecKeyName(value) {
+  if (value == null) return null;
+  let s = String(value).trim().toLowerCase();
+  if (!s) return null;
+  s = s.replace(/[–—―]/g, '-');
+  s = s.replace(/\s+/g, '_');
+  s = s.replace(/[^0-9a-z_]+/g, '_');
+  s = s.replace(/_+/g, '_');
+  s = s.replace(/^_|_$/g, '');
+  if (!s) return null;
+  if (s.length > 63) s = s.slice(0, 63);
+  if (RESERVED_SPEC_KEYS.has(s)) return null;
+  return s;
+}
+
 function escapeRegex(str) {
   return String(str || '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
 }
 
 function textContainsExact(text, pn) {
   if (!text || !pn) return false;
   const pattern = escapeRegex(String(pn).trim());
   if (!pattern) return false;
   const re = new RegExp(`(^|[^A-Za-z0-9])${pattern}(?=$|[^A-Za-z0-9])`, 'i');
   return re.test(String(text));
 }
 
 function normLower(s){ return String(s||'').trim().toLowerCase(); }
 
 function pickBrandHint(...values) {
   for (const value of values) {
     if (value == null) continue;
     const trimmed = String(value).trim();
     if (!trimmed) continue;
     if (trimmed.toLowerCase() === 'unknown') continue;
     return trimmed;
   }
   return null;
 }
 
diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index 8d6a6e42ac6967eca888e68b6af26bdea1ac71a7..28066c641c48f817b4ec653e86304c260c202abd 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -1130,68 +1160,185 @@ async function runAutoIngest(input = {}) {
       }
     }
 
     if (Array.isArray(freshKeys) && freshKeys.length) {
       console.log('[variant] detected new keys', { family, brand: brandName, series: baseSeries, keys: freshKeys });
     }
   } catch (err) {
     console.warn('[variant] inferVariantKeys failed:', err?.message || err);
   }
 
   if (!disableEnsure) {
     await ensureSpecsTableByFamily(family);
     if (!variantColumnsEnsured) {
       try {
         await ensureBlueprintVariantColumns(family);
         variantColumnsEnsured = true;
       } catch (err) {
         console.warn('[variant] ensure_blueprint_variant_columns fallback failed:', err?.message || err);
       }
     }
   }
 
   await ensureSpecColumnsForBlueprint(qualified, blueprint);
   colTypes = await getColumnTypes(qualified);
 
+  const rawRows = Array.isArray(extracted.rows) && extracted.rows.length ? extracted.rows : [];
+  const runtimeSpecKeys = new Set();
+  for (const row of rawRows) {
+    if (!row || typeof row !== 'object') continue;
+    for (const rawKey of Object.keys(row)) {
+      const trimmed = String(rawKey || '').trim();
+      if (!trimmed) continue;
+      const lower = trimmed.toLowerCase();
+      if (META_KEYS.has(lower) || BASE_KEYS.has(lower)) continue;
+      runtimeSpecKeys.add(trimmed);
+    }
+  }
+
+  const aiCanonicalMap = new Map();
+  const aiCanonicalMapLower = new Map();
+  if (process.env.AUTO_CANON_KEYS === '1' && runtimeSpecKeys.size) {
+    const specCols = colTypes ? Array.from(colTypes.keys()) : [];
+    const blueprintFieldKeys = blueprint?.fields && typeof blueprint.fields === 'object'
+      ? Object.keys(blueprint.fields).map((k) => String(k || '').trim().toLowerCase()).filter(Boolean)
+      : [];
+    const knownKeys = Array.from(new Set([
+      ...specCols,
+      ...blueprintFieldKeys,
+      ...(Array.isArray(variantKeys) ? variantKeys : []),
+    ]));
+
+    try {
+      const { map, newKeys } = await aiCanonicalizeKeys(
+        family,
+        Array.from(runtimeSpecKeys),
+        knownKeys
+      );
+
+      const knownLower = new Set(knownKeys.map((k) => String(k || '').trim().toLowerCase()).filter(Boolean));
+      const newKeySet = new Set((Array.isArray(newKeys) ? newKeys : []).map((k) => String(k || '').trim()).filter(Boolean));
+      const newCanonKeys = [];
+      for (const [orig, info] of Object.entries(map || {})) {
+        const trimmedOrig = String(orig || '').trim();
+        if (!trimmedOrig) continue;
+        const baseLower = trimmedOrig.toLowerCase();
+        let canonical = String(info?.canonical || '').trim();
+        let action = info?.action === 'map' ? 'map' : 'new';
+        let conf = Number(info?.conf || 0);
+        if (!Number.isFinite(conf)) conf = 0;
+
+        let finalKey = null;
+        if (action === 'map' && canonical) {
+          const lowerCanon = canonical.toLowerCase();
+          if (knownLower.has(lowerCanon)) {
+            finalKey = lowerCanon;
+          } else {
+            finalKey = normalizeSpecKeyName(canonical) || lowerCanon || null;
+          }
+          if (!finalKey) {
+            finalKey = baseLower;
+            action = 'new';
+          }
+        } else {
+          const normalized = normalizeSpecKeyName(canonical || trimmedOrig);
+          finalKey = normalized || baseLower;
+          action = 'new';
+        }
+
+        if (!finalKey || META_KEYS.has(finalKey) || BASE_KEYS.has(finalKey)) continue;
+        const payload = { canonical: finalKey, action, conf };
+        aiCanonicalMap.set(trimmedOrig, payload);
+        aiCanonicalMapLower.set(baseLower, payload);
+        if (action === 'new' || newKeySet.has(trimmedOrig)) newCanonKeys.push(finalKey);
+      }
+
+      if (process.env.AUTO_ADD_FIELDS === '1' && newCanonKeys.length) {
+        const uniqueNew = Array.from(new Set(newCanonKeys.filter(Boolean)));
+        const limitRaw = Number(process.env.AUTO_ADD_FIELDS_LIMIT || '20');
+        const limit = Number.isFinite(limitRaw) && limitRaw > 0 ? limitRaw : uniqueNew.length;
+        const target = uniqueNew.slice(0, limit);
+        if (target.length) {
+          try {
+            const { rows } = await db.query(
+              'SELECT public.ensure_dynamic_spec_columns($1,$2::jsonb) AS created',
+              [family, JSON.stringify(target)]
+            );
+            console.log('[schema] added columns', rows?.[0]?.created);
+          } catch (err) {
+            console.warn('[schema] ensure_dynamic_spec_columns failed:', err?.message || err);
+          }
+
+          for (const key of target) {
+            if (!key) continue;
+            if (colTypes && !colTypes.has(key)) colTypes.set(key, 'text');
+            if (!allowedKeys.includes(key)) allowedKeys.push(key);
+          }
+
+          allowedKeys = Array.from(new Set(allowedKeys));
+
+          if (Array.isArray(blueprint?.allowedKeys)) {
+            blueprint.allowedKeys = Array.from(new Set([...blueprint.allowedKeys, ...target]));
+          } else {
+            blueprint.allowedKeys = [...target];
+          }
+        }
+      }
+
+      const minCanonConf = Number(process.env.AUTO_CANON_MIN_CONF || '0.66');
+      for (const [orig, info] of aiCanonicalMap.entries()) {
+        if (info.action !== 'map' || !info.canonical || info.conf < minCanonConf) continue;
+        try {
+          await db.query('SELECT public.upsert_spec_alias($1,$2,$3)', [family, orig, info.canonical]);
+        } catch (_) {
+          /* ignore alias cache errors */
+        }
+      }
+    } catch (err) {
+      console.warn('[canon] aiCanonicalizeKeys failed:', err?.message || err);
+      aiCanonicalMap.clear();
+      aiCanonicalMapLower.clear();
+    }
+  }
+
   const mpnsFromDoc = harvestMpnCandidates(
     extracted?.text ?? '',
     (baseSeries || series || code || '')
   );
   const mpnNormFromDoc = new Set(mpnsFromDoc.map((m) => normalizeCode(m)).filter(Boolean));
 
   const candidateMap = [];
   const candidateNormSet = new Set();
   for (const cand of candidates) {
     const trimmed = typeof cand === 'string' ? cand.trim() : String(cand || '');
     if (!trimmed) continue;
     const norm = normalizeCode(trimmed);
     if (!norm || candidateNormSet.has(norm)) continue;
     candidateNormSet.add(norm);
     candidateMap.push({ raw: trimmed, norm });
   }
 
-  const rawRows = Array.isArray(extracted.rows) && extracted.rows.length ? extracted.rows : [];
   const baseRows = (rawRows.length ? rawRows : [{}]).map((row) => {
     const obj = row && typeof row === 'object' ? { ...row } : {};
     if (obj.brand == null) obj.brand = brandName;
     const fallbackSeries = obj.series_code || obj.series || baseSeries || null;
     if (fallbackSeries != null) {
       if (obj.series == null) obj.series = fallbackSeries;
       if (obj.series_code == null) obj.series_code = fallbackSeries;
     }
     if (obj.datasheet_uri == null) obj.datasheet_uri = gcsUri;
     if (coverUri && obj.cover == null) obj.cover = coverUri;
     return obj;
   });
 
   const explodedRows = explodeToRows(blueprint, baseRows);
   const physicalCols = new Set(colTypes ? [...colTypes.keys()] : []);
   const allowedSet = new Set((allowedKeys || []).map((k) => String(k || '').trim().toLowerCase()).filter(Boolean));
   const variantSet = new Set(variantKeys);
 
   const seenCodes = new Set();
   for (const row of explodedRows) {
     const seeds = [];
     const seenSeed = new Set();
     const pushSeed = (val) => {
       if (val == null) return;
       if (Array.isArray(val)) { val.forEach(pushSeed); return; }
diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index 8d6a6e42ac6967eca888e68b6af26bdea1ac71a7..28066c641c48f817b4ec653e86304c260c202abd 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -1239,52 +1386,55 @@ async function runAutoIngest(input = {}) {
         verified = Boolean(row.verified_in_doc);
       }
     } else {
       verified = candidateNormSet.has(mpnNorm) || mpnNormFromDoc.has(mpnNorm);
     }
     rec.verified_in_doc = Boolean(verified);
     rec.image_uri = row.image_uri || coverUri || null;
     if (coverUri && rec.cover == null) rec.cover = coverUri;
     const displayName = row.display_name || row.displayname || `${rec.brand} ${mpn}`;
     rec.display_name = displayName;
     if (rec.displayname == null && displayName != null) rec.displayname = displayName;
     rec.updated_at = now;
     // persist에서 브랜드 정규화할 때 쓰도록 원문 텍스트 전달
     rec._doc_text = extractedText;
     if (hasRuntimeMeta) {
       rec.raw_json = mergeRuntimeMetadata(row.raw_json, runtimeMeta);
     } else if (row.raw_json != null) {
       rec.raw_json = row.raw_json;
     }
 
     for (const [rawKey, rawValue] of Object.entries(row)) {
       const key = String(rawKey || '').trim();
       if (!key) continue;
       const lower = key.toLowerCase();
       if (META_KEYS.has(lower) || BASE_KEYS.has(lower)) continue;
-      if (physicalCols.has(lower) || allowedSet.has(lower) || variantSet.has(lower)) {
-        rec[lower] = rawValue;
+      const mapped = aiCanonicalMap.get(key) || aiCanonicalMapLower.get(lower);
+      const target = mapped?.canonical || lower;
+      if (!target || META_KEYS.has(target) || BASE_KEYS.has(target)) continue;
+      if (physicalCols.has(target) || allowedSet.has(target) || variantSet.has(target)) {
+        rec[target] = rawValue;
       }
     }
 
     if (blueprint?.code_rules) applyCodeRules(rec.code, rec, blueprint.code_rules, colTypes);
     records.push(rec);
   }
 
   if (candidateMap.length) {
     const fallbackSeries = baseSeries || null;
     for (const cand of candidateMap) {
       const norm = cand.norm;
       const naturalKey = `${normLower(brandName)}::${norm}`;
       if (seenCodes.has(naturalKey)) continue;
       seenCodes.add(naturalKey);
       const verified = mpnNormFromDoc.has(norm);
       const rec = {
         family_slug: family,
         brand: brandName,
         pn: cand.raw,
         code: cand.raw,
         series_code: fallbackSeries,
         datasheet_uri: gcsUri,
         image_uri: coverUri || null,
         display_name: `${brandName} ${cand.raw}`,
         verified_in_doc: verified,
