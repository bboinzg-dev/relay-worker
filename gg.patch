diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index de17c452f73b39c5e04611ffadd5f6a57af05b94..45728cb26a7b9990882ebb47e0c834ede517b076 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -155,79 +155,97 @@ const MERGE_SKIP_KEYS = new Set([
   'mpn',
   'mpn_list',
   'codes',
   'candidates',
   '_doc_text',
   'last_error',
   'run_id',
   'job_id',
   'runid',
   'jobid',
 ]);
 
 const SPEC_MERGE_OVERRIDES = new Set(['code', 'code_norm', 'pn', 'pn_norm', 'series', 'series_code']);
 
 const DOC_AI_CODE_HEADER_RE =
   /(part\s*(?:no\.?|number|name)|type\s*(?:no\.?|number)?|model|品番|型式|型番|品號|部品番号|품번|형명|주문\s*번호|order(?:ing)?\s*code)/i;
 const DOC_TABLE_ORDERING_HINT_RE =
   /(ordering|order\s*info|order\s*code|types?\b|type\s*(?:no\.?|number)|selection|品番|型式|型番|형명)/i;
 const DOC_TABLE_HEADER_FOOTER_RE = /(header|footer|page\s*\d+)/i;
 const PN_CANON_KEY_RE = /(^|_)(part|pn|code|model|type)(_|$)/;
 const PN_HEADER_LABEL_RE = /(part\s*(?:no\.?|number)|type\s*(?:no\.?|number)?|catalog\s*(?:no\.?|number)|model|品番|型式|형名|型番)/i;
 const PN_CANDIDATE_RE = /[0-9A-Z][0-9A-Z\-_/().#]{3,63}[0-9A-Z)#]/gi;
 const PN_BLACKLIST_RE = /(pdf|font|xref|object|type0|ffff)/i;
 const PN_STRICT = /^[A-Z0-9][A-Z0-9\-_.()/#]{1,62}[A-Z0-9)#]$/i;
 
+function getBlueprintAllowedKeys(blueprint) {
+  const direct = Array.isArray(blueprint?.allowedKeys) ? blueprint.allowedKeys : [];
+  if (direct.length) {
+    return Array.from(
+      new Set(
+        direct
+          .map((k) => String(k || '').trim())
+          .filter(Boolean)
+      )
+    );
+  }
+  if (blueprint?.fields && typeof blueprint.fields === 'object') {
+    return Object.keys(blueprint.fields);
+  }
+  return [];
+}
+
   function gatherRuntimeSpecKeys(rows) {
   const set = new Set();
   const list = Array.isArray(rows) ? rows : [];
   for (const row of list) {
     if (!row || typeof row !== 'object') continue;
     for (const rawKey of Object.keys(row)) {
       const trimmed = String(rawKey || '').trim();
       if (!trimmed) continue;
       const lower = trimmed.toLowerCase();
       if (META_KEYS.has(lower) || BASE_KEYS.has(lower)) continue;
       set.add(trimmed);
     }
   }
   return set;
 }
 
 async function ensureDynamicColumnsForRows(qualifiedTable, rows, allowedKeys = []) {
   if (!AUTO_ADD_FIELDS || !AUTO_ADD_FIELDS_LIMIT) return;
-  let keys = Array.from(gatherRuntimeSpecKeys(rows)).slice(0, AUTO_ADD_FIELDS_LIMIT);
+  let keys = Array.from(gatherRuntimeSpecKeys(rows));
   if (Array.isArray(allowedKeys) && allowedKeys.length) {
     const allow = new Set(
       allowedKeys
         .map((s) => String(s || '').trim().toLowerCase())
         .filter(Boolean),
     );
     if (allow.size) {
       keys = keys.filter((k) => allow.has(String(k || '').trim().toLowerCase()));
     }
   }
+  keys = keys.slice(0, AUTO_ADD_FIELDS_LIMIT);
   if (!keys.length) return;
   const sample = {};
   if (Array.isArray(rows)) {
     const remaining = new Set(keys);
     for (const row of rows) {
       if (!row || typeof row !== 'object') continue;
       for (const key of keys) {
         if (!remaining.has(key)) continue;
         if (Object.prototype.hasOwnProperty.call(row, key)) {
           sample[key] = row[key];
           remaining.delete(key);
         }
       }
       if (!remaining.size) break;
     }
   }
   try {
     await ensureSpecColumnsForKeys(qualifiedTable, keys, sample);
   } catch (err) {
     console.warn('[schema] ensureDynamicColumnsForRows failed:', err?.message || err);
   }
 }
 
 function quoteIdentifier(name) {
   const trimmed = String(name || '').trim();
@@ -2970,73 +2988,60 @@ async function doIngestPipeline(input = {}, runIdParam = null) {
 
   if (!explicitFamily) {
     if (previewGuess && (!family || family === 'relay_power' || family === vertexFamily)) {
       family = previewGuess;
     }
     if ((!family || family === 'relay_power') && /subminiature\s+signal\s+relay|signal\s+relay/i.test(previewText)) {
       family = 'relay_signal';
     }
   }
 
   if (!family) family = 'relay_power';
 
   const overrideBrandLog = overridesBrand ?? brand ?? '';
   console.log(`[PATH] overrides.brand=${overrideBrandLog || ''} family=${family} runId=${runId || ''}`);
 
 // 목적 테이블
   const reg = await db.query(
     `SELECT specs_table FROM public.component_registry WHERE family_slug=$1 LIMIT 1`,
     [family]
   );
   const table = reg.rows[0]?.specs_table || 'relay_power_specs';
   const qualified = table.startsWith('public.')? table : `public.${table}`;
 
   let blueprint = await getBlueprint(family);
 
-    const getBlueprintAllowedKeys = () =>
-    (Array.isArray(blueprint?.allowedKeys) ? blueprint.allowedKeys : []);
-
   if (!vertexExtractValues && family) {
     try {
       vertexExtractValues = await extractValuesByGcs(gcsUri, family);
     } catch (err) {
       console.warn('[vertex] extract failed:', err?.message || err);
     }
   }
 
   // 블루프린트 허용 키
-  let allowedKeys = getBlueprintAllowedKeys().slice();
-  if ((!allowedKeys || !allowedKeys.length) && blueprint?.fields && typeof blueprint.fields === 'object') {
-    allowedKeys = Object.keys(blueprint.fields);
-  }
-  allowedKeys = Array.from(
-    new Set(
-      (allowedKeys || [])
-        .map((k) => String(k || '').trim())
-        .filter(Boolean)
-    )
-  );
+  let allowedKeys = getBlueprintAllowedKeys(blueprint).slice();
 
   let variantKeys = [];
   if (USE_VARIANT_KEYS) {
     variantKeys = Array.isArray(blueprint?.ingestOptions?.variant_keys)
       ? blueprint.ingestOptions.variant_keys
       : (Array.isArray(blueprint?.variant_keys) ? blueprint.variant_keys : []);
     variantKeys = Array.from(
       new Set(
         variantKeys
           .map((k) => String(k || '').trim().toLowerCase())
           .filter(Boolean),
       ),
     );
   }
 
   let pnTemplate = USE_PN_TEMPLATE
     ? (blueprint?.ingestOptions?.pn_template || blueprint?.ingestOptions?.pnTemplate || null)
     : null;
   const requiredFields = [];
   if (blueprint?.fields && typeof blueprint.fields === 'object') {
     for (const [fieldKey, meta] of Object.entries(blueprint.fields)) {
       const isRequired = meta && typeof meta === 'object' && Boolean(meta.required);
       if (!isRequired) continue;
       const normalized = String(fieldKey || '')
         .trim()
@@ -3753,77 +3758,77 @@ async function doIngestPipeline(input = {}, runIdParam = null) {
     if (!orderingDomains) {
       orderingOverride = buildTyOrderingFallback({
         baseSeries,
         orderingInfo: extracted?.ordering_info,
         previewText,
         docAiText,
       });
       if (orderingOverride) orderingDomains = orderingOverride.domains;
     }
     if (!orderingDomains) {
       const orderingWindowText = typeof extracted?.ordering_info?.text === 'string'
         ? extracted.ordering_info.text
         : '';
       const orderingHaystack = [orderingWindowText, previewText, docAiText]
         .filter((chunk) => typeof chunk === 'string' && chunk.trim())
         .join('\n');
       if (orderingWindowText.trim() || (orderingHaystack && ORDERING_SECTION_RE.test(orderingHaystack))) {
         try {
           const recipeInput = orderingWindowText.trim().length >= 40
             ? orderingWindowText
             : (gcsUri || orderingWindowText);
           const recipe = await extractOrderingRecipe(recipeInput);
           orderingLegendRecipe = recipe || orderingLegendRecipe;
           const variantDomains = normalizeVariantDomains(
             recipe?.variant_domains,
-            getBlueprintAllowedKeys(),
+            getBlueprintAllowedKeys(blueprint),
           );
           if (Object.keys(variantDomains).length) {
             orderingDomains = variantDomains;
             if (!pnTemplate && typeof recipe?.pn_template === 'string' && recipe.pn_template.trim()) {
               pnTemplate = recipe.pn_template.trim();
             }
           }
         } catch (err) {
           console.warn('[ordering] recipe extract failed:', err?.message || err);
         }
       }
     }
   }
 
   const orderingDomainKeys = Object.keys(orderingDomains || {});
   if (USE_VARIANT_KEYS) {
     let aiVariantKeys = [];
     const rawOrderingText = orderingTextSources.length ? orderingTextSources.join('\n') : '';
     const detectionInput = rawOrderingText || extractedText || '';
     if (detectionInput.trim()) {
       try {
         aiVariantKeys = await detectVariantKeys({
           rawText: detectionInput,
           family,
           blueprintVariantKeys: blueprint?.variant_keys,
-          allowedKeys: getBlueprintAllowedKeys(),
+          allowedKeys: getBlueprintAllowedKeys(blueprint),
         });
       } catch (err) {
         console.warn('[variant] runtime detect failed:', err?.message || err);
       }
     }
     runtimeVariantKeys = mergeVariantKeyLists(
       VARIANT_MAX_CARDINALITY,
       Array.isArray(aiVariantKeys) ? aiVariantKeys : [],
       orderingDomainKeys,
       blueprintVariantKeys,
     );
   } else {
     runtimeVariantKeys = [];
   }
 
   console.log('[PATH] brand resolved', {
     runId,
     family,
     hint: brandHintSeed || null,
     effective: brandEffectiveResolved,
     source: brandSource,
     vkeys_runtime: runtimeVariantKeys,
   });
 
   if (orderingDomains) {
@@ -3973,51 +3978,51 @@ async function doIngestPipeline(input = {}, runIdParam = null) {
         if (appendedRows.length) {
           if (!Array.isArray(extracted.rows) || !extracted.rows.length) {
             extracted.rows = rawRows;
           }
           const lowerOrderingKeys = orderingKeys
             .map((k) => String(k).trim().toLowerCase())
             .filter(Boolean);
           const allowedLower = new Set(
             (allowedKeys || []).map((k) => String(k || '').trim().toLowerCase()).filter(Boolean)
           );
           for (const key of lowerOrderingKeys) {
             if (!variantKeys.includes(key)) variantKeys.push(key);
             if (!allowedLower.has(key)) {
               allowedKeys.push(key);
               allowedLower.add(key);
             }
             if (Array.isArray(runtimeVariantKeys) && !runtimeVariantKeys.includes(key)) {
               runtimeVariantKeys.push(key);
             }
           }
         }
       }
     }
   }
 
-  const allowedForDomains = getBlueprintAllowedKeys();
+  const allowedForDomains = getBlueprintAllowedKeys(blueprint);
   let legendVariantDomains = normalizeVariantDomains(orderingDomains, allowedForDomains);
   const orderingTextForRecipe = Array.isArray(orderingTextSources)
     ? orderingTextSources
         .map((txt) => (typeof txt === 'string' ? txt : String(txt ?? '')))
         .map((txt) => txt.trim())
         .filter(Boolean)
         .join('\n')
     : '';
   if (orderingTextForRecipe) {
     try {
       const recipe = await extractOrderingRecipe(orderingTextForRecipe);
       if (recipe) orderingLegendRecipe = recipe;
     } catch (err) {
       console.warn('[ordering] legend recipe extract failed:', err?.message || err);
     }
   }
   if (orderingLegendRecipe && orderingLegendRecipe.variant_domains) {
     const recipeDomains = normalizeVariantDomains(
       orderingLegendRecipe.variant_domains,
       allowedForDomains,
     );
     if (Object.keys(recipeDomains).length) {
       if (!legendVariantDomains || !Object.keys(legendVariantDomains).length) {
         legendVariantDomains = { ...recipeDomains };
       } else {
@@ -4365,91 +4370,91 @@ async function doIngestPipeline(input = {}, runIdParam = null) {
       const usedRecords = new Set();
       const canonicalRefs = new Set(canonRecs);
       for (const row of explodedRows) {
         if (!row || typeof row !== 'object') continue;
         let match = null;
         if (canonRecs.length) {
           match =
             bestRowMatchToSpec(row, canonRecs, usedRecords, { tokenStats: docAiTokenStats }) ||
             bestAttributeMatchToSpec(row, canonRecs, variantKeys);
         }
         if (!match && String(family || '').toLowerCase() === 'relay_signal') {
           match = findCoilRowMatchForRelaySignal(row, flatRecs);
         }
         if (match && match.values) {
           Object.assign(row, safeMergeSpec(row, match.values));
           if (canonicalRefs.has(match)) {
             usedRecords.add(match);
           }
         }
       }
     }
     try {
       await ensureDynamicColumnsForRows(
         qualified,
         explodedRows,
-        getBlueprintAllowedKeys(),
+        getBlueprintAllowedKeys(blueprint),
       );
     } catch (err) {
       console.warn('[schema] ensureDynamicColumnsForRows explodedRows failed:', err?.message || err);
     }
   }
   if (
     Array.isArray(explodedRows) &&
     explodedRows.length &&
     blueprint?.fields &&
     Object.keys(blueprint.fields).length
   ) {
     const docTextForLlm = String(docAiText || previewText || '').slice(0, 60000);
     if (docTextForLlm) {
       const llmTargets = explodedRows
         .map((row, index) => ({ row, index }))
         .filter(({ row }) => !hasCoreSpec(row))
         .slice(0, 3);
       for (const target of llmTargets) {
         try {
           const llmValues = await extractFields(
             docTextForLlm,
             target.row?.pn || target.row?.code || '',
             blueprint.fields,
           );
           if (llmValues && typeof llmValues === 'object') {
             const patch = safeMergeSpec(target.row, llmValues);
             if (patch && Object.keys(patch).length) {
               Object.assign(target.row, patch);
             }
           }
         } catch (err) {
           console.warn('[llm] extractFields backfill failed:', err?.message || err);
         }
       }
       if (llmTargets.length) {
         try {
           await ensureDynamicColumnsForRows(
             qualified,
             explodedRows,
-            getBlueprintAllowedKeys(),
+            getBlueprintAllowedKeys(blueprint),
           );
         } catch (err) {
           console.warn('[schema] ensureDynamicColumnsForRows llm failed:', err?.message || err);
         }
       }
     }
   }
   if (docPnCandidatesInfo?.map instanceof Map && docPnCandidatesInfo.map.size && explodedRows.length) {
     const variantKeyUnion = Array.from(
       new Set([
         ...(Array.isArray(variantKeys) ? variantKeys : []),
         ...(Array.isArray(runtimeVariantKeys) ? runtimeVariantKeys : []),
       ])
     );
     for (const row of explodedRows) {
       if (!row || typeof row !== 'object') continue;
       const hints = [row.pn, row.code, row.part_number, row.part_no, row.code_norm, code]
         .map((value) => (value == null ? null : String(value)))
         .filter((value) => value && value.trim());
       const bestPn = pickOrderingPreferredPn(row, {
         candidateInfo: docPnCandidatesInfo,
         hints,
         variantKeys: variantKeyUnion,
         seriesHints: [baseSeries, series, row.series, row.series_code],
         brand: row.brand || brandName,
@@ -5217,64 +5222,64 @@ async function persistProcessedData(processed = {}, overrides = {}) {
           try {
             const { map } = await aiCanonicalizeKeys(family, unknownKeys, knownList);
             const widened = new Set(knownList);
             for (const key of unknownKeys) {
               const rec = map?.[key] || {};
               let target = String(rec.canonical || '').trim();
               if (!target || rec.action !== 'map') target = key;
               const lower = target.toLowerCase();
               if (!lower || knownLower.has(lower)) continue;
               knownLower.add(lower);
               widened.add(target);
             }
             blueprint = blueprint && typeof blueprint === 'object' ? blueprint : {};
             blueprint.allowedKeys = Array.from(widened);
             allowedKeys = Array.from(blueprint.allowedKeys);
           } catch (err) {
             console.warn('[persist] aiCanonicalizeKeys failed:', err?.message || err);
           }
         }
       }
 
       if (Array.isArray(processedRowsInput) && processedRowsInput.length) {
         await ensureDynamicColumnsForRows(
           qualified,
           processedRowsInput,
-          getBlueprintAllowedKeys(),
+          getBlueprintAllowedKeys(blueprint),
         );
       }
       await ensureDynamicColumnsForRows(
         qualified,
         schemaEnsureRows,
-        getBlueprintAllowedKeys(),
+        getBlueprintAllowedKeys(blueprint),
       );
       // 폭발/병합이 끝났다면 이걸 저장 대상으로 사용
       records = Array.isArray(explodedRows) && explodedRows.length ? explodedRows : records;
       await ensureDynamicColumnsForRows(
         qualified,
         records,
-        getBlueprintAllowedKeys(),
+        getBlueprintAllowedKeys(blueprint),
       );
       try {
         persistResult = await saveExtractedSpecs({
           qualifiedTable: qualified,
           family,
           brand: brandOverride,
           records,
           pnTemplate,
           requiredKeys: effectiveRequired,
           coreSpecKeys: effectiveRequired,
           blueprint,
           mpnList,
           runId,
           run_id: runId,
           jobId,
           job_id: jobId,
           gcsUri,
           orderingInfo: processed?.ordering_info,
           docType: processed?.doc_type,
         }) || persistResult;
       } catch (e) {
         console.warn('[persist] saveExtractedSpecs failed:', e?.message || e);
         if (!persistResult || typeof persistResult !== 'object') {
           persistResult = { upserts: 0, written: [], skipped: [], warnings: [] };
         }