diff --git a/src/pipeline/persist.js b/src/pipeline/persist.js
index 3997ec4544fe9b2890f390785305f378ab3ea413..b98e4bc9bf0210ea48e7f64a23726950b81bbcad 100644
--- a/src/pipeline/persist.js
+++ b/src/pipeline/persist.js
@@ -20,93 +20,96 @@ function tryRequire(paths) {
   const error = new Error(`MODULE_NOT_FOUND: ${paths.join(' | ')}`);
   error.code = 'MODULE_NOT_FOUND';
   error.attempts = errors.map((e) => e?.message || String(e));
   throw error;
 }
 
 const { pool } = tryRequire([
   path.join(__dirname, '../../db'),
   path.join(__dirname, '../db'),
   path.join(__dirname, './db'),
   path.join(process.cwd(), 'db'),
 ]);
 // bring normalizer for contact_form synonyms (e.g., "DPDT" â†’ "2C")
 const { normalizeContactForm } = require('../utils/mpn-exploder');
 const { ensureSpecsTable } = tryRequire([
   path.join(__dirname, '../utils/schema'),
   path.join(__dirname, '../../utils/schema'),
   path.join(__dirname, '../schema'),
   path.join(process.cwd(), 'schema'),
 ]);
 const { getColumnsOf } = require('./ensure-spec-columns');
 const { normalizeValueLLM } = require('../utils/ai');
 let { renderPnTemplate: renderPnTemplateFromOrdering } = require('../utils/ordering');
 const { PN_RE } = require('../utils/patterns');
 const { getBlueprintPnTemplate } = require('../utils/getBlueprintPnTemplate');
+const { extractOrderingInfo } = require('../utils/ordering-sections');
 
 const STRICT_CODE_RULES = /^(1|true|on)$/i.test(process.env.STRICT_CODE_RULES || '1');
 const MIN_CORE_SPEC_COUNT = (() => {
   const raw = Number(process.env.MIN_CORE_SPEC_COUNT ?? 2);
   if (!Number.isFinite(raw) || raw <= 0) return 2;
   return Math.min(Math.floor(raw), 10);
 })();
 
 function norm(s) {
   return String(s || '')
     .replace(/[\s\-_/()]/g, '')
     .toUpperCase();
 }
 
 function codeForRelaySignal(spec) {
   const parts = [];
   const base = spec.pn || spec.series_code || spec.series || '';
   if (base) parts.push(base);
 
   const op = String(spec.operating_function || '').toLowerCase();
   if (op.includes('latch')) parts.push('L');
 
   const suf = (spec.suffix || '').trim();
   if (suf) parts.push(suf.toUpperCase());
 
   const cv = (spec.coil_voltage_vdc || spec.voltage || '')
     .toString()
     .replace(/\D/g, '');
   if (cv) parts.push(`DC${cv}${/H$/i.test(suf) ? 'H' : ''}`); // 'V' ëŒ€ì‹  ì ‘ë¯¸ 'H'ê¹Œì§€ ê³ ë ¤
 
   return parts
     .filter(Boolean)
     .join('-')
     .replace(/--+/g, '-');
 }
 
 function looksLikeGarbageCode(value) {
   const text = String(value ?? '');
   if (!text) return false;
   return (
     /^[a-f0-9]{20,}_\d{10,}/i.test(text)
     || /(^|_)(mech|doc|pdf)[-_]/i.test(text)
     || /pdf:|\.pdf$/i.test(text)
+    || /^ASCTB\d{3,4}[A-Z]$/i.test(text)          // Panasonic catalog doc-id
+    || /ASCTB\d{3,4}[A-Z]\s+\d{6}/i.test(text)    // with trailing yyyymm
   );
 }
 
 const META_KEYS = new Set([
   'family_slug',
   'brand',
   'brand_norm',
   'pn',
   'pn_norm',
   'code',
   'code_norm',
   'mfr_full',
   'datasheet_uri',
   'verified_in_doc',
   'display_name',
   'displayname',
   'image_uri',
   'cover',
   'series',
   'series_code',
   'raw_json',
   'last_error',
   'created_at',
   'updated_at',
 ]);
@@ -856,72 +859,81 @@ const renderPnTemplate =
 
 function buildPnIfMissing(record = {}, pnTemplate) {
   const existing = String(record.pn || '').trim();
   if (existing) return;
   const fromTemplate = renderPnTemplate(pnTemplate, record);
   // ë³¸ë¬¸ ê²€ì¦: í…œí”Œë¦¿ ê²°ê³¼ê°€ ì‹¤ì œ ë¬¸ì„œ í…ìŠ¤íŠ¸ì— ì¡´ìž¬í•  ë•Œë§Œ ì±„íƒ
   const ctxText = String(record._doc_text || record.doc_text || '');
   if (fromTemplate && ctxText && fuzzyContainsPn(ctxText, fromTemplate)) {
     record.pn = fromTemplate;
     if (!record.code) record.code = fromTemplate;
     return;
   }
   const code = String(record.code || '').trim();
   if (code) record.pn = code;
 }
 
 /**
  * @param {string} family
  * @param {import('../types/blueprint').Spec} spec
  * @param {import('../types/blueprint').Blueprint} [blueprint]
  */
 function buildBestIdentifiers(family, spec = {}, blueprint) {
   if (!spec || typeof spec !== 'object') return spec;
 
   let codeCandidate = null;
+  const docText = String(spec._doc_text || spec.doc_text || '');
   const localTemplate = getBlueprintPnTemplate(blueprint || {}, spec);
   if (localTemplate) {
     try {
-      const orderingInfo = spec.ordering_info || spec.orderingInfo || spec._ordering_info || null;
+      let orderingInfo = spec.ordering_info || spec.orderingInfo || spec._ordering_info || null;
+      // ðŸ” Fallback: if no ordering info from Vertex, derive from raw doc text
+      if (!orderingInfo) {
+        const parsed = docText ? extractOrderingInfo(docText, 200) : null;
+        if (parsed) {
+          orderingInfo = parsed;
+          spec.ordering_info = parsed; // ë‹¤ìŒ ë‹¨ê³„ì—ì„œ í…œí”Œë¦¿/ê²€ì¦ì— í™œìš©
+          spec.orderingInfo = parsed;
+        }
+      }
       const context = { ...spec };
       if (orderingInfo && typeof orderingInfo === 'object') {
         context.ordering_info = orderingInfo;
         context.orderingInfo = orderingInfo;
         if (context.codes == null && Array.isArray(orderingInfo.codes)) {
           context.codes = orderingInfo.codes;
         }
       }
       const rendered = renderPnTemplate(localTemplate, context);
       if (rendered) {
         codeCandidate = rendered;
       }
     } catch (_) {
       // ignore template rendering errors for identifier derivation
     }
   }
 
-  const docText = String(spec._doc_text || spec.doc_text || '');
   if (!codeCandidate && family === 'relay_signal') {
     const fallback = codeForRelaySignal(spec);
     if (fallback && norm(docText).includes(norm(fallback))) {
       codeCandidate = fallback;
     }
   }
   if (codeCandidate && norm(docText).includes(norm(codeCandidate))) {
     spec.pn = codeCandidate;
     spec.code = codeCandidate;
     spec.verified_in_doc = true;
   } else {
     spec.code = spec.pn;
     if (!STRICT_CODE_RULES) spec._warn_invalid_code = true;
   }
   if (!spec.verified_in_doc) {
     const oi = spec.ordering_info || spec.orderingInfo || null;
     const codes = Array.isArray(oi?.codes) ? oi.codes : null;
     if (codes && codes.length) {
       const me = String(spec.pn || spec.code || '').trim().toUpperCase();
       if (me && codes.some((c) => String(c || '').trim().toUpperCase() === me)) {
         spec.verified_in_doc = true;
       }
     }
   }