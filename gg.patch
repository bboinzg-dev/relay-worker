diff --git a/server.js b/server.js
index b3e9c0ae19c00acdb67d8b0d611217c09551ba53..54f9dfda3488a1da6da2efe133de7d57ec677172 100644
--- a/server.js
+++ b/server.js
@@ -1051,63 +1051,71 @@ async function handleWorkerIngest(req, res) {
       const overrideBrand = payload?.overrides?.brand ?? payload?.brand ?? null;
       const overrideSeries = payload?.overrides?.series ?? payload?.series ?? null;
       const nextOverrides = {
         ...(payload?.overrides || {}),
         brand: overrideBrand,
         series: overrideSeries,
       };
 
       const result = await getIngest().runAutoIngest({
         ...payload,
         runId,
         run_id: runId,
         gcsUri,
         gcs_uri: gcsUri,
         skipPersist: true,
         overrides: nextOverrides,
       });
 
       const processed = result?.processed;
       if (!processed || !Array.isArray(processed.records)) {
         throw new Error('process_no_records');
       }
 
       await markRunning(baseContext);
 
+      await db.query(
+        `UPDATE public.ingest_run_logs
+            SET detail = jsonb_set(coalesce(detail,'{}'::jsonb), '{processed}', $2::jsonb, true),
+                updated_at = now()
+          WHERE id = $1`,
+        [runId, JSON.stringify(processed)]
+      );
+
       const nextPayload = {
         runId,
         run_id: runId,
         gcsUri,
         gcs_uri: gcsUri,
         family_slug: payload?.family_slug ?? null,
         brand: payload?.brand ?? null,
         code: payload?.code ?? null,
         series: payload?.series ?? null,
         display_name: payload?.display_name ?? null,
         uploader_id: payload?.uploader_id ?? null,
         phase: 'persist',
-        processed,
+        // processed는 싣지 않음. DB에서 가져와 사용.
         overrides: nextOverrides,
       };
 
       try {
         await enqueueIngestTask(nextPayload);
         return res.status(200).json({ ok: true, runId, phase, queued: 'persist' });
       } catch (err) {
         console.error(
           '[enqueue error]',
           err?.code || err?.response?.status || err?.message,
           err?.response?.data ? JSON.stringify(err.response.data) : (err?.details || '')
         );
         console.warn('[ingest][persist fallback] attempting inline persist', { runId });
 
         await markPersisting(baseContext);
         const inlineResult = await getIngest().persistProcessedData(processed || {}, {
           brand: overrideBrand,
           code: payload?.code ?? null,
           series: overrideSeries,
           display_name: payload?.display_name ?? null,
         });
 
         const failureReasons = new Set(Array.isArray(inlineResult?.reject_reasons) ? inlineResult.reject_reasons : []);
         const warningReasons = new Set(Array.isArray(inlineResult?.warnings) ? inlineResult.warnings : []);
 
diff --git a/server.js b/server.js
index b3e9c0ae19c00acdb67d8b0d611217c09551ba53..54f9dfda3488a1da6da2efe133de7d57ec677172 100644
--- a/server.js
+++ b/server.js
@@ -1125,51 +1133,57 @@ async function handleWorkerIngest(req, res) {
 
         await markSucceeded({
           ...baseContext,
           result: inlineResult,
           gcsUri,
           durationMs: inlineResult?.ms ?? (Date.now() - startedAt),
           meta: payload,
         });
 
         return res.status(200).json({
           ok: true,
           runId,
           phase,
           persisted_inline: true,
           specs_table: inlineResult?.specs_table || null,
         });
       }
     }
 
     if (phase === 'persist') {
       await markPersisting(baseContext);
 
       const overrideBrand = payload?.overrides?.brand ?? payload?.brand ?? null;
       const overrideSeries = payload?.overrides?.series ?? payload?.series ?? null;
 
-      const out = await getIngest().persistProcessedData(payload?.processed || {}, {
+      let proc = payload?.processed || null;
+      if (!proc) {
+        const r = await db.query(`SELECT detail->'processed' AS p FROM public.ingest_run_logs WHERE id=$1`, [runId]);
+        proc = r.rows?.[0]?.p || null;
+      }
+
+      const out = await getIngest().persistProcessedData(proc || {}, {
         brand: overrideBrand,
         code: payload?.code ?? null,
         series: overrideSeries,
         display_name: payload?.display_name ?? null,
       });
 
       const reasons = new Set([...(out?.reject_reasons || []), ...(out?.warnings || [])]);
       if (!out?.ok) {
         const list = [...reasons];
         const hard = list.some((r) => /missing_|invalid_|no_records|reject/i.test(r));
         await markFailed({
           ...baseContext,
           error: list.join(',') || 'ingest_rejected',
           durationMs: out?.ms ?? (Date.now() - startedAt),
         });
         failureMarked = true;
         if (hard) {
           return res.status(200).json({ ok: false, runId, phase, reasons: list });
         }
         return res.status(500).json({ ok: false, runId, phase, reasons: list });
       }
 
       await markSucceeded({
         ...baseContext,
         result: out,
