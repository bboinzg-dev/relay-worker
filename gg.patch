*** a/server.js
--- b/server.js
@@
 const express = require('express');
 const cors = require('cors');
 const bodyParser = require('body-parser');
 const multer = require('multer');
 const crypto = require('crypto');
 const jwt = require('jsonwebtoken');
@@
 const app = express();
 
+/* ---------- ALWAYS-ON BOOT LOG ---------- */
+try {
+  console.log('[BOOT] server.js starting:', { filename: __filename, node: process.version });
+} catch {}
+
 /* ---------------- Global middleware (keep existing) ---------------- */
 app.use(cors());
 app.use(bodyParser.json({ limit: '20mb' }));
 app.use(bodyParser.urlencoded({ extended: true, limit: '20mb' }));
@@
-// --- AI routes mount (export 타입 자동 처리) ---
+// --- AI routes mount (export 타입 자동 처리) ---
 try {
   const ai = require('./server.ai');
   if (ai && typeof ai === 'object') {
     // server.ai.js 가 express.Router()를 export 하는 형태
     app.use('/api', ai);  // ==> 최종 경로: /api/ai/...
     console.log('[BOOT] mounted AI routes at /api/* (router export)');
   } else if (typeof ai === 'function') {
     // 만약 server.ai.js 가 (app)=>{ app.post('/api/ai/resolve', ...) } 로 export 한다면
     ai(app);
     console.log('[BOOT] mounted AI routes via function(export)');
   } else {
     console.warn('[BOOT] server.ai export type not supported:', typeof ai);
   }
 } catch (e) {
-  console.error('[BOOT] ai mount failed', e?.message || e);
+  console.error('[BOOT] ai mount failed', e?.message || e);
+  // 🔰 ALWAYS-ON FALLBACK: server.ai.js 로딩 실패/누락 시에도 최소 라우트 제공(404 방지)
+  const express = require('express');
+  const fb = express.Router();
+  fb.get('/ai/ping', (_req, res) => res.json({ ok: true, fallback: true }));
+  fb.get('/ai/resolve', (req, res) => res.json({ ok: true, echo: String(req.query?.q || '') }));
+  fb.post('/ai/resolve', (req, res) => res.json({ ok: true, echo: String((req.body && req.body.q) || '') }));
+  app.use('/api', fb);
+  console.warn('[BOOT] fallback AI routes mounted at /api/*');
 }
 
@@
-// 라우트 덤프 & 파일 리스트: 디버깅에 매우 유용 → ROUTE_DEBUG=1 일 때 활성화
-if (process.env.ROUTE_DEBUG === '1') {
-  app.get('/_routes', (req, res) => {
-    try {
-      const out = [];
-      const walk = (stack, base='') => {
-        stack.forEach((s) => {
-          if (s.route && s.route.path) {
-            const methods = Object.keys(s.route.methods).join(',').toUpperCase();
-            out.push(`${methods.padEnd(6)} ${base}${s.route.path}`);
-          } else if (s.name === 'router' && s.handle?.stack) {
-            // express.Router() 내부
-            walk(s.handle.stack, base);
-          }
-        });
-      };
-      walk(app._router.stack, '');
-      res.type('text/plain').send(out.join('\n') || 'no-routes');
-    } catch (e) {
-      res.status(500).json({ ok: false, error: String(e?.message || e) });
-    }
-  });
-  console.log('[BOOT] route debug at /_routes');
-  // 🔍 컨테이너 내 파일 확인: server*.js 포함 여부 즉시 점검
-  const fs = require('fs');
-  app.get('/_ls', (_req, res) => {
-    try {
-      const here = fs.readdirSync(__dirname).sort();
-      res.json({ dir: __dirname, files: here.filter(f => f.startsWith('server')) });
-    } catch (e) {
-      res.status(500).json({ ok:false, error: String(e?.message || e) });
-    }
-  });
-}
+// 🔎 ALWAYS-ON DEBUG: 디버그 라우트는 환경변수와 무관하게 항상 노출
+app.get('/_routes', (req, res) => {
+  try {
+    const out = [];
+    const walk = (stack, base='') => {
+      stack.forEach((s) => {
+        if (s.route && s.route.path) {
+          const methods = Object.keys(s.route.methods).join(',').toUpperCase();
+          out.push(`${methods.padEnd(6)} ${base}${s.route.path}`);
+        } else if (s.name === 'router' && s.handle?.stack) {
+          walk(s.handle.stack, base);
+        }
+      });
+    };
+    if (app && app._router && app._router.stack) {
+      walk(app._router.stack, '');
+    }
+    res.type('text/plain').send(out.join('\n') || 'no-routes');
+  } catch (e) {
+    res.status(500).json({ ok: false, error: String(e?.message || e) });
+  }
+});
+console.log('[BOOT] ALWAYS-ON route debug at /_routes');
+
+app.get('/_ls', (_req, res) => {
+  try {
+    const fs = require('fs');
+    const here = fs.readdirSync(__dirname).sort();
+    res.json({ dir: __dirname, files: here.filter(f => f.startsWith('server')) });
+  } catch (e) {
+    res.status(500).json({ ok:false, error: String(e?.message || e) });
+  }
+});
+console.log('[BOOT] ALWAYS-ON file lister at /_ls');
