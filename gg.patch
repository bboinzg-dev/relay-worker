diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index 350fb9f1e1bc57487934a944414acc6d19aabcf4..33c675b905bca698e66f8b301c287ed600a52816 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -4082,50 +4082,51 @@ async function doIngestPipeline(input = {}, runIdParam = null) {
       const tpl = await learnPnTemplate({
         family,
         brand: brand || extracted.brand,
         series,
         docText: fullText,
         rows: Array.isArray(records) && records.length ? records : extracted.rows,
       });
       if (tpl) {
         await upsertExtractionRecipe({ family, brand: brand || extracted.brand, series, pnTemplate: tpl });
         pnTemplate = tpl; // 이번 런에 바로 적용
       }
     }
   } catch (e) { console.warn('[pn-learn] skipped:', e?.message || e); }
 
   const processedPayload = {
     started,
     gcsUri,
     family,
     table,
     qualified,
     pnTemplate,
     requiredFields,
     coverUri,
     records,
     rows: records,
+    explodedRows,
     mpnList: Array.isArray(extracted?.mpn_list) ? extracted.mpn_list : [],
     extractedBrand: extracted?.brand || null,
     brandName,
     baseSeries,
     runId,
     run_id: runId,
     jobId,
     job_id: jobId,
     text: extractedText,
     brand: brandEffectiveResolved || extracted?.brand || null,
     brand_detected: detectedBrand || null,
     brand_effective: brandEffectiveResolved || null,
     brand_source: brandSource || null,
     variant_keys_runtime: runtimeVariantKeys,
     ordering_info: extracted?.ordering_info ?? null,
     doc_type: typeof extracted?.doc_type === 'string' ? extracted.doc_type : null,
   };
 
   console.log(
     '[DIAG] processedPayload recs=%d mpnList=%d docType=%s ordering=%s',
     Array.isArray(records) ? records.length : -1,
     Array.isArray(processedPayload.mpnList) ? processedPayload.mpnList.length : -1,
     processedPayload.doc_type || null,
     processedPayload.ordering_info ? 'yes' : 'no',
   );
@@ -4248,50 +4249,51 @@ async function runAutoIngest(payload = {}) {
     } catch (err) {
       console.warn('[ingest] failure update failed:', err?.message || err);
     }
     throw e;
   } finally {
     clearTimeout(watchdog);
     try { await db.query('SELECT pg_advisory_unlock(hashtextextended($1))', [runId]); } catch {}
     try { await db.query('SELECT pg_advisory_unlock(hashtext($1))', [runId]); } catch {}
   }
 }
 
 async function persistProcessedData(processed = {}, overrides = {}) {
   const {
     started = Date.now(),
     gcsUri = null,
     family: processedFamily = null,
     family_slug: processedFamilySlug = null,
     table: processedTable = null,
     specs_table: processedSpecsTable = null,
     qualified: qualifiedInput = null,
     pnTemplate = null,
     requiredFields = [],
     coverUri = null,
     records: initialRecords = [],
     rows: processedRowsInput = [],
+    explodedRows: processedExplodedRows = [],
     mpnList = [],
     extractedBrand = null,
     brandName = null,
     baseSeries = null,
     text: processedText = null,
     brand: processedBrand = null,
     brand_detected: processedDetected = null,
     brand_effective: processedEffective = null,
     brand_source: processedBrandSource = null,
     variant_keys_runtime: processedVariantKeys = [],
     meta: processedMeta = null,
   } = processed || {};
 
   // persist: Cloud Tasks가 별도 요청으로 호출 → 매번 family/table/colTypes 재확정 필수
   const normalizeFamily = (value) => {
     if (!value) return null;
     const trimmed = String(value).trim();
     return trimmed || null;
   };
 
   const pickFamily = (...values) => {
     for (const value of values) {
       const normalized = normalizeFamily(value);
       if (normalized) return normalized;
     }
@@ -4374,50 +4376,54 @@ async function persistProcessedData(processed = {}, overrides = {}) {
 
   if (!table) {
     throw new Error('persist_no_table');
   }
 
   if (!qualified) {
     qualified = table.includes('.') ? table : `public.${table}`;
   }
 
   let colTypes = new Map();
   try {
     colTypes = await getColumnTypes(qualified);
   } catch (err) {
     console.warn('[persist] column type fetch failed:', err?.message || err);
     colTypes = new Map();
   }
 
   const recordsSource = Array.isArray(initialRecords) && initialRecords.length
     ? initialRecords
     : (Array.isArray(processedRowsInput) ? processedRowsInput : []);
   let records = Array.isArray(recordsSource) ? recordsSource : [];
   sanitizeRecordTemplates(records);
   if (Array.isArray(processedRowsInput) && processedRowsInput !== records) {
     sanitizeRecordTemplates(processedRowsInput);
   }
+  const explodedRows = Array.isArray(processedExplodedRows) ? processedExplodedRows : [];
+  if (explodedRows.length && explodedRows !== records && explodedRows !== processedRowsInput) {
+    sanitizeRecordTemplates(explodedRows);
+  }
   const runtimeMeta = {
     brand_source: processedBrandSource ?? null,
     variant_keys_runtime: Array.isArray(processedVariantKeys) ? processedVariantKeys : [],
   };
   const hasRuntimeMeta =
     runtimeMeta.brand_source != null ||
     (Array.isArray(runtimeMeta.variant_keys_runtime) && runtimeMeta.variant_keys_runtime.length > 0);
   const docText = typeof processedText === 'string'
     ? processedText
     : (processedText != null ? String(processedText) : '');
   const normalizeSeedBrand = (value) => {
     if (value == null) return null;
     const trimmed = String(value).trim();
     if (!trimmed) return null;
     if (trimmed.toLowerCase() === 'unknown') return null;
     return trimmed;
   };
   const brandSeed =
     normalizeSeedBrand(processedEffective) ||
     normalizeSeedBrand(processedBrand) ||
     normalizeSeedBrand(processedDetected) ||
     null;
   const attachRuntimeMeta = (row) => {
     if (!hasRuntimeMeta) return;
     if (!row || typeof row !== 'object') return;