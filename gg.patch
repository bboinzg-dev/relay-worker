diff --git a/src/ingest/mpn-exploder.js b/src/ingest/mpn-exploder.js
index ae2a4d10a647c7b530f3ecd829e07a21d628710c..42043910ebb04adf35c34fe4169b5ab1d9d5b360 100644
--- a/src/ingest/mpn-exploder.js
+++ b/src/ingest/mpn-exploder.js
@@ -45,50 +45,121 @@ function pick(obj, key) {
     cand.add(a);
     cand.add(String(a).toLowerCase());
   }
   for (const k of cand) {
     const v = obj?.[k];
     if (v == null) continue;
     if (Array.isArray(v)) {
       const first = v.find((x) => x != null && String(x).trim() !== '');
       if (first != null) return first;
     }
     const s = String(v).trim();
     if (s !== '') return v;
   }
   return null;
 }
 
 function normalizeList(raw) {
   if (raw == null) return [];
   if (Array.isArray(raw)) return raw.filter(v => v != null && String(v).trim() !== '');
   const s = String(raw).trim();
   if (!s) return [];
   // "DC5V", "5 V", "05" 등에서 숫자만 뽑아 pad에 쓰기 좋게
   return s.split(LIST_SEP).map(tok => tok.trim()).filter(Boolean);
 }
 
+function getAliasKeys(key) {
+  const raw = String(key || '').trim();
+  if (!raw) return [];
+  const lower = raw.toLowerCase();
+  const seen = new Set([raw]);
+  const out = [raw];
+
+  const direct = KEY_ALIASES[lower];
+  if (Array.isArray(direct)) {
+    for (const alias of direct) {
+      const token = String(alias || '').trim();
+      if (!token || seen.has(token)) continue;
+      seen.add(token);
+      out.push(token);
+    }
+  }
+
+  for (const [base, list] of Object.entries(KEY_ALIASES)) {
+    if (!Array.isArray(list) || !list.length) continue;
+    if (!list.some((alias) => String(alias || '').trim().toLowerCase() === lower)) continue;
+    const canonical = String(base || '').trim();
+    if (canonical && !seen.has(canonical)) {
+      seen.add(canonical);
+      out.push(canonical);
+    }
+    for (const alias of list) {
+      const token = String(alias || '').trim();
+      if (!token || seen.has(token)) continue;
+      seen.add(token);
+      out.push(token);
+    }
+  }
+
+  // 대소문자 변형도 허용
+  const normalized = new Set([...out]);
+  for (const token of out) {
+    const lowerToken = token.toLowerCase();
+    if (!normalized.has(lowerToken)) {
+      normalized.add(lowerToken);
+      seen.add(lowerToken);
+    }
+  }
+
+  return Array.from(seen);
+}
+
+function readRowValue(row, key) {
+  if (!row || typeof row !== 'object') return undefined;
+  if (key in row) return row[key];
+  const lower = String(key || '').toLowerCase();
+  if (lower in row) return row[lower];
+  const upper = String(key || '').toUpperCase();
+  if (upper in row) return row[upper];
+  return undefined;
+}
+
+function collectVariantList(row, key) {
+  const direct = normalizeList(readRowValue(row, key));
+  if (direct.length) return { list: direct, sourceKey: key };
+
+  const aliases = getAliasKeys(key);
+  for (const alias of aliases) {
+    if (String(alias || '') === String(key || '')) continue;
+    const values = normalizeList(readRowValue(row, alias));
+    if (!values.length) continue;
+    return { list: values, sourceKey: alias };
+  }
+
+  return { list: [], sourceKey: key };
+}
+
 function escapeRegExp(str) {
   return String(str || '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
 }
 
 function applyTemplateMods(value, mods = []) {
   if (value == null) return '';
 
   let out = Array.isArray(value) ? value[0] : value;
   if (out == null) return '';
   if (typeof out !== 'string') out = String(out);
 
   for (const rawMod of mods) {
     const token = String(rawMod || '').trim();
     if (!token) continue;
     const [opRaw, argRaw = ''] = token.split('=').map((t) => t.trim());
     const op = opRaw.toLowerCase();
     if (!op) continue;
 
     if (op === 'pad') {
       const width = Number(argRaw);
       if (Number.isFinite(width) && width > 0) out = out.padStart(width, '0');
       continue;
     }
 
     if (op === 'map') {
diff --git a/src/ingest/mpn-exploder.js b/src/ingest/mpn-exploder.js
index ae2a4d10a647c7b530f3ecd829e07a21d628710c..42043910ebb04adf35c34fe4169b5ab1d9d5b360 100644
--- a/src/ingest/mpn-exploder.js
+++ b/src/ingest/mpn-exploder.js
@@ -293,54 +364,65 @@ function explodeToRows(blueprint, rows = [], options = {}) {
 
     if (Array.isArray(candidates) && candidates.length) {
       const seen = new Set();
       for (const raw of candidates) {
         const code = String(raw || '').trim();
         if (!code) continue;
         const norm = code.toLowerCase();
         if (seen.has(norm)) continue;
         seen.add(norm);
 
         const v = parseVariantsFromCode
           ? parseVariantsFromCode(code, blueprint?.code_rules || {})
           : {};
 
         candidateRows.push({
           ...row,
           ...v,
           code,
           code_norm: norm,
         });
       }
     }
 
     const series = row.series_code || row.series || '';
 
-    const lists = variantKeys.map((k) => {
-      const v = row[k];
-      const list = normalizeList(v);
-      return list.length ? list : [null];
+    const variantInfo = variantKeys.map((k) => {
+      const { list, sourceKey } = collectVariantList(row, k);
+      return {
+        key: k,
+        sourceKey,
+        list: list.length ? list : [null],
+      };
     });
 
+    const lists = variantInfo.map((info) => info.list);
+
     const combos = lists.length ? cartesian(lists) : [[]];
     for (const combo of combos) {
       const r = { ...row };
-      variantKeys.forEach((k, i) => { r[k] = combo[i]; });
+      variantInfo.forEach((info, idx) => {
+        const value = combo[idx];
+        const targetKey = info.key;
+        const sourceKey = info.sourceKey;
+        if (sourceKey) r[sourceKey] = value;
+        if (targetKey && targetKey !== sourceKey) r[targetKey] = value;
+      });
 
       let code = tpl
         ? renderTemplate(tpl, { ...r, series })
         : [series, ...variantKeys.map((k) => r[k]).filter(Boolean)].join('');
 
       code = String(code).replace(/\s+/g, '').trim();
       if (!code) continue;
 
       r.code = code;
       r.code_norm = code.toLowerCase();
       expandedRows.push(r);
     }
   }
 
   const rowsOut = [...expandedRows, ...candidateRows];
   return dedupeByBrandCode(rowsOut);
 }
 
 module.exports = { explodeToRows, renderTemplate, normalizeList, cartesian };
