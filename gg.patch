diff --git a/server.ai.js b/server.ai.js
index 11a00f070c17fd6fd77f8ecb4ed34d54f15b8b05..422e3a1413ac9dc354bb780cb9664c0775b84d55 100644
--- a/server.ai.js
+++ b/server.ai.js
@@ -1,25 +1,322 @@
 // server.ai.js — Express Router export (최종 경로는 /api/ai/*)
 'use strict';
+
 const express = require('express');
 const router = express.Router();
 
-// 루트 DB 모듈(필요 시 사용)
-const { query } = require('./db');
+const { VertexAI } = require('@google-cloud/vertexai');
+const db = require('./db');
+const { safeJsonParse } = require('./src/utils/safe-json');
+
+let vertexInstance = null;
+
+function getVertex() {
+  if (vertexInstance) return vertexInstance;
+  const project = process.env.GCP_PROJECT_ID || process.env.GOOGLE_CLOUD_PROJECT;
+  const location = process.env.VERTEX_LOCATION || 'us-central1';
+  if (!project) {
+    throw new Error('GCP_PROJECT_ID/GOOGLE_CLOUD_PROJECT is required');
+  }
+  vertexInstance = new VertexAI({ project, location });
+  return vertexInstance;
+}
+
+async function getFamiliesAndTables() {
+  const sql = `SELECT family_slug, specs_table FROM public.component_registry ORDER BY family_slug`;
+  const { rows } = await db.query(sql);
+  return rows.map((row) => ({ family: row.family_slug, table: row.specs_table }));
+}
+
+const FAMILY_COL_ALIAS = {
+  relay_power: {
+    amps: ['contact_rating_a', 'contact_rating_dc_a', 'contact_rating_ac_a', 'contact_rating_text'],
+    coil_v: ['coil_voltage_vdc', 'rated_coil_voltage_dc', 'coil_voltage_text', 'coil_voltage_code'],
+  },
+  relay_signal: {
+    amps: ['contact_rating_a', 'contact_rating_dc_a', 'contact_rating_ac_a', 'contact_rating_text'],
+    coil_v: ['coil_voltage_vdc', 'coil_voltage_text', 'coil_voltage_code'],
+  },
+  resistor_chip: {
+    ohm: ['resistance_ohm'],
+  },
+  mosfet: {
+    ida: ['current_id_a'],
+    vds: ['voltage_vds_v'],
+    rds: ['rds_on_mohm'],
+  },
+};
+
+function sanitizeIdentifier(input, type = 'identifier') {
+  if (!input) throw new Error(`Invalid ${type}`);
+  const text = String(input);
+  if (!/^[_a-zA-Z][_a-zA-Z0-9]*$/.test(text)) {
+    throw new Error(`Unsafe ${type}: ${text}`);
+  }
+  return text;
+}
+
+function parseSchemaAndTable(raw) {
+  if (!raw) throw new Error('Missing table');
+  const text = String(raw);
+  if (text.includes('.')) {
+    const [schema, table] = text.split('.', 2);
+    return {
+      schema: sanitizeIdentifier(schema, 'schema'),
+      table: sanitizeIdentifier(table, 'table'),
+    };
+  }
+  return { schema: 'public', table: sanitizeIdentifier(text, 'table') };
+}
+
+const NUMERIC_TYPES = new Set([
+  'smallint',
+  'integer',
+  'bigint',
+  'decimal',
+  'numeric',
+  'real',
+  'double precision',
+]);
+
+async function loadColumnMeta(schemaTable) {
+  const { schema, table } = parseSchemaAndTable(schemaTable);
+  const sql = `
+    SELECT column_name, data_type
+    FROM information_schema.columns
+    WHERE table_schema = $1 AND table_name = $2
+  `;
+  const { rows } = await db.query(sql, [schema, table]);
+  const all = new Set();
+  const numeric = new Set();
+  for (const row of rows) {
+    const col = row.column_name;
+    all.add(col);
+    if (NUMERIC_TYPES.has(row.data_type)) numeric.add(col);
+  }
+  return { schema, table, all, numeric };
+}
+
+function pickExistingColumn(candidates = [], meta) {
+  for (const candidate of candidates) {
+    if (meta.all.has(candidate)) return candidate;
+  }
+  return null;
+}
+
+function sqlNumericExpression(column, isNumeric) {
+  const colExpr = `"${column}"`;
+  if (isNumeric) return `${colExpr}::numeric`;
+  return `NULLIF(regexp_replace(${colExpr}, '[^0-9.]+', '', 'g'), '')::numeric`;
+}
+
+function buildPredicate({ family, filters = [], meta }) {
+  const where = [];
+  const params = [];
+  let paramIndex = 0;
+
+  for (const rawFilter of filters) {
+    const key = String(rawFilter?.key || '').toLowerCase();
+    if (!key) continue;
+    const op = String(rawFilter?.op || '>=').toUpperCase();
+    const value = rawFilter?.value;
+
+    const aliasList = FAMILY_COL_ALIAS[family]?.[key] || [key];
+    const column = pickExistingColumn(aliasList, meta);
+    if (!column) continue;
+
+    const numericExpr = sqlNumericExpression(column, meta.numeric.has(column));
+    const colExpr = `"${column}"`;
+
+    if (typeof value === 'number') {
+      if (!['>=', '>', '<=', '<', '=', '!='].includes(op)) continue;
+      where.push(`${numericExpr} ${op} $${++paramIndex}`);
+      params.push(value);
+      continue;
+    }
+
+    if (typeof value === 'string' && value.trim() !== '') {
+      where.push(`COALESCE(${colExpr}::text, '') ILIKE $${++paramIndex}`);
+      params.push(`%${value.trim()}%`);
+    }
+  }
+
+  return {
+    where: where.length ? `WHERE ${where.join(' AND ')}` : '',
+    params,
+  };
+}
+
+function mapRow(row) {
+  const title = row.title || `${row.brand || ''} ${row.pn || ''}`.trim();
+  return {
+    family: row.family_slug,
+    brand: row.brand,
+    pn: row.pn,
+    title: title || null,
+    uri: row.datasheet_url || row.uri || null,
+    image: row.image_uri || null,
+  };
+}
+
+async function planQuery(query, families) {
+  try {
+    const modelName = process.env.VERTEX_MODEL_ID || process.env.GEMINI_MODEL_CLASSIFY || 'gemini-2.5-flash';
+    const vertex = getVertex();
+    const mdl = vertex.getGenerativeModel({
+      model: modelName,
+      generationConfig: {
+        responseMimeType: 'application/json',
+        temperature: 0.2,
+        maxOutputTokens: 1024,
+      },
+      systemInstruction: {
+        parts: [
+          {
+            text: [
+              '너는 전자부품 검색 질의를 구조화 계획으로 바꾸는 엔진이다.',
+              `허용된 family 슬러그만 사용: ${families.map((f) => f.family).join(', ')}`,
+              '출력 JSON 스키마: {"families": string[], "filters": [{"family"?: string, "key": string, "op": ">=|>|<=|<|=|!=", "value": number|string }], "keywords": string[] }',
+              '예: "컨택트 20A 이상 릴레이" → {"families":["relay_power"],"filters":[{"family":"relay_power","key":"amps","op":">=","value":20}] }',
+            ].join('\n'),
+          },
+        ],
+      },
+    });
+
+    const resp = await mdl.generateContent({
+      contents: [
+        {
+          role: 'user',
+          parts: [{ text: query }],
+        },
+      ],
+    });
+
+    const parts = resp?.response?.candidates?.[0]?.content?.parts || [];
+    const text = parts.map((part) => part?.text || '').join('');
+    return safeJsonParse(text) || {};
+  } catch (err) {
+    console.error('[ai/search] plan generation failed:', err?.message || err);
+    return {};
+  }
+}
+
+function pickFamilies(planFamilies, allFamilies) {
+  if (!Array.isArray(planFamilies) || planFamilies.length === 0) return allFamilies;
+  const allow = new Set(planFamilies);
+  return allFamilies.filter((family) => allow.has(family.family));
+}
+
+async function queryFamilyTable({ family, filters, meta }) {
+  const { schema, table: tableName } = meta;
+  const predicate = buildPredicate({ family, filters, meta });
+  const sql = [
+    `SELECT id::text, '${family}'::text AS family_slug, brand, pn,`,
+    `CASE WHEN COALESCE(NULLIF(pn, ''), '') <> '' THEN CONCAT_WS(' ', brand, pn) ELSE COALESCE(brand, '') END AS title,`,
+    `image_uri, datasheet_url`,
+    `FROM ${schema}.${tableName}`,
+    predicate.where,
+    'ORDER BY updated_at DESC NULLS LAST',
+    'LIMIT 30',
+  ].join('\n');
+  const { rows } = await db.query(sql, predicate.params);
+  return rows.map(mapRow);
+}
+
+async function keywordFallback(keyword) {
+  if (!keyword) return [];
+  const { schema, table } = parseSchemaAndTable('retail.products_src');
+  const sql = `
+    SELECT id::text, family_slug, brand, pn, title, image_uri, datasheet_url
+    FROM ${schema}.${table}
+    WHERE (title ILIKE $1 OR brand ILIKE $1)
+    ORDER BY updated_at DESC
+    LIMIT 30
+  `;
+  const { rows } = await db.query(sql, [`%${keyword}%`]);
+  return rows.map(mapRow);
+}
+
+function mergeResults(lists) {
+  const map = new Map();
+  for (const list of lists) {
+    for (const item of list) {
+      const key = `${item.family}::${item.pn || item.uri || item.title}`;
+      if (!map.has(key)) map.set(key, item);
+    }
+  }
+  return Array.from(map.values());
+}
+
+async function runSearchPipeline(q) {
+  const families = await getFamiliesAndTables();
+  const plan = await planQuery(q, families);
+  const targetFamilies = pickFamilies(plan?.families, families);
+
+  const perFamilyResults = [];
+  const filtersByFamily = Array.isArray(plan?.filters) ? plan.filters : [];
+
+  for (const familyInfo of targetFamilies) {
+    try {
+      const meta = await loadColumnMeta(familyInfo.table);
+      const relevantFilters = filtersByFamily.filter(
+        (filter) => !filter?.family || filter.family === familyInfo.family,
+      );
+      const rows = await queryFamilyTable({
+        family: familyInfo.family,
+        filters: relevantFilters,
+        meta,
+      });
+      if (rows.length) perFamilyResults.push(rows);
+    } catch (err) {
+      console.error('[ai/search] table query failed:', familyInfo.family, err?.message || err);
+    }
+  }
+
+  let items = mergeResults(perFamilyResults);
+
+  if (items.length === 0) {
+    const keywords = Array.isArray(plan?.keywords) ? plan.keywords : [];
+    const fallbackQuery = keywords.length ? keywords.join(' ') : q;
+    items = await keywordFallback(fallbackQuery);
+  }
+
+  return { ok: true, items };
+}
+
+router.get('/search', async (req, res) => {
+  const q = String(req.query?.q || '').trim();
+  if (!q) {
+    return res.status(400).json({ ok: false, error: 'q required' });
+  }
 
-async function resolveHandler(req, res) {
   try {
-    const q = (req.body && req.body.q) || req.query?.q || '';
-    if (!q) return res.status(400).json({ ok:false, error:'q required' });
+    const payload = await runSearchPipeline(q);
+    return res.json(payload);
+  } catch (err) {
+    console.error('[ai/search] failed:', err?.message || err);
+    return res.status(500).json({ ok: false, error: String(err?.message || err) });
+  }
+});
 
-    // TODO: 여기서 Vertex(Gemini) 호출/DB 조회를 넣으세요.
-    return res.json({ ok:true, echo:q }); // 일단 경로 확인용 에코
-  } catch (e) {
-    return res.status(500).json({ ok:false, error:String(e?.message||e) });
+async function handleResolve(req, res) {
+  const q = String(req.body?.q || req.query?.q || '').trim();
+  if (!q) {
+    return res.status(400).json({ ok: false, error: 'q required' });
+  }
+
+  try {
+    const payload = await runSearchPipeline(q);
+    return res.json(payload);
+  } catch (err) {
+    console.error('[ai/resolve] failed:', err?.message || err);
+    return res.status(500).json({ ok: false, error: String(err?.message || err) });
   }
 }
 
-router.get('/resolve', resolveHandler);
-router.post('/resolve', resolveHandler);
-router.get('/ping', (_req, res) => res.json({ ok:true }));
+router.get('/resolve', handleResolve);
+router.post('/resolve', handleResolve);
+
+router.get('/ping', (_req, res) => res.json({ ok: true }));
 
 module.exports = router;