diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index 8b954f856bb798b672724608e86e320dde77e849..c49e32fc83fcc3d82170577b83aa1f4701226225 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -1668,70 +1668,140 @@ async function runAutoIngest(payload = {}) {
         `
           UPDATE public.ingest_run_logs
              SET status='FAILED',
                  event='EXCEPTION',
                  error_message=$2,
                  finished_at=now(), ts=now()
            WHERE id=$1
         `,
         [runId, msg],
       );
     } catch (err) {
       console.warn('[ingest] failure update failed:', err?.message || err);
     }
     throw e;
   } finally {
     clearTimeout(watchdog);
     try { await db.query('SELECT pg_advisory_unlock(hashtextextended($1))', [runId]); } catch {}
     try { await db.query('SELECT pg_advisory_unlock(hashtext($1))', [runId]); } catch {}
   }
 }
 
 async function persistProcessedData(processed = {}, overrides = {}) {
   const {
     started = Date.now(),
     gcsUri = null,
-    family = null,
-    table = null,
+    family: processedFamily = null,
+    family_slug: processedFamilySlug = null,
+    table: processedTable = null,
+    specs_table: processedSpecsTable = null,
     qualified: qualifiedInput = null,
     pnTemplate = null,
     requiredFields = [],
     coverUri = null,
     records: initialRecords = [],
     rows: processedRowsInput = [],
     mpnList = [],
     extractedBrand = null,
     brandName = null,
     baseSeries = null,
     text: processedText = null,
     brand: processedBrand = null,
     brand_detected: processedDetected = null,
     brand_effective: processedEffective = null,
     brand_source: processedBrandSource = null,
     variant_keys_runtime: processedVariantKeys = [],
+    meta: processedMeta = null,
   } = processed || {};
 
+  const normalizeFamily = (value) => {
+    if (!value) return null;
+    const trimmed = String(value).trim();
+    return trimmed || null;
+  };
+
+  const metaFamily =
+    normalizeFamily(processedMeta?.family) ||
+    normalizeFamily(processedMeta?.family_slug);
+  const overridesFamily =
+    normalizeFamily(overrides?.family) ||
+    normalizeFamily(overrides?.family_slug);
+  const family =
+    normalizeFamily(processedFamily) ||
+    normalizeFamily(processedFamilySlug) ||
+    metaFamily ||
+    overridesFamily ||
+    null;
+
+  const sanitizeIdentifier = (value) => {
+    const trimmed = String(value || '').trim();
+    if (!trimmed) return '';
+    if (trimmed.includes('.')) {
+      const [schemaRaw, tableRaw] = trimmed.split('.', 2);
+      const schemaSafe = String(schemaRaw || '').replace(/[^a-zA-Z0-9_]/g, '');
+      const tableSafe = String(tableRaw || '').replace(/[^a-zA-Z0-9_]/g, '');
+      if (!schemaSafe || !tableSafe) return '';
+      return `${schemaSafe}.${tableSafe}`;
+    }
+    return trimmed.replace(/[^a-zA-Z0-9_]/g, '');
+  };
+
+  const pickTableCandidate = (...values) => {
+    for (const value of values) {
+      const normalized = sanitizeIdentifier(value);
+      if (normalized) return normalized;
+    }
+    return '';
+  };
+
+  let table = pickTableCandidate(processedSpecsTable, processedTable, qualifiedInput);
+  if (!table && family) {
+    try {
+      const r = await db.query(
+        `SELECT specs_table FROM public.component_registry WHERE family_slug=$1 LIMIT 1`,
+        [family],
+      );
+      table = pickTableCandidate(r.rows?.[0]?.specs_table);
+    } catch (err) {
+      console.warn('[persist] specs_table lookup failed:', err?.message || err);
+    }
+  }
+  if (!table && family) {
+    table = sanitizeIdentifier(`${family}_specs`);
+  }
+  const qualified = qualifiedInput || (table ? (table.includes('.') ? table : `public.${table}`) : null);
+
+  let colTypes = new Map();
+  if (qualified) {
+    try {
+      colTypes = await getColumnTypes(qualified);
+    } catch (err) {
+      console.warn('[persist] column type fetch failed:', err?.message || err);
+      colTypes = new Map();
+    }
+  }
+
   const recordsSource = Array.isArray(initialRecords) && initialRecords.length
     ? initialRecords
     : (Array.isArray(processedRowsInput) ? processedRowsInput : []);
   let records = Array.isArray(recordsSource) ? recordsSource : [];
   const runtimeMeta = {
     brand_source: processedBrandSource ?? null,
     variant_keys_runtime: Array.isArray(processedVariantKeys) ? processedVariantKeys : [],
   };
   const hasRuntimeMeta =
     runtimeMeta.brand_source != null ||
     (Array.isArray(runtimeMeta.variant_keys_runtime) && runtimeMeta.variant_keys_runtime.length > 0);
   const docText = typeof processedText === 'string'
     ? processedText
     : (processedText != null ? String(processedText) : '');
   const normalizeSeedBrand = (value) => {
     if (value == null) return null;
     const trimmed = String(value).trim();
     if (!trimmed) return null;
     if (trimmed.toLowerCase() === 'unknown') return null;
     return trimmed;
   };
   const brandSeed =
     normalizeSeedBrand(processedEffective) ||
     normalizeSeedBrand(processedBrand) ||
     normalizeSeedBrand(processedDetected) ||
diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index 8b954f856bb798b672724608e86e320dde77e849..c49e32fc83fcc3d82170577b83aa1f4701226225 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -1741,51 +1811,50 @@ async function persistProcessedData(processed = {}, overrides = {}) {
     if (!row || typeof row !== 'object') return;
     row.raw_json = mergeRuntimeMetadata(row.raw_json, runtimeMeta);
   };
   if ((docText && docText.length) || brandSeed) {
     const applyRowHints = (row) => {
       if (!row || typeof row !== 'object') return;
       if (docText && (row._doc_text == null || row._doc_text === '')) {
         row._doc_text = docText;
       }
       if (brandSeed && (!row.brand || !String(row.brand).trim())) {
         row.brand = brandSeed;
       }
       attachRuntimeMeta(row);
     };
     for (const row of records) applyRowHints(row);
     if (Array.isArray(processedRowsInput) && processedRowsInput !== records) {
       for (const row of processedRowsInput) applyRowHints(row);
     }
   } else if (hasRuntimeMeta) {
     for (const row of records) attachRuntimeMeta(row);
     if (Array.isArray(processedRowsInput) && processedRowsInput !== records) {
       for (const row of processedRowsInput) attachRuntimeMeta(row);
     }
   }
 
-  const qualified = qualifiedInput || (table ? (table.startsWith('public.') ? table : `public.${table}`) : null);
   const runId = processed?.runId ?? processed?.run_id ?? overrides?.runId ?? overrides?.run_id ?? null;
   const jobId = processed?.jobId ?? processed?.job_id ?? overrides?.jobId ?? overrides?.job_id ?? null;
 
   let persistResult = { upserts: 0, written: [], skipped: [], warnings: [] };
   if (qualified && family && records.length) {
     const allowMinimal = /^(1|true|on)$/i.test(process.env.ALLOW_MINIMAL_INSERT || '0');
     const requiredList = Array.isArray(requiredFields) ? requiredFields : [];
     const effectiveRequired = allowMinimal ? [] : requiredList;
 
     const safeBrand = (value) => {
       if (value == null) return null;
       const trimmed = String(value).trim();
       if (!trimmed) return null;
       if (trimmed.toLowerCase() === 'unknown') return null;
       return trimmed;
     };
 
     let brandOverride = safeBrand(overrides?.brand)
       || safeBrand(processedEffective)
       || safeBrand(processedBrand)
       || safeBrand(brandName)
       || safeBrand(extractedBrand)
       || safeBrand(processedDetected)
       || null;
 
