diff --git a/src/utils/mpn-exploder.js b/src/utils/mpn-exploder.js
index 9f03f4033f12cf0c86e4b2244bd100d798336e8c..52038a11d587b12aa11aaf177e165bdbad68d2cb 100644
--- a/src/utils/mpn-exploder.js
+++ b/src/utils/mpn-exploder.js
@@ -1,28 +1,29 @@
 'use strict';
 
 const LIST_SEP = /[\s,;/|·•]+/;
+const VOLTAGE_UNIT_RE = /\d\s*(?:V|VAC|VDC)\b/i;
 // 패턴리스 정규화기: 1A/1B/1C/2A/2B/2C/1A1B/2AB 등 조합 처리
 function normalizeContactForm(value) {
   if (value == null) return null;
   const raw = Array.isArray(value) ? value[0] : value;
   if (raw == null) return null;
   let s = String(raw).normalize('NFKC').toLowerCase();
   if (!s.trim()) return null;
   s = s.replace(/[\s\-_/]/g, '');
   // 동의어 치환
   s = s
     .replace(/spstnc/g, '1b')
     .replace(/spst(no)?/g, '1a')
     .replace(/dpst(no)?/g, '2a')
     .replace(/spdt/g, '1c')
     .replace(/dpdt/g, '2c')
     .replace(/form/g, '');
   // (\d+)?[abc]+ 블록들을 누적 카운트
   let a = 0;
   let b = 0;
   let c = 0;
   const re = /(\d+)?([abc]+)/g;
   let m;
   while ((m = re.exec(s)) !== null) {
     const rawCount = m[1] ? Number.parseInt(m[1], 10) : 1;
     const n = Number.isFinite(rawCount) && rawCount > 0 ? rawCount : 1;
@@ -221,50 +222,70 @@ function __applyOps(val, ops = []) {
       for (const pair of mapPairs) {
         const [from, to] = pair.split('>');
         if (!from || to == null) continue;
         mapping[String(from).trim().toUpperCase()] = String(to).trim();
       }
       const key = String(s).trim().toUpperCase();
       s = mapping[key] ?? s;
       continue;
     }
   }
   return s;
 }
 
 function renderTemplate(tpl, ctx) {
   if (!tpl) return '';
   return String(tpl).replace(/\{\{?([^{}]+)\}\}?/g, (_, expr) => {
     const [head, ...pipes] = String(expr)
       .split('|')
       .map((s) => s.trim());
     if (!head) return '';
     const val = __applyOps(ctx[head], pipes);
     return val == null ? '' : String(val);
   });
 }
 
+function escapeRegex(str) {
+  return String(str || '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
+}
+
+function templateNeedsPlaceholder(tpl, key) {
+  if (!tpl || !key) return false;
+  const pattern = escapeRegex(String(key).trim());
+  if (!pattern) return false;
+  const re = new RegExp(`\{\{?\\s*${pattern}(?:\\W|\}|\\|)`, 'i');
+  return re.test(String(tpl));
+}
+
+function defaultTextContainsExact(text, pn) {
+  if (!text || !pn) return false;
+  const pattern = escapeRegex(String(pn).trim());
+  if (!pattern) return false;
+  const re = new RegExp(`(^|[^A-Za-z0-9])${pattern}(?=$|[^A-Za-z0-9])`, 'i');
+  return re.test(String(text));
+}
+
 function assignValue(target, key, value) {
   if (!key) return;
   target[key] = value;
   const lower = String(key).toLowerCase();
   if (lower && lower !== key) target[lower] = value;
 }
 
 function collectMpnSeeds(base) {
   const seeds = [];
   const seen = new Set();
 
   const push = (val) => {
     if (val == null) return;
     if (Array.isArray(val)) {
       for (const item of val) push(item);
       return;
     }
     if (typeof val === 'string') {
       const trimmed = val.trim();
       if (!trimmed) return;
       const parts = splitAndCarryPrefix(trimmed);
       if (parts.length > 1) {
         for (const part of parts) push(part);
         return;
       }
@@ -273,146 +294,237 @@ function collectMpnSeeds(base) {
       seen.add(norm);
       seeds.push(trimmed);
       return;
     }
     const str = String(val);
     const norm = str.toLowerCase();
     if (seen.has(norm)) return;
     seen.add(norm);
     seeds.push(str);
   };
 
   push(base?.mpn);
   if (base?.code) push(base.code);
 
   const extraKeys = ['mpn', 'part_number', 'part_no', 'code'];
   const values = base && typeof base.values === 'object' ? base.values : {};
   for (const key of extraKeys) push(values[key]);
   return seeds;
 }
 
 function explodeToRows(base, options = {}) {
   const variantKeys = Array.isArray(options.variantKeys)
     ? options.variantKeys.map((k) => String(k || '').trim()).filter(Boolean)
     : [];
   const pnTemplate = options.pnTemplate || null;
+  const haystackInput = options.haystack;
+  const haystack = Array.isArray(haystackInput)
+    ? haystackInput.filter((chunk) => typeof chunk === 'string' && chunk.trim()).join('\n')
+    : typeof haystackInput === 'string'
+      ? haystackInput
+      : '';
+  const textContainsExactFn =
+    typeof options.textContainsExact === 'function' ? options.textContainsExact : defaultTextContainsExact;
+  const previewOnly = Boolean(options.previewOnly);
+  const maxTemplateAttemptsRaw = Number(options.maxTemplateAttempts);
+  const maxTemplateAttempts = Number.isFinite(maxTemplateAttemptsRaw) && maxTemplateAttemptsRaw > 0
+    ? Math.floor(maxTemplateAttemptsRaw)
+    : null;
+  const onTemplateRender = typeof options.onTemplateRender === 'function' ? options.onTemplateRender : null;
 
   const values = {};
   if (base && typeof base.values === 'object') {
     for (const [rawKey, rawValue] of Object.entries(base.values)) {
       const key = String(rawKey || '').trim();
       if (!key) continue;
       assignValue(values, key, rawValue);
     }
   }
   if (base?.series && values.series == null) assignValue(values, 'series', base.series);
   if (base?.series_code && values.series_code == null) assignValue(values, 'series_code', base.series_code);
 
   const lists = variantKeys.map((key) => {
     const fromExact = values[key];
     if (fromExact != null) {
       const normed = normalizeList(fromExact);
       return normed.length ? normed : [fromExact];
     }
     const lower = key.toLowerCase();
     if (values[lower] != null) {
       const normed = normalizeList(values[lower]);
       return normed.length ? normed : [values[lower]];
     }
     return [null];
   });
 
   const combos = lists.length ? cartesian(lists) : [[]];
   const mpnCandidates = collectMpnSeeds(base);
 
   const rows = [];
-  combos.forEach((combo, idx) => {
+  let templateAttempts = 0;
+  for (let idx = 0; idx < combos.length; idx += 1) {
+    if (maxTemplateAttempts && templateAttempts >= maxTemplateAttempts) break;
+    const combo = combos[idx];
     const rowValues = { ...values };
     variantKeys.forEach((key, keyIdx) => {
       const val = combo[keyIdx];
       if (val == null || val === '') return;
       assignValue(rowValues, key, val);
     });
 
     const normalizedSeries = normalizeSeriesCode(
       rowValues.series_code
         ?? rowValues.series
         ?? base?.series_code
         ?? base?.series
         ?? null,
     );
     if (normalizedSeries) {
       assignValue(rowValues, 'series_code', normalizedSeries);
       if (rowValues.series == null) assignValue(rowValues, 'series', normalizedSeries);
     }
 
     const normalizedContactForm = normalizeContactForm(
       rowValues.contact_form
         ?? rowValues.contact_arrangement
         ?? rowValues.form
         ?? null,
     );
     if (normalizedContactForm) assignValue(rowValues, 'contact_form', normalizedContactForm);
     else {
       delete rowValues.contact_form;
       delete rowValues.contactform;
     }
 
     assignValue(rowValues, 'coil_voltage_text', rowValues.coil_voltage_vdc);
-    const normalizedCoilVoltage = normalizeCoilVoltage(rowValues.coil_voltage_vdc);
-    if (normalizedCoilVoltage) assignValue(rowValues, 'coil_voltage_vdc', normalizedCoilVoltage);
+    const normalizedCoilVoltageVdc = normalizeCoilVoltage(rowValues.coil_voltage_vdc);
+    if (normalizedCoilVoltageVdc) assignValue(rowValues, 'coil_voltage_vdc', normalizedCoilVoltageVdc);
     else {
       delete rowValues.coil_voltage_vdc;
       delete rowValues.coil_voltagevdc;
     }
 
-    const canUseTemplate = pnTemplate && normalizedSeries;
+    const normalizedCoilVoltageVac = normalizeCoilVoltage(rowValues.coil_voltage_vac);
+    if (normalizedCoilVoltageVac) assignValue(rowValues, 'coil_voltage_vac', normalizedCoilVoltageVac);
+    else {
+      delete rowValues.coil_voltage_vac;
+      delete rowValues.coil_voltagevac;
+    }
+
+    const needsCoil = pnTemplate
+      && (templateNeedsPlaceholder(pnTemplate, 'coil_voltage_vdc')
+        || templateNeedsPlaceholder(pnTemplate, 'coil_voltage_vac'));
+    const needsContact = pnTemplate && templateNeedsPlaceholder(pnTemplate, 'contact_form');
+    const needsTerm = pnTemplate && templateNeedsPlaceholder(pnTemplate, 'terminal_shape');
+    const needsOp = pnTemplate && templateNeedsPlaceholder(pnTemplate, 'operating_function');
+    const needsPack = pnTemplate && templateNeedsPlaceholder(pnTemplate, 'packing_style');
+
+    const hasCoil = Boolean(
+      normalizeCoilVoltage(rowValues.coil_voltage_vdc ?? rowValues.coil_voltage_vac),
+    );
+    const hasContact = Boolean(rowValues.contact_form ?? rowValues.contactform);
+    const hasTerm = Boolean(
+      rowValues.terminal_shape
+        ?? rowValues.terminalshape
+        ?? rowValues.terminal_form
+        ?? rowValues.terminalform,
+    );
+    const hasOp = Boolean(rowValues.operating_function ?? rowValues.operatingfunction);
+    const hasPack = Boolean(rowValues.packing_style ?? rowValues.packingstyle);
 
     let generatedByTemplate = false;
     let code = null;
+    let attempted = false;
 
-    if (pnTemplate && canUseTemplate) {
-      code = renderTemplate(pnTemplate, {
+    if (pnTemplate) {
+      if (!normalizedSeries) continue;
+      if (needsCoil && !hasCoil) continue;
+      if (needsContact && !hasContact) continue;
+      if (needsTerm && !hasTerm) continue;
+      if (needsOp && !hasOp) continue;
+      if (needsPack && !hasPack) continue;
+
+      const context = {
         ...rowValues,
         series: normalizedSeries,
         series_code: normalizedSeries,
         contact_form: normalizedContactForm,
-        coil_voltage_vdc: normalizedCoilVoltage,
-      });
+        coil_voltage_vdc: normalizedCoilVoltageVdc,
+        coil_voltage_vac: normalizedCoilVoltageVac,
+      };
+
+      const rendered = renderTemplate(pnTemplate, context);
+      attempted = true;
+      templateAttempts += 1;
+      const renderedCode = typeof rendered === 'string' ? rendered.trim() : String(rendered || '').trim();
+      if (!renderedCode) {
+        if (onTemplateRender) onTemplateRender({ accepted: false, reason: 'empty_render', context });
+        continue;
+      }
+      if (needsCoil && !VOLTAGE_UNIT_RE.test(renderedCode)) {
+        if (onTemplateRender) {
+          onTemplateRender({
+            accepted: false,
+            reason: 'missing_voltage_unit',
+            candidate: renderedCode,
+            context,
+          });
+        }
+        continue;
+      }
+      if (haystack && !textContainsExactFn(haystack, renderedCode)) {
+        if (onTemplateRender) {
+          onTemplateRender({
+            accepted: false,
+            reason: 'missing_doc_evidence',
+            candidate: renderedCode,
+            context,
+          });
+        }
+        continue;
+      }
+      code = renderedCode;
       generatedByTemplate = true;
+      if (onTemplateRender) {
+        onTemplateRender({ accepted: true, candidate: renderedCode, context });
+      }
     } else if (mpnCandidates[idx]) {
       code = mpnCandidates[idx];
     } else if (mpnCandidates.length) {
       code = mpnCandidates[0];
     } else {
       // 템플릿/표 후보가 없으면 "임의 PN"을 만들지 않는다 (가짜 PN 차단)
-      return;
+      continue;
     }
 
     code = String(code || '').trim();
-    if (!code) return;
+    if (!code) continue;
 
-    if (generatedByTemplate && !isLikelyPn(code)) return;
+    if (generatedByTemplate && !isLikelyPn(code)) continue;
 
     const codeNorm = code.toLowerCase();
-    if (rows.some((r) => r.code_norm === codeNorm)) return;
+    if (rows.some((r) => r.code_norm === codeNorm)) continue;
 
-    rows.push({
-      code,
-      code_norm: codeNorm,
-      values: rowValues,
-    });
-  });
+    if (!previewOnly) {
+      rows.push({
+        code,
+        code_norm: codeNorm,
+        values: rowValues,
+      });
+    }
+
+    if (maxTemplateAttempts && attempted && templateAttempts >= maxTemplateAttempts) break;
+  }
 
   return rows;
 }
 
 module.exports = {
   LIST_SEP,
   NON_MPN_WORDS,
   splitAndCarryPrefix,
   normalizeList,
   cartesian,
   renderTemplate,
   explodeToRows,
   normalizeContactForm,
 };
\ No newline at end of file