diff --git a/src/pipeline/persist.js b/src/pipeline/persist.js
index fcc492783204886dca6364a0c3b8d17d62feb325..e897fc055784deabbfd83ee8151ab11e62fb1917 100644
--- a/src/pipeline/persist.js
+++ b/src/pipeline/persist.js
@@ -135,50 +135,173 @@ async function normalizeValueWithCache(params) {
   llmNormalizationCache.set(cacheKey, task);
   return task;
 }
 
 function normKey(key) {
   return String(key || '')
     .trim()
     .toLowerCase();
 }
 
 function sha1(input) {
   return crypto.createHash('sha1').update(String(input || '')).digest('hex');
 }
 
 function isMinimalFallbackPn(value) {
   return typeof value === 'string' && value.startsWith('pdf:');
 }
 
 function isValidCode(value) {
   const trimmed = String(value || '').trim();
   if (!trimmed) return false;
   if (isMinimalFallbackPn(trimmed)) return true;
   return PN_RE.test(trimmed);
 }
 
+function pickFiniteNumber(...candidates) {
+  for (const candidate of candidates) {
+    if (candidate == null || candidate === '') continue;
+    const num = Number(candidate);
+    if (Number.isFinite(num)) return num;
+  }
+  return null;
+}
+
+function normalizeDocType(value) {
+  if (value == null) return null;
+  const str = String(value).trim().toLowerCase();
+  if (!str) return null;
+  if (str.startsWith('order')) return 'ordering';
+  if (str.startsWith('catalog') || str.startsWith('multi')) return 'catalog';
+  if (str.startsWith('single') || str.startsWith('one')) return 'single';
+  return null;
+}
+
+function normalizeOrderingInfoPayload(raw) {
+  if (raw == null) return null;
+  let value = raw;
+  if (typeof value === 'string') {
+    const trimmed = value.trim();
+    if (!trimmed) return null;
+    try {
+      value = JSON.parse(trimmed);
+    } catch (_) {
+      return null;
+    }
+  }
+
+  if (Array.isArray(value)) {
+    const sections = value
+      .map((entry) => normalizeOrderingInfoPayload(entry))
+      .filter((entry) => entry && typeof entry === 'object');
+    if (!sections.length) return null;
+    if (sections.length === 1) return sections[0];
+    return { sections };
+  }
+
+  if (!value || typeof value !== 'object') return null;
+
+  const codes = [];
+  const seenCodes = new Set();
+  const collectCode = (input) => {
+    const str = typeof input === 'string' ? input : String(input ?? '');
+    const trimmed = str.trim();
+    if (!trimmed) return;
+    const normalized = trimmed.toUpperCase();
+    if (seenCodes.has(normalized)) return;
+    seenCodes.add(normalized);
+    codes.push(normalized);
+  };
+
+  if (Array.isArray(value.codes)) {
+    for (const code of value.codes) collectCode(code);
+  }
+  if (!codes.length && Array.isArray(value.scored)) {
+    for (const entry of value.scored) {
+      if (!entry || typeof entry !== 'object') continue;
+      collectCode(entry.code);
+    }
+  }
+  if (!codes.length && Array.isArray(value.sections)) {
+    for (const section of value.sections) {
+      const normalized = normalizeOrderingInfoPayload(section);
+      if (!normalized) continue;
+      if (Array.isArray(normalized.codes)) {
+        for (const code of normalized.codes) collectCode(code);
+      }
+    }
+  }
+
+  if (!codes.length) return null;
+
+  const textSources = [
+    value.text,
+    value.window_text,
+    value.windowText,
+    value?.window?.text,
+  ];
+  let text = null;
+  for (const candidate of textSources) {
+    if (typeof candidate === 'string' && candidate.trim()) {
+      text = candidate;
+      break;
+    }
+  }
+
+  const start = pickFiniteNumber(value.start, value.window_start, value?.window?.start);
+  const end = pickFiniteNumber(value.end, value.window_end, value?.window?.end);
+  const anchorIndex = pickFiniteNumber(
+    value.anchor_index,
+    value.anchorIndex,
+    value?.window?.anchor_index,
+    value?.window?.anchorIndex,
+  );
+
+  const scored = Array.isArray(value.scored)
+    ? value.scored
+        .map((entry) => {
+          if (!entry || typeof entry !== 'object') return null;
+          const code = typeof entry.code === 'string' ? entry.code.trim().toUpperCase() : null;
+          if (!code) return null;
+          const score = Number(entry.score);
+          const normalized = { code };
+          if (Number.isFinite(score)) normalized.score = score;
+          return normalized;
+        })
+        .filter(Boolean)
+    : null;
+
+  const payload = { codes };
+  if (text) payload.text = text;
+  if (start != null) payload.start = start;
+  if (end != null) payload.end = end;
+  if (anchorIndex != null) payload.anchor_index = anchorIndex;
+  if (scored && scored.length) payload.scored = scored;
+
+  return payload;
+}
+
 function repairPn(raw) {
   if (!raw) return null;
   let s = String(raw).trim();
   if (!s) return null;
   if (BANNED_PREFIX.test(s) || BANNED_EXACT.test(s)) return null;
   s = s.replace(/[–—―]/g, '-');
   s = s.replace(/\s+/g, '');
   s = s.replace(/[^0-9A-Za-z\-_/().]/g, '');
   if (BANNED_PREFIX.test(s) || BANNED_EXACT.test(s)) return null;
   return s.length >= 3 ? s : null;
 }
 
 function isNumericType(type = '') {
   const t = String(type || '').toLowerCase();
   return (
     t.includes('int') ||
     t.includes('numeric') ||
     t.includes('decimal') ||
     t.includes('real') ||
     t.includes('double')
   );
 }
 
 function parseNumberToken(token, suffix) {
   if (!token) return null;
diff --git a/src/pipeline/persist.js b/src/pipeline/persist.js
index fcc492783204886dca6364a0c3b8d17d62feb325..e897fc055784deabbfd83ee8151ab11e62fb1917 100644
--- a/src/pipeline/persist.js
+++ b/src/pipeline/persist.js
@@ -806,50 +929,52 @@ async function saveExtractedSpecs(targetTable, familySlug, rows = [], options =
   if (jobId) suffixParts.push(`job:${jobId}`);
   const appNameSuffix = suffixParts.length ? ` ${suffixParts.join(' ')}` : '';
 
   const guard = await ensureSchemaGuards(familySlug);
   if (!guard.ok) {
     result.skipped.push({ reason: guard.reason || 'schema_not_ready', detail: guard.detail || null });
     return result;
   }
 
   const physicalCols = await getColumnsOf(targetTable);
   if (!physicalCols.size) {
     result.skipped.push({ reason: 'schema_not_ready' });
     return result;
   }
 
   if (!physicalCols.has('pn') || !physicalCols.has('brand_norm') || !physicalCols.has('code_norm')) {
     result.skipped.push({ reason: 'schema_not_ready' });
     return result;
   }
 
   const columnTypes = await getColumnTypes(targetTable);
   const blueprintMeta = options?.blueprint || null;
   const blueprintFieldMap = buildBlueprintFieldMap(blueprintMeta);
   const blueprintAllowedSet = buildAllowedKeySet(blueprintMeta);
   const pnTemplate = typeof options.pnTemplate === 'string' && options.pnTemplate ? options.pnTemplate : null;
+  const sharedOrderingInfo = normalizeOrderingInfoPayload(options?.orderingInfo);
+  const sharedDocType = normalizeDocType(options?.docType);
   const requiredKeys = Array.isArray(options.requiredKeys)
     ? options.requiredKeys.map((k) => normKey(k)).filter(Boolean)
     : [];
   const explicitCoreKeys = Array.isArray(options.coreSpecKeys)
     ? options.coreSpecKeys.map((k) => normKey(k)).filter(Boolean)
     : [];
   const guardKeys = explicitCoreKeys.length ? explicitCoreKeys : requiredKeys;
   let candidateSpecKeys = [];
 
   const allKeys = new Set();
   for (const meta of META_KEYS) {
     if (physicalCols.has(meta)) allKeys.add(meta);
   }
   for (const col of columnTypes.keys()) {
     if (/_min(?:_[a-z0-9]+)?$/.test(col) || /_max(?:_[a-z0-9]+)?$/.test(col)) {
       allKeys.add(col);
     }
   }
 
   for (const row of rows) {
     for (const key of Object.keys(row || {})) {
       const normalized = normKey(key);
       if (physicalCols.has(normalized)) allKeys.add(normalized);
     }
   }
diff --git a/src/pipeline/persist.js b/src/pipeline/persist.js
index fcc492783204886dca6364a0c3b8d17d62feb325..e897fc055784deabbfd83ee8151ab11e62fb1917 100644
--- a/src/pipeline/persist.js
+++ b/src/pipeline/persist.js
@@ -900,50 +1025,92 @@ async function saveExtractedSpecs(targetTable, familySlug, rows = [], options =
           row?._doc_text ??
           row?.doc_text ??
           (options?.docText || options?.doc_text) ??
           '',
       );
       const docTextLower = docTextRaw.toLowerCase();
       const brandCandidates = [options?.brand, rec.brand, rec.brand_norm];
       let brandKey = null;
       for (const candidate of brandCandidates) {
         if (!candidate) continue;
         const trimmed = String(candidate).trim();
         if (!trimmed) continue;
         brandKey = await normalizeBrand(trimmed, docTextLower);
         if (brandKey) break;
       }
       if (brandKey) {
         if (!rec.brand || !String(rec.brand).trim()) {
           rec.brand = options?.brand || brandKey;
         }
         rec.brand_norm = brandKey;
       } else if (physicalCols.has('brand_norm')) {
         rec.brand_norm = null;
       }
       if (physicalCols.has('last_error')) rec.last_error = null;
 
+      let orderingPayload = sharedOrderingInfo;
+      if (Object.prototype.hasOwnProperty.call(rec, 'ordering_info') && rec.ordering_info != null) {
+        orderingPayload = normalizeOrderingInfoPayload(rec.ordering_info) || orderingPayload;
+      }
+
+      let docTypeValue = sharedDocType;
+      if (Object.prototype.hasOwnProperty.call(rec, 'doc_type')) {
+        const normalizedRowDocType = normalizeDocType(rec.doc_type);
+        if (normalizedRowDocType) docTypeValue = normalizedRowDocType;
+      }
+
+      if (orderingPayload || docTypeValue) {
+        let rawHolder = rec.raw_json;
+        if (typeof rawHolder === 'string') {
+          try {
+            rawHolder = JSON.parse(rawHolder);
+          } catch (_) {
+            rawHolder = {};
+          }
+        }
+        if (!rawHolder || typeof rawHolder !== 'object' || Array.isArray(rawHolder)) {
+          rawHolder = {};
+        }
+        if (orderingPayload && !rawHolder.ordering_info) {
+          let cloned = orderingPayload;
+          try {
+            cloned = JSON.parse(JSON.stringify(orderingPayload));
+          } catch (_) {}
+          rawHolder.ordering_info = cloned;
+        }
+        if (docTypeValue && !rawHolder.doc_type) {
+          rawHolder.doc_type = docTypeValue;
+        }
+        rec.raw_json = rawHolder;
+      }
+      if (Object.prototype.hasOwnProperty.call(rec, 'ordering_info')) {
+        delete rec.ordering_info;
+      }
+      if (Object.prototype.hasOwnProperty.call(rec, 'doc_type')) {
+        delete rec.doc_type;
+      }
+
       const templateContext = { ...rec };
       const ctxText = docTextRaw;
       const pnWasTemplate = looksLikeTemplate(templateContext.pn);
       const codeWasTemplate = looksLikeTemplate(templateContext.code);
 
       if (pnWasTemplate) {
         const renderedPn = renderAnyTemplate(templateContext.pn, templateContext, ctxText);
         rec.pn = renderedPn ?? null;
       }
 
       if (codeWasTemplate) {
         const contextForCode = { ...templateContext, pn: rec.pn ?? templateContext.pn };
         const renderedCode = renderAnyTemplate(templateContext.code, contextForCode, ctxText);
         rec.code = renderedCode ?? null;
       }
 
       if (!isValidCode(rec.pn) && isValidCode(rec.code)) {
         rec.pn = rec.code;
       }
 
       if (!isValidCode(rec.pn) && allowMinimalStrict) {
         const base = fallbackHash || sha1(`${targetTable || ''}:${familySlug || ''}`);
         const fallbackPn = `pdf:${base}#${rowIndex + 1}`;
         rec.pn = fallbackPn;
         if (!rec.code || !isValidCode(rec.code)) {
