diff --git a/src/utils/schema.js b/src/utils/schema.js
index 055f7145139a0b37a2980c521cbbd0a5d2ed9a08..d6bb814cb56370f0381b51a6bb07220bd10f8803 100644
--- a/src/utils/schema.js
+++ b/src/utils/schema.js
@@ -255,42 +255,41 @@ async function upsertByBrandCode(tableName, values = {}) {
     [schema, table],
   );
   const allowed = new Set(meta.rows.map((r) => String(r.column_name).toLowerCase()));
   const generated = new Set(
     meta.rows
       .filter((r) => String(r.is_generated || '').toUpperCase() === 'ALWAYS')
       .map((r) => String(r.column_name).toLowerCase()),
   );
 
   const insertCols = [];
   const insertVals = [];
   for (const col of cols) {
     if (!allowed.has(col)) continue;
     if (generated.has(col)) continue;
     insertCols.push(col);
     insertVals.push(payload[col]);
   }
   if (!insertCols.length) return null;
 
   const params = insertCols.map((_, i) => `$${i + 1}`);
   const updates = insertCols
     .filter((col) => !NO_UPDATE.has(col))
     .map((col) => `${col}=EXCLUDED.${col}`);
 
   // Spec tables enforce uniqueness via the expression index (lower(brand), lower(pn)).
-  // Prefer targeting the named index when available, but fall back to the raw expression.
-  const conflictByExpr = `ON CONFLICT ((lower(brand)), (lower(pn)))`;
-  const conflictByName = `ON CONFLICT ON CONSTRAINT ux_${table}_brandpn_expr`;
-  const conflict = table ? conflictByName : conflictByExpr;
+  // The backing database creates this as an expression index (not a constraint),
+  // therefore we must always target the raw expression in ON CONFLICT clauses.
+  const conflict = `ON CONFLICT ((lower(brand)), (lower(pn)))`;
 
   const sql = `
     insert into ${qualified} (${insertCols.join(',')})
     values (${params.join(',')})
     ${conflict}
     do update set ${updates.length ? `${updates.join(', ')}, ` : ''}updated_at=now()
     returning *`;
 
   const res = await db.query(sql, insertVals);
   return res.rows?.[0] || null;
 }
 
 module.exports = { ensureSpecsTable, upsertByBrandCode };
