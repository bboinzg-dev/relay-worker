diff --git a/src/pipeline/persist.js b/src/pipeline/persist.js
index f94a179831e011301569394443cc8b83ed302f9d..5268c38ae257ad038f495dfb30774a4140b6f6b6 100644
--- a/src/pipeline/persist.js
+++ b/src/pipeline/persist.js
@@ -71,61 +71,64 @@ const META_KEYS = new Set([
   'family_slug',
   'brand',
   'brand_norm',
   'pn',
   'pn_norm',
   'code',
   'code_norm',
   'mfr_full',
   'datasheet_uri',
   'verified_in_doc',
   'display_name',
   'displayname',
   'image_uri',
   'cover',
   'series',
   'series_code',
   'raw_json',
   'last_error',
   'created_at',
   'updated_at',
 ]);
 
 const CONFLICT_KEYS = ['brand', 'pn'];
 const NEVER_INSERT = new Set(['id', 'brand_norm', 'code_norm', 'pn_norm', 'created_at', 'updated_at']);
 
-const PN_RE = /\b[0-9A-Z][0-9A-Z\-_/().]{3,63}[0-9A-Z)]\b/i;
+const PN_RE = /\b[0-9A-Z][0-9A-Z\-_/().#]{3,63}[0-9A-Z)#]\b/i;
 const FORBIDDEN_RE = /(pdf|font|xref|object|type0|ffff)/i;
 const BANNED_PREFIX = /^(pdf|page|figure|table|sheet|rev|ver|draft)\b/i;
 const BANNED_EXACT = /^pdf-?1(\.\d+)?$/i;
 
-const RANGE_PATTERN = /(-?\d+(?:,\d{3})*(?:\.\d+)?)(?:\s*([kmgmunpµ]))?(?:\s*[a-z%°]*)?\s*(?:to|~|–|—|-)\s*(-?\d+(?:,\d{3})*(?:\.\d+)?)(?:\s*([kmgmunpµ]))?/i;
-const NUMBER_PATTERN = /(-?\d+(?:,\d{3})*(?:\.\d+)?)(?:\s*([kmgmunpµ]))?/i;
+const RANGE_PATTERN = /(-?\d+(?:,\d{3})*(?:\.\d+)?)(?:\s*([kmgKMGmunpµ]))?(?:\s*[a-z%°]*)?\s*(?:to|~|–|—|-)\s*(-?\d+(?:,\d{3})*(?:\.\d+)?)(?:\s*([kmgKMGmunpµ]))?/i;
+const NUMBER_PATTERN = /(-?\d+(?:,\d{3})*(?:\.\d+)?)(?:\s*([kmgKMGmunpµ]))?/i;
 const SCALE_MAP = {
   k: 1e3,
+  K: 1e3,
   m: 1e-3,
+  M: 1e6,
   g: 1e9,
+  G: 1e9,
   'µ': 1e-6,
   u: 1e-6,
   n: 1e-9,
   p: 1e-12,
 };
 
 const LLM_CONFIDENCE_THRESHOLD = (() => {
   const raw = Number(process.env.SPEC_AI_CONFIDENCE_MIN ?? process.env.SPEC_NORMALIZE_CONFIDENCE ?? 0.5);
   return Number.isFinite(raw) ? raw : 0.5;
 })();
 
 const llmNormalizationCache = new Map();
 
 function buildBlueprintFieldMap(blueprint) {
   const map = new Map();
   if (!blueprint) return map;
 
   const raw =
     (blueprint.fields && typeof blueprint.fields === 'object' && blueprint.fields) ||
     blueprint.fields_json ||
     blueprint;
 
   if (Array.isArray(raw)) {
     for (const entry of raw) {
       if (!entry || typeof entry !== 'object') continue;
@@ -323,73 +326,77 @@ function normalizeOrderingInfoPayload(raw) {
           const score = Number(entry.score);
           const normalized = { code };
           if (Number.isFinite(score)) normalized.score = score;
           return normalized;
         })
         .filter(Boolean)
     : null;
 
   const payload = { codes };
   if (text) payload.text = text;
   if (start != null) payload.start = start;
   if (end != null) payload.end = end;
   if (anchorIndex != null) payload.anchor_index = anchorIndex;
   if (scored && scored.length) payload.scored = scored;
 
   return payload;
 }
 
 function repairPn(raw) {
   if (!raw) return null;
   let s = String(raw).trim();
   if (!s) return null;
   if (BANNED_PREFIX.test(s) || BANNED_EXACT.test(s)) return null;
   s = s.replace(/[–—―]/g, '-');
   s = s.replace(/\s+/g, '');
-  s = s.replace(/[^0-9A-Za-z\-_/().]/g, '');
+  s = s.replace(/[^0-9A-Za-z\-_/().#]/g, '');
   if (BANNED_PREFIX.test(s) || BANNED_EXACT.test(s)) return null;
   return s.length >= 3 ? s : null;
 }
 
 function isNumericType(type = '') {
   const t = String(type || '').toLowerCase();
   return (
     t.includes('int') ||
     t.includes('numeric') ||
     t.includes('decimal') ||
     t.includes('real') ||
     t.includes('double')
   );
 }
 
 function parseNumberToken(token, suffix) {
   if (!token) return null;
   const cleaned = token.replace(/,/g, '');
   const base = Number(cleaned);
   if (!Number.isFinite(base)) return null;
   if (!suffix) return base;
-  const scale = SCALE_MAP[suffix.toLowerCase()];
+  const trimmedSuffix = String(suffix).trim();
+  if (!trimmedSuffix) return base;
+  const direct = SCALE_MAP[trimmedSuffix];
+  if (direct != null) return base * direct;
+  const scale = SCALE_MAP[trimmedSuffix.toLowerCase()];
   return scale != null ? base * scale : base;
 }
 
 function parseNumericOrRange(value) {
   if (value == null || value === '') return { value: null };
   if (typeof value === 'number') {
     return Number.isFinite(value) ? { value } : { value: null };
   }
 
   const str = String(value).trim();
   if (!str) return { value: null };
 
   const rangeMatch = str.match(RANGE_PATTERN);
   if (rangeMatch) {
     const min = parseNumberToken(rangeMatch[1], rangeMatch[2]);
     const max = parseNumberToken(rangeMatch[3], rangeMatch[4]);
     if (min != null && max != null) return { range: { min, max } };
   }
 
   const singleMatch = str.match(NUMBER_PATTERN);
   if (singleMatch) {
     const parsed = parseNumberToken(singleMatch[1], singleMatch[2]);
     return { value: parsed };
   }
 
@@ -739,54 +746,58 @@ function renderAnyTemplate(template, record = {}, ctxOrOptions = {}, maybeOption
 
   const single = renderTemplateWithPattern(working, context, /\{\s*([^{}]+?)\s*\}/g);
   working = single.rendered;
   if (single.used) used = true;
 
   if (!used) return null;
   const collapseWhitespace = options?.collapseWhitespace !== false;
   let cleaned = collapseWhitespace ? working.replace(/\s+/g, '') : working;
   cleaned = cleaned.trim();
   return cleaned || null;
 }
 
 function renderPnTemplateLocal(template, record = {}) {
   return renderAnyTemplate(template, record);
 }
 
 const renderPnTemplate =
   typeof renderPnTemplateFromOrdering === 'function' ? renderPnTemplateFromOrdering : renderPnTemplateLocal;
 
 function buildPnIfMissing(record = {}, pnTemplate) {
   const existing = String(record.pn || '').trim();
   if (existing) return;
   const fromTemplate = renderPnTemplate(pnTemplate, record);
   // 본문 검증: 템플릿 결과가 실제 문서 텍스트에 존재할 때만 채택
   const ctxText = String(record._doc_text || record.doc_text || '');
-  if (fromTemplate && ctxText && ctxText.includes(fromTemplate)) {
-    record.pn = fromTemplate;
-    if (!record.code) record.code = fromTemplate;
-    return;
+  if (fromTemplate && ctxText) {
+    const normalizedContext = norm(ctxText);
+    const normalizedTemplate = norm(fromTemplate);
+    if (normalizedTemplate && normalizedContext.includes(normalizedTemplate)) {
+      record.pn = fromTemplate;
+      if (!record.code) record.code = fromTemplate;
+      return;
+    }
   }
   const code = String(record.code || '').trim();
   if (code) record.pn = code;
 }
 
 function buildBestIdentifiers(family, spec = {}, blueprint) {
   if (!spec || typeof spec !== 'object') return spec;
 
   let codeCandidate = null;
   if (blueprint?.pn_template) {
     try {
       codeCandidate = renderPnTemplate(blueprint.pn_template, spec);
     } catch (_) {}
   }
 
   if (!codeCandidate && family === 'relay_signal') {
     codeCandidate = codeForRelaySignal(spec);
   }
 
   const docText = String(spec._doc_text || spec.doc_text || '');
   if (codeCandidate && norm(docText).includes(norm(codeCandidate))) {
     spec.pn = codeCandidate;
     spec.code = codeCandidate;
     spec.verified_in_doc = true;
   } else {