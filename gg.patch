diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index 72484a18a028be92eb46f1a0cc4377890c53ff28..dd1825fc963f8b46c906fa2197e17be1562297a0 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -524,96 +524,113 @@ async function runAutoIngest({
         if (raw && raw.length > 1000) {
           const fieldsJson = Object.fromEntries((allowedKeys||[]).map(k => [k, 'text']));
           const vals = await extractFields(raw, code || '', fieldsJson);
           extracted = {
             brand: brand || 'unknown',
             rows: [{ brand: brand || 'unknown', code: code || (path.parse(fileName).name), ...(vals||{}) }],
           };
         } else {
           // ìŠ¤ìº”/ì´ë¯¸ì§€í˜• PDF ë“± í…ìŠ¤íŠ¸ê°€ ì—†ìœ¼ë©´ ì •ë°€ ì¶”ì¶œì„ 1íšŒë§Œ í•˜ë“œìº¡ìœ¼ë¡œ ì‹œë„
           extracted = await withTimeout(
             extractPartsAndSpecsFromPdf({ gcsUri, allowedKeys, brandHint: brand || null }),
             EXTRACT_HARD_CAP_MS,
             'extract',
           );
         }
       } else {
         extracted = await withTimeout(
           extractPartsAndSpecsFromPdf({ gcsUri, allowedKeys, brandHint: brand || null }),
           EXTRACT_HARD_CAP_MS,
           'extract',
         );
       }
     } catch (e) { console.warn('[extract timeout/fail]', e?.message || e); }
   }
 
+  // ğŸ”¹ ì´ ë³€ìˆ˜ê°€ "ë°ì´í„°ì‹œíŠ¸ ë¶„ì„ì—ì„œ ë°”ë¡œ ë½‘ì€ MPN ë¦¬ìŠ¤íŠ¸"ê°€ ë¨
   let codes = [];
   if (!code) {
     const skuFromTable = pickSkuListFromTables(extracted);
     codes = skuFromTable.length ? skuFromTable : expandFromCodeSystem(extracted, blueprint);
     const maxEnv = Number(process.env.FIRST_PASS_CODES || FIRST_PASS_CODES || 20);
     const maxCodes = Number.isFinite(maxEnv) && maxEnv > 0 ? maxEnv : 20;
     if (codes.length > maxCodes) codes = codes.slice(0, maxCodes);
   }
 
+  // ğŸ”¹ í›„ë³´(candidates)ê°€ ì•„ì§ ë¹„ì—ˆê³ , ë°©ê¸ˆ ìˆ˜ì§‘í•œ codesê°€ ìˆìœ¼ë©´ candidatesë¡œ ìŠ¹ê²©
   if (!candidates.length && codes.length) {
     const merged = [];
     const seen = new Set();
     for (const raw of codes) {
       const trimmed = typeof raw === 'string' ? raw.trim() : String(raw || '');
       if (!trimmed) continue;
       const norm = normalizeCode(trimmed);
       if (seen.has(norm)) continue;
       seen.add(norm);
       merged.push(trimmed);
     }
     if (merged.length) candidates = merged;
   }
 
+  // ğŸ”¹ â€œì• ì´ˆì— ë¶„ì„ë‹¨ê³„ì—ì„œ ì—¬ëŸ¬ MPNì„ ë¦¬ìŠ¤íŠ¸ì—…â€ â€” ì¶”ì¶œ ê²°ê³¼ì— ëª…ì‹œì ìœ¼ë¡œ ë¶€ì°©
+  if (extracted && typeof extracted === 'object') {
+    const list = (Array.isArray(codes) ? codes : []).filter(Boolean);
+    extracted.codes = list;        // <- ìµœì¢… MPN ë°°ì—´
+    extracted.mpn_list = list;     // <- ë™ì˜ì–´(ì™¸ë¶€ì—ì„œ ì“°ê¸° ì‰½ë„ë¡)
+  }
+
   if (!code && !codes.length) {
     let fullText = '';
     try { fullText = await readText(gcsUri, 300 * 1024) || ''; } catch {}
 
     const fromTypes  = extractPartNumbersFromTypesTables(fullText, FIRST_PASS_CODES * 4); // TYPES í‘œ ìš°ì„ 
     const fromOrder  = rankPartNumbersFromOrderingSections(fullText, FIRST_PASS_CODES);
     const fromSeries = extractPartNumbersBySeriesHeuristic(fullText, FIRST_PASS_CODES * 4);
     // ê°€ì¥ ì‹ ë¢° ë†’ì€ ìˆœì„œë¡œ ë³‘í•©
     const picks = fromTypes.length ? fromTypes : (fromOrder.length ? fromOrder : fromSeries);
 
     if (!candidates.length && picks.length) {
       const merged = [];
       const seen = new Set();
       for (const p of picks) {
         const raw = typeof p === 'string' ? p : p?.code;
         const trimmed = typeof raw === 'string' ? raw.trim() : '';
         if (!trimmed) continue;
         const norm = normalizeCode(trimmed);
         if (seen.has(norm)) continue;
         seen.add(norm);
         merged.push(trimmed);
       }
-      if (merged.length) candidates = merged;
+      if (merged.length) {
+        candidates = merged;
+        // ğŸ”¹ types/order/series íœ´ë¦¬ìŠ¤í‹±ìœ¼ë¡œë„ ì°¾ì€ ê²½ìš°, ì´ê²ƒë„ ì¶”ì¶œ ê²°ê³¼ì— ë°˜ì˜
+        if (extracted && typeof extracted === 'object') {
+          const uniq = Array.from(new Set([...(extracted.codes || []), ...merged]));
+          extracted.codes = uniq;
+          extracted.mpn_list = uniq;
+        }
+      }
     }
 
     // ë¶„í•  ì—¬ë¶€ëŠ” ë³„ë„ íŒë‹¨. ì—¬ê¸°ì„œëŠ” í›„ë³´ë§Œ ëª¨ì•„ë‘ .
     // extracted.rowsëŠ” ê±´ë“œë¦¬ì§€ ì•ŠìŒ.
   }
 
 
   // ì»¤ë²„ ì¶”ì¶œ ë¹„í™œì„±(ìš”ì²­ì— ë”°ë¼ ì™„ì „ OFF)
   let coverUri = null;
   if (/^(1|true|on)$/i.test(process.env.COVER_CAPTURE || '0')) {
     try {
       const bForCover = brand || extracted.brand || 'unknown';
       const cForCover = code || extracted.rows?.[0]?.code || path.parse(fileName).name;
       coverUri = await withTimeout(
         extractCoverToGcs(gcsUri, { family, brand: bForCover, code: cForCover }),
         Math.min(30000, Math.round(BUDGET * 0.15)),
         'cover',
       );
     } catch (e) { console.warn('[cover fail]', e?.message || e); }
   }
 
   if (code) {
     const trimmedCode = String(code || '').trim();
     if (trimmedCode) {
       const norm = normalizeCode(trimmedCode);
diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index 72484a18a028be92eb46f1a0cc4377890c53ff28..dd1825fc963f8b46c906fa2197e17be1562297a0 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -826,29 +843,32 @@ async function runAutoIngest({
     for (const [k,v] of Object.entries(rec)) {
       const kk = String(k || '').toLowerCase();
       if (BASE_KEYS.has(kk)) continue;
       if (!colsSet.has(kk)) continue;
       if (META_KEYS.has(kk)) continue;
       safe[kk] = v;
     }
     if (colsSet.has('updated_at')) safe.updated_at = now;
 
     // â† ì—…ì„œíŠ¸ ì „ì— ìˆ«ì/ì •ìˆ˜/ë¶ˆë¦¬ì–¸ ì»¬ëŸ¼ì„ íƒ€ì…ì— ë§ì¶° ì •ë¦¬(ì‹¤íŒ¨ í‚¤ëŠ” ì‚­ì œ)
     sanitizeByColTypes(safe, colTypes);
     await upsertByBrandCode(table, normalizeKeysOnce(safe));
     upserted++;
   }
 
   return {
     ok: true,
     ms: Date.now() - started,
     family,
     final_table: table,
     brand: records[0]?.brand,
     code:  records[0]?.code,
     datasheet_uri: gcsUri,
     cover: records[0]?.image_uri || null,
     rows: upserted,
+    // ğŸ”¹ í˜¸ì¶œìê°€ â€œì´ë²ˆ PDFì—ì„œ ë½‘íŒ ëª¨ë“  MPN ë¦¬ìŠ¤íŠ¸â€ë¥¼ ë°”ë¡œ í™•ì¸ ê°€ëŠ¥
+    codes: Array.isArray(extracted?.codes) ? extracted.codes : [],
+    mpn_list: Array.isArray(extracted?.mpn_list) ? extracted.mpn_list : [],
   };
 }
 
 module.exports = { runAutoIngest };
