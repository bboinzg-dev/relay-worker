diff --git a/src/utils/mpn-exploder.js b/src/utils/mpn-exploder.js
index 6cba330109364746c7515ebf64f3f89bf53be149..895bcffbbb10edcbdab4a77c1a1ed716bcfeb613 100644
--- a/src/utils/mpn-exploder.js
+++ b/src/utils/mpn-exploder.js
@@ -1,68 +1,82 @@
 'use strict';
 
 const LIST_SEP = /[\s,;/|·•]+/;
-const CONTACT_FORM_PATTERNS = [
-  { regex: /(1\s*form\s*a|1a|spst-?no)/i, value: '1A' },
-  { regex: /(2\s*form\s*a|2a|dpst-?no)/i, value: '2A' },
-];
-const CONTACT_FORM_ALLOWED = new Set(['1A', '2A']);
+// 패턴리스 정규화기: 1A/1B/1C/2A/2B/2C/1A1B/2AB 등 조합 처리
+function normalizeContactForm(value) {
+  if (value == null) return null;
+  const raw = Array.isArray(value) ? value[0] : value;
+  if (raw == null) return null;
+  let s = String(raw).normalize('NFKC').toLowerCase();
+  if (!s.trim()) return null;
+  s = s.replace(/[\s\-_]/g, '');
+  // 동의어 치환
+  s = s
+    .replace(/spstnc/g, '1b')
+    .replace(/spst(no)?/g, '1a')
+    .replace(/dpst(no)?/g, '2a')
+    .replace(/spdt/g, '1c')
+    .replace(/dpdt/g, '2c')
+    .replace(/form/g, '');
+  // (\d+)?[abc]+ 블록들을 누적 카운트
+  let a = 0;
+  let b = 0;
+  let c = 0;
+  const re = /(\d+)?([abc]+)/g;
+  let m;
+  while ((m = re.exec(s)) !== null) {
+    const n = m[1] ? parseInt(m[1], 10) : 1;
+    const letters = m[2];
+    if (letters.includes('c')) c += n;
+    if (letters.includes('a')) a += n;
+    if (letters.includes('b')) b += n;
+  }
+  if (!a && !b && !c) return null;
+  if (c > 0) return `${c}C`;
+  if (a > 0 && b > 0) return `${a}A${b}B`;
+  if (a > 0) return `${a}A`;
+  return `${b}B`;
+}
 const SERIES_STRIP_WORDS = /\b(relays?|series|relay|power|signal)\b/gi;
 const NON_MPN_WORDS = new Set([
   'relay', 'relays', 'coil', 'vdc', 'vac', 'form', 'series', 'typ', 'max', 'min'
 ]);
 
 function normalizeSeriesCode(value) {
   if (value == null) return null;
   const raw = Array.isArray(value) ? value[0] : value;
   if (raw == null) return null;
   const str = String(raw).trim();
   if (!str) return null;
   const cleaned = str
     .replace(SERIES_STRIP_WORDS, '')
     .replace(/\s+/g, '')
     .trim();
   const upper = cleaned.toUpperCase();
   return upper || null;
 }
 
-function normalizeContactForm(value) {
-  if (value == null) return null;
-  const raw = Array.isArray(value) ? value[0] : value;
-  if (raw == null) return null;
-  const str = String(raw).trim();
-  if (!str) return null;
-  for (const { regex, value: mapped } of CONTACT_FORM_PATTERNS) {
-    if (regex.test(str)) return mapped;
-  }
-  const compact = str.replace(/\s+/g, '').toUpperCase();
-  if (CONTACT_FORM_ALLOWED.has(compact)) return compact;
-  if (compact === 'SPST' || compact === 'SPSTNO') return '1A';
-  if (compact === 'DPST' || compact === 'DPSTNO') return '2A';
-  return null;
-}
-
 function normalizeCoilVoltage(value) {
   if (value == null) return null;
   const raw = Array.isArray(value) ? value[0] : value;
   if (raw == null) return null;
   const str = String(raw).trim();
   if (!str) return null;
   const digits = str.match(/\d+/g);
   if (!digits || !digits.length) return null;
   const joined = digits.join('');
   if (!joined) return null;
   return joined;
 }
 
 function isLikelyPn(value) {
   if (value == null) return false;
   const str = String(value).trim();
   if (!str) return false;
   return /^[A-Z]{1,4}[A-Z0-9\-_/]{2,}$/i.test(str);
 }
 
 function derivePrefix(token) {
   if (!token) return '';
   const trimmed = token.trim();
   if (!trimmed) return '';
 
@@ -228,122 +242,119 @@ function explodeToRows(base, options = {}) {
     const fromExact = values[key];
     if (fromExact != null) {
       const normed = normalizeList(fromExact);
       return normed.length ? normed : [fromExact];
     }
     const lower = key.toLowerCase();
     if (values[lower] != null) {
       const normed = normalizeList(values[lower]);
       return normed.length ? normed : [values[lower]];
     }
     return [null];
   });
 
   const combos = lists.length ? cartesian(lists) : [[]];
   const mpnCandidates = collectMpnSeeds(base);
 
   const rows = [];
   combos.forEach((combo, idx) => {
     const rowValues = { ...values };
     variantKeys.forEach((key, keyIdx) => {
       const val = combo[keyIdx];
       if (val == null || val === '') return;
       assignValue(rowValues, key, val);
     });
 
-        const normalizedSeries = normalizeSeriesCode(
+    const normalizedSeries = normalizeSeriesCode(
       rowValues.series_code
         ?? rowValues.series
         ?? base?.series_code
         ?? base?.series
         ?? null,
     );
     if (normalizedSeries) {
       assignValue(rowValues, 'series_code', normalizedSeries);
       if (rowValues.series == null) assignValue(rowValues, 'series', normalizedSeries);
     }
 
     const normalizedContactForm = normalizeContactForm(
       rowValues.contact_form
         ?? rowValues.contact_arrangement
         ?? rowValues.form
         ?? null,
     );
     if (normalizedContactForm) assignValue(rowValues, 'contact_form', normalizedContactForm);
     else {
       delete rowValues.contact_form;
       delete rowValues.contactform;
     }
 
     const normalizedCoilVoltage = normalizeCoilVoltage(rowValues.coil_voltage_vdc);
     if (normalizedCoilVoltage) assignValue(rowValues, 'coil_voltage_vdc', normalizedCoilVoltage);
     else {
       delete rowValues.coil_voltage_vdc;
       delete rowValues.coil_voltagevdc;
     }
 
-    const canUseTemplate = pnTemplate
-      && normalizedSeries
-      && normalizedContactForm
-      && CONTACT_FORM_ALLOWED.has(normalizedContactForm)
-      && normalizedCoilVoltage;
+    const canUseTemplate = pnTemplate && normalizedSeries && normalizedCoilVoltage;
 
     let generatedByTemplate = false;
     let generatedByFallback = false;
     let code = null;
 
     if (pnTemplate) {
-            if (!canUseTemplate) return;
+      if (!canUseTemplate) return;
       code = renderTemplate(pnTemplate, {
         ...rowValues,
         series: normalizedSeries,
         series_code: normalizedSeries,
         contact_form: normalizedContactForm,
         coil_voltage_vdc: normalizedCoilVoltage,
       });
-            generatedByTemplate = true;
+      generatedByTemplate = true;
     } else if (mpnCandidates[idx]) {
       code = mpnCandidates[idx];
     } else if (mpnCandidates.length) {
       code = mpnCandidates[0];
     } else {
       const parts = [];
       if (normalizedSeries) parts.push(normalizedSeries);
       else if (base?.series) parts.push(base.series);
       else if (base?.series_code) parts.push(base.series_code);
       const suffix = variantKeys
         .map((key) => rowValues[key] ?? rowValues[key?.toLowerCase()])
         .filter((v) => v != null && v !== '')
         .map((v) => String(v))
         .join('');
       if (suffix) parts.push(suffix);
       code = parts.join('');
-            generatedByFallback = true;
+      generatedByFallback = true;
     }
 
     code = String(code || '').trim();
     if (!code) return;
 
-        if ((generatedByTemplate || generatedByFallback) && !isLikelyPn(code)) return;
+    if ((generatedByTemplate || generatedByFallback) && !isLikelyPn(code)) return;
 
     const codeNorm = code.toLowerCase();
     if (rows.some((r) => r.code_norm === codeNorm)) return;
 
     rows.push({
       code,
       code_norm: codeNorm,
       values: rowValues,
     });
   });
 
   return rows;
 }
 
 module.exports = {
   LIST_SEP,
   NON_MPN_WORDS,
   splitAndCarryPrefix,
   normalizeList,
   cartesian,
   renderTemplate,
   explodeToRows,
-};
\ No newline at end of file
+  normalizeContactForm,
+};