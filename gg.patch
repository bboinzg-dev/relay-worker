diff --git a/src/services/vertex.js b/src/services/vertex.js
index 80a7a1d8a495b0f7f1975b04c3f16b2df98c2273..40c2f36a5d7b8efa027a27c26a9374eadb55869d 100644
--- a/src/services/vertex.js
+++ b/src/services/vertex.js
@@ -74,92 +74,103 @@ function safeParseJson(text) {
     return JSON.parse(stripped);
   } catch (_) {}
 
   let depth = 0;
   let start = -1;
   for (let i = 0; i < stripped.length; i += 1) {
     const ch = stripped[i];
     if (ch === '{') {
       if (depth === 0) start = i;
       depth += 1;
     } else if (ch === '}') {
       depth -= 1;
       if (depth === 0 && start >= 0) {
         const slice = stripped.slice(start, i + 1);
         try {
           return JSON.parse(slice);
         } catch (_) {}
         start = -1;
       }
     }
   }
 
   return null;
 }
 
+function extractCandidateJson(response) {
+  const parts = Array.isArray(response?.response?.candidates?.[0]?.content?.parts)
+    ? response.response.candidates[0].content.parts
+    : [];
+  const text = parts
+    .map((part) => (typeof part?.text === 'string' ? part.text : ''))
+    .join('');
+  if (!text || !text.trim()) {
+    return { text: '', data: null };
+  }
+  return { text, data: safeParseJson(text) };
+}
+
 async function classifyByGcs(gcsUri, filename = 'datasheet.pdf') {
   const fams = await getFamilies();
   const prompt = [
     `PDF 전체를 읽고 {"family_slug","brand","code","series"} JSON만 반환. 파일명: ${filename}`,
     `- family_slug는 반드시 다음 중 하나: ${fams.map((f) => `"${f}"`).join(', ')}`,
   ].join('\n');
   const resp = await callGemini({
     modelName: MODEL_CLASSIFY,
     contents: [
       {
         role: 'user',
         parts: [
           { fileData: { fileUri: gcsUri, mimeType: 'application/pdf' } },
           { text: prompt },
         ],
       },
     ],
     generationConfig: { responseMimeType: 'application/json' },
   });
-  const parts = resp.response?.candidates?.[0]?.content?.parts ?? [];
-  const text = parts.map((p) => p.text || '').join('');
+  const { text, data } = extractCandidateJson(resp);
   if (!text) return {};
-  const parsed = safeParseJson(text);
+  const parsed = data;
   if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {
     return parsed;
   }
   if (text) {
     console.warn('[vertex] classify parse failed: invalid JSON payload');
   }
   return {};
 }
 
 async function extractValuesByGcs(gcsUri, family) {
   const fields = await getFields(family);
   const prompt = [
     `다음 PDF에서 ${family} 부품의 스펙을 추출합니다.`,
     '아래 DB 컬럼만 채우고 없으면 null.',
     '반드시 {"values":{ "<컬럼명>": 값 }} 만 출력.',
     `columns: ${JSON.stringify(fields)}`,
   ].join('\n');
   const resp = await callGemini({
     modelName: MODEL_EXTRACT,
     contents: [
       {
         role: 'user',
         parts: [
           { text: prompt },
           { fileData: { fileUri: gcsUri, mimeType: 'application/pdf' } },
         ],
       },
     ],
     generationConfig: { responseMimeType: 'application/json' },
   });
-  const parts = resp.response?.candidates?.[0]?.content?.parts ?? [];
-  const raw = parts.map((p) => p.text || '').join('');
+  const { text: raw, data } = extractCandidateJson(resp);
   if (!raw) return {};
-  const parsed = safeParseJson(raw);
+  const parsed = data;
   if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {
     return parsed.values || {};
   }
   if (raw) {
     console.warn('[vertex] extract parse failed: invalid JSON payload');
   }
   return {};
 }
 
 module.exports = { classifyByGcs, extractValuesByGcs, safeParseJson };
\ No newline at end of file