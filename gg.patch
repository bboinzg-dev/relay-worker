diff --git a/src/ai/datasheetExtract.js b/src/ai/datasheetExtract.js
index 8887cd09bcd0907e343cd8aa28615e0d87f827b6..13bdd3a44f0e5de3edeeaed0b381922bccbee73a 100644
--- a/src/ai/datasheetExtract.js
+++ b/src/ai/datasheetExtract.js
@@ -637,67 +637,86 @@ async function geminiMapValues({ family, brandHint, codes, allowedKeys, docText,
    }
    return out; 
 }
 
 /* -------------------- Public: main extractor -------------------- */
 async function extractPartsAndSpecsFromPdf({ gcsUri, allowedKeys, family = null, brandHint = null }) {
   const rowAllowedKeySet = new Set();
   const rowAllowedKeys = [];
   const ensureAllowedKey = (value) => {
     const str = value == null ? '' : String(value).trim();
     if (!str) return;
     const lower = str.toLowerCase();
     if (rowAllowedKeySet.has(lower)) return;
     rowAllowedKeySet.add(lower);
     rowAllowedKeys.push(str);
   };
 
   if (Array.isArray(allowedKeys)) {
     for (const key of allowedKeys) ensureAllowedKey(key);
   }
   ensureAllowedKey('series');
   ensureAllowedKey('series_code');
   ensureAllowedKey('pn_jp');
   ensureAllowedKey('pn_aliases');
   ensureAllowedKey('ordering_market');
-    if ((family || '').toLowerCase().includes('capacitor')) {
+
+  const familyLower = String(family || '').trim().toLowerCase();
+
+  if (familyLower.includes('capacitor')) {
     [
       'capacitance_uf',
       'rated_voltage_v',
       'esr_mohm',
       'df_percent',
       'dcl_ua',
       'case_size_code',
       'product_category',
       'msl',
       'rms_current_100khz_45c',
       'rms_current_100khz_85c',
       'rms_current_100khz_105c',
       'rms_current_100khz_125c',
     ].forEach(ensureAllowedKey);
   }
 
+  if (familyLower.startsWith('relay')) {
+    [
+      'contact_rating_text',
+      'dielectric_strength_v',
+      'operate_time_ms',
+      'release_time_ms',
+      'coil_resistance_ohm',
+      'insulation_resistance_mohm',
+      'length_mm',
+      'width_mm',
+      'height_mm',
+      'mount_type',
+      'packing_style',
+    ].forEach(ensureAllowedKey);
+  }
+
   const promptAllowedKeys = Array.from(new Set([
     ...rowAllowedKeys,
   ]));
 
   let docai = await processWithDocAI(gcsUri);
   let fullText = docai?.fullText || '';
   if (!fullText) fullText = await parseTextWithPdfParse(gcsUri);
 
   const tableList = Array.isArray(docai?.tables) ? docai.tables : [];
   const typePartMap = extractTypePartPairs(tableList);
 
   const brand = brandHint || (await detectBrandFromText(fullText)) || 'unknown';
   const orderingInfo = extractOrderingInfo(fullText, MAX_PARTS);
 
   // 코드 후보
   let codes = [];
   if (tableList.length) codes = codesFromDocAiTables(tableList);
   if (!codes.length && fullText) codes = codesFromFreeText(fullText);
   const pnRegex = buildPnRegexFromExamples(codes.slice(0, MAX_PARTS));
 
   // 표 프리뷰(LLM 컨텍스트)
   let tablePreview = '';
   let perCodePreviewMap = new Map();
   const baseSegments = [];
   if (tableList.length) {
@@ -917,59 +936,62 @@ async function extractPartsAndSpecsFromPdf({ gcsUri, allowedKeys, family = null,
       normalizeVariantDomainMap(recipe?.variant_domains),
     );
     if (!pnTemplate && typeof recipe?.pn_template === 'string' && recipe.pn_template.trim()) {
       pnTemplate = recipe.pn_template.trim();
     }
   } catch (err) {
     console.warn('[ordering] extractOrderingRecipe failed:', err?.message || err);
   }
 
   const variantKeys = Object.keys(orderingDomains)
     .map((key) => String(key || '').trim())
     .filter(Boolean);
   if (variantKeys.length) {
     for (const key of variantKeys) ensureAllowedKey(key);
     const baseSeries = orderingDomains.series_code?.[0] || orderingDomains.series?.[0] || null;
     const orderingBase = {
       brand,
       series: baseSeries,
       series_code: baseSeries,
       values: orderingDomains,
     };
     const generatedRows = explodeToRows(orderingBase, { variantKeys, pnTemplate }) || [];
     const beforeCount = out.length;
     for (const generated of generatedRows) {
       if (!generated || typeof generated !== 'object') continue;
+      const rawCode = generated.code;
+      const codeStr = String(rawCode || '').trim();
+      if (!codeStr) continue;
       // 테이블 예시로 학습한 PN-정규식에 안 맞으면 버림
-      if (pnRegex && !pnRegex.test(String(generated.code || ''))) continue;
-      const codeNorm = String(generated.code || '').trim().toUpperCase();
+      if (pnRegex && !pnRegex.test(codeStr)) continue;
+      const codeNorm = codeStr.toUpperCase();
       const values = generated.values && typeof generated.values === 'object' ? generated.values : {};
-      const v = hasDocEvidence(normalizeCodeKey(generated.code)) || hasOrderingEvidence(generated.code);
+      const v = hasDocEvidence(normalizeCodeKey(codeStr)) || hasOrderingEvidence(codeStr);
       if (values && typeof values === 'object' && !Object.prototype.hasOwnProperty.call(values, '_pn_template')) {
         values._pn_template = pnTemplate || null;
       }
-      pushRow({ code: generated.code, values, brand, verified: v });
+      pushRow({ code: codeStr, values, brand, verified: v });
     }
     orderingExpanded = out.length > beforeCount;
   }
 
   if (!out.length) {
     for (const c of seedCodes) {
       pushRow({ code: c, values: {}, brand, verified: hasDocEvidenceValue(c) });
     }
   }
 
   const codeList = mergedCodes.slice(0, MAX_PARTS);
   const uniqueRowCodes = new Set();
   for (const row of out) {
     if (!row || typeof row !== 'object') continue;
     const code = String(row.code || row.pn || '').trim().toUpperCase();
     if (code) uniqueRowCodes.add(code);
   }
   const uniqueCandidateCodes = new Set(codeList.map((c) => String(c || '').trim().toUpperCase()).filter(Boolean));
   let docType = 'single';
   if (orderingInfo || orderingExpanded || orderingHint) docType = 'ordering';
   else if (uniqueRowCodes.size > 1 || uniqueCandidateCodes.size > 1) docType = 'catalog';
 
   return {
     brand,
     rows: out.slice(0, MAX_PARTS),