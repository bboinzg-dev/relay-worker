diff --git a/src/pipeline/persist.js b/src/pipeline/persist.js
index b75a0332f1b5c725fb4f91fc43a03b34a8a2ea33..4e31c6cf98e1c20e71ca391994758a70a97f445a 100644
--- a/src/pipeline/persist.js
+++ b/src/pipeline/persist.js
@@ -397,51 +397,64 @@ async function saveExtractedSpecs(targetTable, familySlug, rows = [], options =
   const updateCols = colList.filter((col) => !CONFLICT_KEYS.includes(col));
   const updateSql = updateCols.length
     ? updateCols.map((col) => `"${col}" = EXCLUDED."${col}"`).join(', ')
     : null;
 
   const sql = [
     `INSERT INTO ${targetTable} (${colList.map((c) => `"${c}"`).join(',')})`,
     `VALUES (${placeholders})`,
     'ON CONFLICT (brand_norm, code_norm)',
     updateSql ? `DO UPDATE SET ${updateSql}` : 'DO NOTHING',
     'RETURNING pn',
   ].join('\n');
 
   const client = await pool.connect();
   const warnings = new Set();
   const seenNatural = new Set();
 
   try {
     for (const row of rows) {
       result.processed += 1;
       const rec = {};
       for (const [key, value] of Object.entries(row || {})) {
         rec[normKey(key)] = value;
       }
 
-      const brandInfo = normalizeBrandValue(rec.brand ?? rec.brand_norm ?? '', aliasMap);
+      if ((!rec.brand || String(rec.brand).trim() === '') && options?.brand) {
+        rec.brand = options.brand;
+      }
+
+      let brandInfo = normalizeBrandValue(rec.brand ?? rec.brand_norm ?? '', aliasMap);
+      if (!brandInfo.ok && options?.brand) {
+        brandInfo = normalizeBrandValue(options.brand, aliasMap);
+      }
+      if (!brandInfo.ok) {
+        const fallbackBrand = String(rec.brand || options?.brand || '').trim();
+        if (fallbackBrand) {
+          brandInfo = { ok: true, brand: fallbackBrand, brandNorm: fallbackBrand.toLowerCase() };
+        }
+      }
       if (!brandInfo.ok) {
         if (brandInfo.reason === 'brand_not_allowed' && brandInfo.detail) {
           console.warn('[persist] brand alias not found:', brandInfo.detail);
         }
         result.skipped.push({ reason: brandInfo.reason, detail: brandInfo.detail || null });
         continue;
       }
       rec.brand = brandInfo.brand;
       rec.brand_norm = brandInfo.brandNorm;
 
       buildPnIfMissing(rec, pnTemplate);
 
       let codeValue = rec.code ?? rec.pn ?? null;
       if (typeof codeValue === 'string') codeValue = codeValue.trim();
       else codeValue = codeValue == null ? '' : String(codeValue).trim();
       if (!codeValue) {
         result.skipped.push({ reason: 'missing_code' });
         continue;
       }
       if (/^[0-9A-F]{12,}$/i.test(codeValue)) {
         result.skipped.push({ reason: 'invalid_code' });
         continue;
       }
       if (!CODE_PATTERN.test(codeValue) || CODE_FORBIDDEN_RE.test(codeValue)) {
         result.skipped.push({ reason: 'invalid_code' });
