diff --git a/src/ai/datasheetExtract.js b/src/ai/datasheetExtract.js
index 064d8918fee68715ef70d5e266a48865ecc3da34..84f7d49480c2e5a3f15cb0354abef7a7279a95c9 100644
--- a/src/ai/datasheetExtract.js
+++ b/src/ai/datasheetExtract.js
@@ -1,47 +1,49 @@
 'use strict';
 
 /**
  * PDF → { brand, rows: [{ code, verified_in_doc, ...values }] }
  * - 전 패밀리 공용. 블루프린트(allowedKeys)로 values 키 제한.
  * - DocAI(Form Parser) 우선(표/텍스트 확보) → 실패 시 pdf-parse 폴백.
  * - 표의 Part No/Type/Model/Ordering Code에서 실제 PN 우선 수집.
  * - Ordering 정보는 조합 폭 과다 방지. 자유텍스트는 보조(regex).
  * - Gemini 2.5 Flash로 블루프린트 키에 맞춰 values만 채움(엄격 JSON).
  */
 
 const { Storage } = require('@google-cloud/storage');
 const storage = new Storage();
 
 let DocumentProcessorServiceClient, VertexAI, pdfParse;
 try { DocumentProcessorServiceClient = require('@google-cloud/documentai').v1.DocumentProcessorServiceClient; } catch {}
 try { VertexAI = require('@google-cloud/vertexai').VertexAI; } catch {}
 try { pdfParse = require('pdf-parse'); } catch {}
 
 const db = require('../../db');
 const { parseGcsUri } = require('../utils/gcs');
 const { safeJsonParse } = require('../utils/safe-json');
+const { explodeToRows } = require('../utils/mpn-exploder');
+const { extractOrderingRecipe } = require('../utils/vertex');
 const { extractOrderingInfo } = require('../utils/ordering-sections');
 
 const MAX_PARTS = Number(process.env.MAX_ENUM_PARTS || 200);
 
 /* -------------------- ENV helpers -------------------- */
 function resolveDocAI() {
   const projectId =
     process.env.DOCAI_PROJECT_ID ||
     process.env.DOC_AI_PROJECT_ID ||
     process.env.GCP_PROJECT_ID ||
     process.env.GOOGLE_CLOUD_PROJECT;
 
   const location =
     process.env.DOCAI_LOCATION ||
     process.env.DOC_AI_LOCATION ||
     'us';
 
   const processorId =
     process.env.DOCAI_PROCESSOR_ID ||
     process.env.DOC_AI_PROCESSOR_ID;
 
   return { projectId, location, processorId };
 }
 
 function resolveGemini() {
@@ -245,142 +247,261 @@ function codesFromDocAiTables(tables) {
       heuristicCols.forEach((colIdx) => {
         const cell = row[colIdx];
         if (cell == null) return;
         const text = String(cell).trim();
         if (!text) return;
         for (const code of extractCodesFromCell(text)) set.add(code);
       });
     });
   }
   return Array.from(set);
 }
 function codesFromFreeText(txt) {
   const set = new Set();
   const re = /\b([A-Z0-9][A-Z0-9\-_/\.]{2,})\b/g;
   let m; while ((m = re.exec(txt)) !== null) {
     const cand = m[1].toUpperCase();
     if (looksLikeCode(cand)) set.add(cand);
     if (set.size > MAX_PARTS) break;
   }
   return Array.from(set);
 }
 
 /* -------------------- Gemini mapping -------------------- */
 async function geminiMapValues({ family, brandHint, codes, allowedKeys, docText, tablePreview }) {
   const { project, location, model } = resolveGemini();
-  if (!VertexAI || !project) return [];
+  if (!VertexAI || !project) return {};
 
   const vertex = new VertexAI({ project, location });
   const mdl = vertex.getGenerativeModel({
     model,
     systemInstruction: { parts: [{ text: [
       `You extract component specs from datasheets.`,
       `Category (family): "${family}".`,
       `Return ONLY strict JSON. Schema: {"parts":[{"brand":"string","code":"string","values":{...}}]}.`,
       `Allowed "values" keys: ${allowedKeys.join(', ') || '(none)'}. Do not invent keys.`,
       `Only include codes from the provided list (do not fabricate).`,
       `Normalize numbers to plain numbers (no units). Omit missing.`
     ].join('\n') }] }
   });
 
   const userText = [
     brandHint ? `brand_hint: ${brandHint}` : '',
     `codes: ${codes.join(', ')}`,
     tablePreview ? `TABLES:\n${tablePreview}` : '',
     `TEXT:\n${(docText || '').slice(0, 200000)}`
   ].filter(Boolean).join('\n\n');
 
   const resp = await mdl.generateContent({
     contents: [{ role: 'user', parts: [{ text: userText }]}],
     generationConfig: {
       temperature: 0.2,
       topP: 0.8,
       responseMimeType: 'application/json',
       maxOutputTokens: 8192,
     },
   });
 
-  let txt = resp?.response?.candidates?.[0]?.content?.parts?.[0]?.text || '{}';
+  const txt = resp?.response?.candidates?.[0]?.content?.parts?.[0]?.text || '{}';
+  let parsed = {};
   try {
-    const parsed = safeJsonParse(txt);
-    return Array.isArray(parsed?.parts) ? parsed.parts : [];
+    parsed = safeJsonParse(txt) || {};
   } catch {
-    return [];
+    parsed = {};
   }
+
+  const parts = Array.isArray(parsed?.parts) ? parsed.parts : [];
+  const tableHint = typeof parsed?.table_hint === 'string' ? parsed.table_hint : null;
+  const pnTemplate = typeof parsed?.pn_template === 'string' && parsed.pn_template.trim()
+    ? parsed.pn_template.trim()
+    : null;
+  const variantDomains = parsed?.variant_domains && typeof parsed.variant_domains === 'object'
+    ? parsed.variant_domains
+    : null;
+
+  return { parts, table_hint: tableHint, pn_template: pnTemplate, variant_domains: variantDomains };
+}
+
+function normalizeVariantDomainMap(raw) {
+  const normalized = {};
+  if (!raw || typeof raw !== 'object') return normalized;
+  for (const [rawKey, rawValue] of Object.entries(raw)) {
+    const key = String(rawKey || '').trim();
+    if (!key) continue;
+    const values = Array.isArray(rawValue) ? rawValue : [rawValue];
+    const seen = new Set();
+    const list = [];
+    for (const candidate of values) {
+      if (candidate == null) continue;
+      const str = String(candidate).trim();
+      const marker = str.toLowerCase();
+      if (seen.has(marker)) continue;
+      seen.add(marker);
+      list.push(str);
+    }
+    if (list.length) normalized[key] = list;
+  }
+  return normalized;
+}
+
+function mergeVariantDomainMaps(primary, secondary) {
+  const out = { ...primary };
+  for (const [key, values] of Object.entries(secondary || {})) {
+    if (!out[key]) {
+      out[key] = [...values];
+      continue;
+    }
+    const seen = new Set(out[key].map((v) => v.toLowerCase()));
+    for (const value of values) {
+      const norm = value.toLowerCase();
+      if (seen.has(norm)) continue;
+      seen.add(norm);
+      out[key].push(value);
+    }
+  }
+  return out;
 }
 
 /* -------------------- Public: main extractor -------------------- */
 async function extractPartsAndSpecsFromPdf({ gcsUri, allowedKeys, family = null, brandHint = null }) {
   let docai = await processWithDocAI(gcsUri);
   let fullText = docai?.fullText || '';
   if (!fullText) fullText = await parseTextWithPdfParse(gcsUri);
 
   const brand = brandHint || (await detectBrandFromText(fullText)) || 'unknown';
   const orderingInfo = extractOrderingInfo(fullText, MAX_PARTS);
 
   // 코드 후보
   let codes = [];
   if (docai?.tables?.length) codes = codesFromDocAiTables(docai.tables);
   if (!codes.length && fullText) codes = codesFromFreeText(fullText);
 
   // 표 프리뷰(LLM 컨텍스트)
   let tablePreview = '';
   if (docai?.tables?.length) {
     tablePreview = docai.tables.slice(0, 6).map(t => {
       const head = (t.headers || []).join(' | ');
       const rows = (t.rows || []).slice(0, 40).map(r => r.join(' | ')).join('\n');
       return `HEADER: ${head}\n${rows}`;
     }).join('\n---\n');
   }
 
   // Gemini로 values 매핑(블루프린트 키만)
-  const mapped = await geminiMapValues({
+  const mappedResult = await geminiMapValues({
     family,
     brandHint: brand,
     codes: codes.slice(0, MAX_PARTS),
     allowedKeys,
     docText: fullText,
     tablePreview
   });
 
-  // 병합
+  const mappedParts = Array.isArray(mappedResult?.parts) ? mappedResult.parts : [];
+  const tableHintRaw = String(mappedResult?.table_hint || '');
+
   const out = [];
-  const seen = new Set();
-  for (const m of mapped) {
-    const code = String(m?.code || '').trim().toUpperCase();
-    if (!code || seen.has(code)) continue;
-    seen.add(code);
-    const row = { code, verified_in_doc: true };
-    if (m?.brand) row.brand = m.brand;
-    const values = m?.values || {};
-    for (const k of allowedKeys) { if (values[k] != null) row[k] = values[k]; }
+  const seenRows = new Set();
+  const mergedCodes = [];
+  const seenCodes = new Set();
+  const seedCodes = codes.slice(0, MAX_PARTS);
+
+  const pushCode = (value) => {
+    const norm = String(value || '').trim().toUpperCase();
+    if (!norm || seenCodes.has(norm)) return;
+    seenCodes.add(norm);
+    mergedCodes.push(norm);
+  };
+
+  seedCodes.forEach(pushCode);
+
+  const pushRow = ({ code, values = {}, brand: rowBrand, verified }) => {
+    const norm = String(code || '').trim().toUpperCase();
+    if (!norm || seenRows.has(norm)) return;
+    seenRows.add(norm);
+    const row = { code: norm, verified_in_doc: Boolean(verified) };
+    const brandValue = rowBrand || brand;
+    if (brandValue) row.brand = brandValue;
+    if (values && typeof values === 'object') {
+      for (const key of allowedKeys) {
+        if (values[key] != null) row[key] = values[key];
+      }
+    }
     out.push(row);
+    pushCode(norm);
+  };
+
+  for (const part of mappedParts) {
+    const partValues = part?.values && typeof part.values === 'object' ? part.values : {};
+    pushRow({ code: part?.code, values: partValues, brand: part?.brand, verified: true });
+  }
+
+  const shouldExpandOrdering = !mappedParts.length
+    || tableHintRaw.toUpperCase().includes('ORDERING');
+
+  if (shouldExpandOrdering) {
+    let orderingDomains = normalizeVariantDomainMap(mappedResult?.variant_domains);
+    let pnTemplate = typeof mappedResult?.pn_template === 'string' && mappedResult.pn_template.trim()
+      ? mappedResult.pn_template.trim()
+      : null;
+    try {
+      const recipe = await extractOrderingRecipe(gcsUri);
+      orderingDomains = mergeVariantDomainMaps(
+        orderingDomains,
+        normalizeVariantDomainMap(recipe?.variant_domains),
+      );
+      if (!pnTemplate && typeof recipe?.pn_template === 'string' && recipe.pn_template.trim()) {
+        pnTemplate = recipe.pn_template.trim();
+      }
+    } catch (err) {
+      console.warn('[ordering] extractOrderingRecipe failed:', err?.message || err);
+    }
+
+    const variantKeys = Object.keys(orderingDomains);
+    if (variantKeys.length) {
+      const baseSeries = orderingDomains.series_code?.[0] || orderingDomains.series?.[0] || null;
+      const orderingBase = {
+        brand,
+        series: baseSeries,
+        series_code: baseSeries,
+        values: orderingDomains,
+      };
+      const generatedRows = explodeToRows(orderingBase, { variantKeys, pnTemplate }) || [];
+      for (const generated of generatedRows) {
+        if (!generated || typeof generated !== 'object') continue;
+        const values = generated.values && typeof generated.values === 'object' ? generated.values : {};
+        pushRow({ code: generated.code, values, brand, verified: false });
+      }
+    }
   }
 
-  if (!out.length) for (const c of codes.slice(0, MAX_PARTS)) out.push({ code: c, verified_in_doc: true });
+  if (!out.length) {
+    for (const c of seedCodes) {
+      pushRow({ code: c, values: {}, brand, verified: true });
+    }
+  }
 
   const tableList = Array.isArray(docai?.tables) ? docai.tables : [];
-  const codeList = codes.slice(0, MAX_PARTS);
+  const codeList = mergedCodes.slice(0, MAX_PARTS);
   const uniqueRowCodes = new Set();
   for (const row of out) {
     if (!row || typeof row !== 'object') continue;
     const code = String(row.code || row.pn || '').trim().toUpperCase();
     if (code) uniqueRowCodes.add(code);
   }
   const uniqueCandidateCodes = new Set(codeList.map((c) => String(c || '').trim().toUpperCase()).filter(Boolean));
   let docType = 'single';
-  if (orderingInfo) docType = 'ordering';
+  if (orderingInfo || shouldExpandOrdering) docType = 'ordering';
   else if (uniqueRowCodes.size > 1 || uniqueCandidateCodes.size > 1) docType = 'catalog';
 
   return {
     brand,
     rows: out.slice(0, MAX_PARTS),
     text: fullText,
     tables: tableList,
     codes: codeList,
     mpn_list: codeList,
     ordering_info: orderingInfo || null,
     doc_type: docType,
   };
 }
 
 module.exports = { extractPartsAndSpecsFromPdf };