diff --git a/server.js b/server.js
index c4f1c9719770da0d6de043624745a0cfe4c1ac10..129a462e83fa583ba51128729cb16b39c963c02b 100644
--- a/server.js
+++ b/server.js
@@ -39,51 +39,50 @@ const jwt = require('jsonwebtoken');
 // 1) DB 모듈: 로드 실패해도 서버는 떠야 함
 let db;
 try {
   db = require('./db');
 } catch (err) {
   console.error('[BOOT] db load failed:', err?.message || err);
   db = { query: async () => { throw new Error('DB_UNAVAILABLE'); } };
 }
 const { getSignedUrl, canonicalDatasheetPath, canonicalCoverPath, moveObject, storage, parseGcsUri } = require('./src/utils/gcs');
 const { ensureSpecsTable, upsertByBrandCode } = require('./src/utils/schema');
 // 3) ingestAuto: 부팅 시점에 절대 로드하지 말고, 요청 시점에만 로드
 let __INGEST_MOD__ = null;
 function getIngest() {
   if (__INGEST_MOD__) return __INGEST_MOD__;
   try {
     __INGEST_MOD__ = require('./src/pipeline/ingestAuto');
   } catch (e) {
     console.error('[INGEST] module load failed:', e?.message || e);
     __INGEST_MOD__ = {
       runAutoIngest: async () => { throw new Error('INGEST_MODULE_LOAD_FAILED'); },
       persistProcessedData: async () => { throw new Error('INGEST_MODULE_LOAD_FAILED'); },
     };
   }
   return __INGEST_MOD__;
 }
-const { enqueueIngest } = require('./src/utils/enqueue');
 
 
 
 // ───────────────── Cloud Tasks (enqueue next-step) ─────────────────
 // 2) Cloud Tasks: 런타임에 없으면 비활성화
 let CloudTasksClient;
 try { ({ CloudTasksClient } = require('@google-cloud/tasks')); }
 catch (e) { console.warn('[BOOT] @google-cloud/tasks unavailable:', e?.message || e); }
 const PROJECT_ID       = process.env.GCP_PROJECT_ID || process.env.GOOGLE_CLOUD_PROJECT;
 const TASKS_LOCATION   = process.env.TASKS_LOCATION   || 'asia-northeast3';
 const QUEUE_NAME       = process.env.QUEUE_NAME       || 'ingest-queue';
 // step 라우트 폐지 → ingest 하나로 통일
 const WORKER_TASK_URL = process.env.WORKER_TASK_URL || process.env.WORKER_STEP_URL || 'https://<YOUR-RUN-URL>/api/worker/ingest';
 const TASKS_INVOKER_SA = process.env.TASKS_INVOKER_SA || '';
 
 // ⚠️ 외부 API(예: Vertex/HTTP) 가능성이 있는 부팅 태스크는 가드 안에서만 실행
 //   → 아래 부팅 IIFE 내부의  if (!EXT_CALLS_OFF)  블록으로 이동
 //try { require('./src/tasks/embedFamilies').run().catch(console.error); } catch {}
 
 // lazy init: gRPC 문제 대비 regional endpoint + REST fallback
 let _tasks = null;
 let _queuePath = null;
 function getTasks() {
   if (!_tasks) {
     if (!CloudTasksClient) throw new Error('@google-cloud/tasks unavailable');
diff --git a/server.js b/server.js
index c4f1c9719770da0d6de043624745a0cfe4c1ac10..129a462e83fa583ba51128729cb16b39c963c02b 100644
--- a/server.js
+++ b/server.js
@@ -953,51 +952,51 @@ async function handleWorkerIngest(req, res) {
 
         const overrideBrand = payload?.overrides?.brand ?? payload?.brand ?? null;
         const overrideSeries = payload?.overrides?.series ?? payload?.series ?? null;
         const nextOverrides = {
           ...(payload?.overrides || {}),
           brand: overrideBrand,
           series: overrideSeries,
         };
 
         const nextPayload = {
           runId,
           run_id: runId,
           gcsUri,
           gcs_uri: gcsUri,
           family_slug: payload?.family_slug ?? null,
           brand: payload?.brand ?? null,
           code: payload?.code ?? null,
           series: payload?.series ?? null,
           display_name: payload?.display_name ?? null,
           uploader_id: payload?.uploader_id ?? null,
           overrides: nextOverrides,
           phase: 'process',
         };
 
         try {
-          await enqueueIngest(nextPayload);
+          await enqueueIngestTask(nextPayload);
         } catch (err) {
           console.error(
             '[enqueue error]',
             err?.code || err?.response?.status || err?.message,
             err?.response?.data ? JSON.stringify(err.response.data) : (err?.details || '')
           );
           throw new Error(`enqueue failed: ${String(err?.message || err)}`);
         }
 
         return;
       }
 
       if (phase === 'process') {
         await markProcessing(baseContext);
 
         const overrideBrand = payload?.overrides?.brand ?? payload?.brand ?? null;
         const overrideSeries = payload?.overrides?.series ?? payload?.series ?? null;
         const nextOverrides = {
           ...(payload?.overrides || {}),
           brand: overrideBrand,
           series: overrideSeries,
         };
 
         const result = await getIngest().runAutoIngest({
           ...payload,
diff --git a/server.js b/server.js
index c4f1c9719770da0d6de043624745a0cfe4c1ac10..129a462e83fa583ba51128729cb16b39c963c02b 100644
--- a/server.js
+++ b/server.js
@@ -1011,51 +1010,51 @@ async function handleWorkerIngest(req, res) {
 
         const processed = result?.processed;
         if (!processed || !Array.isArray(processed.records)) {
           throw new Error('process_no_records');
         }
 
         await markRunning(baseContext);
 
         const nextPayload = {
           runId,
           run_id: runId,
           gcsUri,
           gcs_uri: gcsUri,
           family_slug: payload?.family_slug ?? null,
           brand: payload?.brand ?? null,
           code: payload?.code ?? null,
           series: payload?.series ?? null,
           display_name: payload?.display_name ?? null,
           uploader_id: payload?.uploader_id ?? null,
           phase: 'persist',
           processed,
           overrides: nextOverrides,
         };
 
         try {
-          await enqueueIngest(nextPayload);
+          await enqueueIngestTask(nextPayload);
         } catch (err) {
           console.error(
             '[enqueue error]',
             err?.code || err?.response?.status || err?.message,
             err?.response?.data ? JSON.stringify(err.response.data) : (err?.details || '')
           );
           throw new Error(`persist enqueue failed: ${String(err?.message || err)}`);
         }
         return;
       }
 
       if (phase === 'persist') {
         await markPersisting(baseContext);
 
         const overrideBrand = payload?.overrides?.brand ?? payload?.brand ?? null;
         const overrideSeries = payload?.overrides?.series ?? payload?.series ?? null;
 
         const out = await getIngest().persistProcessedData(payload?.processed || {}, {
           brand: overrideBrand,
           code: payload?.code ?? null,
           series: overrideSeries,
           display_name: payload?.display_name ?? null,
         });
 
         const failureReasons = new Set(Array.isArray(out?.reject_reasons) ? out.reject_reasons : []);
