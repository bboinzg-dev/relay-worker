diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index fb2cc30e070406c6a5d3e1f9c87f178fc38b1096..4c8ed43e5fea8ea8b5a9c2734a9717c9c08fd839 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -256,88 +256,97 @@ function normalizeSpecKeyName(value) {
   if (!s) return null;
   s = s.replace(/[–—―]/g, '-');
   s = s.replace(/\s+/g, '_');
   s = s.replace(/[^0-9a-z_]+/g, '_');
   s = s.replace(/_+/g, '_');
   s = s.replace(/^_|_$/g, '');
   if (!s) return null;
   if (s.length > 63) s = s.slice(0, 63);
   if (RESERVED_SPEC_KEYS.has(s)) return null;
   return s;
 }
 
 const ORDERING_SECTION_RE = /(ordering information|ordering info|how to order|order information|ordering code|how-to-order|\b品番\b|\b型番\b|주문|注文)/i;
 const CONTACT_LINE_RE = /(contact|arrangement|configuration|form)/i;
 const COIL_LINE_RE = /(coil|voltage|vdc)/i;
 const CONSTRUCTION_LINE_RE = /(construction|sealed|flux\s*proof|enclosure)/i;
 const INSULATION_LINE_RE = /(insulation)/i;
 const MATERIAL_LINE_RE = /(material)/i;
 const POWER_LINE_RE = /(coil\s*power|power\s*consumption|power\s*code)/i;
 
 function normalizeOrderingEnumToken(token) {
   if (token == null) return null;
   const raw = String(token).trim();
   if (!raw) return null;
   if (/^(nil|blank|none|null|n\/a)$/i.test(raw)) return '';
+  // 문자 1~2자 또는 숫자 1~2자(예: Cover 1/2)
   if (/^[A-Za-z]{1,2}$/.test(raw)) return raw.toUpperCase();
+  if (/^\d{1,2}$/.test(raw)) return raw;
   return null;
 }
 
 function addOrderingDomainValue(domains, key, value) {
   if (!key) return;
   if (value == null) return;
   const arr = domains.get(key) || [];
   if (!arr.some((item) => item === value)) {
     arr.push(value);
     domains.set(key, arr);
   }
 }
 
 function extractContactValues(text) {
   if (!text) return [];
   const out = [];
   const re = /\b((?:\d{1,2}\s*[ABC])+)(?![A-Za-z])/gi;
   let m;
   while ((m = re.exec(text)) !== null) {
     const token = m[1] ? m[1].replace(/\s+/g, '').toUpperCase() : '';
     if (!token) continue;
     if (!/[ABC]/.test(token)) continue;
     out.push(token);
   }
   return out;
 }
 
 function extractCoilVoltageValues(text) {
   if (!text) return [];
   const out = [];
-  const re = /\b(\d{1,3})\s*(?:V(?:DC)?|DC)\b/gi;
+  // DC12V / AC220V / 12V / 12 V / 12 VDC / 12 DC / AC 110 / DC 24
+  const re = /\b(?:AC|DC)?\s*(\d{1,3})\s*(?:V(?:DC)?|DC)?\b/gi;
   let m;
   while ((m = re.exec(text)) !== null) {
     const num = Number.parseInt(m[1], 10);
     if (!Number.isFinite(num)) continue;
-    const normalized = `${num} V`;
-    out.push(normalized);
+    out.push(`${num} V`);
+  }
+  // "AC: 6,12,24..." 같이 단위 없는 숫자 나열도 코일/볼티지 맥락이면 허용
+  if (!out.length && /(coil|volt|ac|dc)/i.test(text)) {
+    for (const match of text.matchAll(/\b(\d{1,3})\b/g)) {
+      const n = parseInt(match[1], 10);
+      if (Number.isFinite(n)) out.push(`${n} V`);
+    }
   }
   return out;
 }
 
 function extractEnumCodeValues(text) {
   if (!text) return [];
   const out = [];
   const directRe = /(Nil|Blank|None|[A-Za-z])\s*(?=[:=（(\-])/g;
   let m;
   while ((m = directRe.exec(text)) !== null) {
     const normalized = normalizeOrderingEnumToken(m[1]);
     if (normalized == null) continue;
     out.push(normalized);
   }
   if (out.length) return out;
 
   const fragments = String(text)
     .split(/[\n,\/|•·]+/)
     .map((part) => part.replace(/[()]/g, '').trim())
     .filter(Boolean);
   for (const frag of fragments) {
     const normalized = normalizeOrderingEnumToken(frag);
     if (normalized == null) continue;
     out.push(normalized);
   }
@@ -444,50 +453,60 @@ function collectOrderingDomains({ orderingInfo, previewText, docAiText, docAiTab
           else if (key === 'coil_voltage_vdc') addMany(key, extractCoilVoltageValues(text));
           else addMany(key, extractEnumCodeValues(text));
         });
       }
     }
   }
 
   const textSources = new Set();
   gatherOrderingTexts(orderingInfo, []).forEach((txt) => textSources.add(txt));
   if (typeof docAiText === 'string' && docAiText.trim()) textSources.add(docAiText);
   if (typeof previewText === 'string' && previewText.trim()) textSources.add(previewText);
 
   for (const rawText of textSources) {
     const sections = sliceOrderingSections(rawText);
     for (const section of sections) {
       const lines = section.split(/\n+/);
       for (const rawLine of lines) {
         const line = rawLine.replace(/^[\s•·\-–—]+/, '').trim();
         if (!line) continue;
         if (CONTACT_LINE_RE.test(line)) addMany('contact_arrangement', extractContactValues(line));
         if (COIL_LINE_RE.test(line)) addMany('coil_voltage_vdc', extractCoilVoltageValues(line));
         if (CONSTRUCTION_LINE_RE.test(line)) addMany('construction', extractEnumCodeValues(line));
         if (INSULATION_LINE_RE.test(line)) addMany('insulation_code', extractEnumCodeValues(line));
         if (MATERIAL_LINE_RE.test(line)) addMany('material_code', extractEnumCodeValues(line));
         if (POWER_LINE_RE.test(line)) addMany('coil_power_code', extractEnumCodeValues(line));
+        // 자주 나오는 일반 패턴들
+        if (/led/i.test(line)) addMany('led_code', extractEnumCodeValues(line)); // "L: With LED, Nil: W/O LED"
+        if (/cover/i.test(line)) {
+          const modes = Array.from(line.matchAll(/\b([12])\b/g)).map((m) => m[1]);
+          if (modes.length) addMany('cover_mode', modes);
+        }
+        if (/(insert|pcb)/i.test(line)) {
+          const types = Array.from(line.matchAll(/\b([ab])\s*[:=]/gi)).map((m) => m[1].toLowerCase());
+          if (types.length) addMany('mount_type_code', types);
+        }
       }
     }
   }
 
   const result = {};
   for (const [key, values] of domains.entries()) {
     if (!values || !values.length) continue;
     result[key] = values;
   }
   return Object.keys(result).length ? result : null;
 }
 
 function buildTyOrderingFallback({ baseSeries, orderingInfo, previewText, docAiText }) {
   const normalizedSeries = String(baseSeries || '').trim().toUpperCase();
   if (normalizedSeries && normalizedSeries !== 'TY') return null;
 
   const textSources = new Set();
   gatherOrderingTexts(orderingInfo, []).forEach((txt) => textSources.add(txt));
   if (typeof docAiText === 'string' && docAiText.trim()) textSources.add(docAiText);
   if (typeof previewText === 'string' && previewText.trim()) textSources.add(previewText);
 
   if (!textSources.size) return null;
   const haystack = Array.from(textSources).join('\n').toUpperCase();
   if (!haystack) return null;
   if (!/(ORDERING|HOW TO ORDER|주문|注文)/.test(haystack)) return null;
@@ -560,50 +579,53 @@ function escapeRegex(str) {
 
 function textContainsExact(text, pn) {
   if (!text || !pn) return false;
   const pattern = escapeRegex(String(pn).trim());
   if (!pattern) return false;
   const re = new RegExp(`(^|[^A-Za-z0-9])${pattern}(?=$|[^A-Za-z0-9])`, 'i');
   return re.test(String(text));
 }
 
 function normLower(s){ return String(s||'').trim().toLowerCase(); }
 
 function isValidCode(s) {
   const v = String(s || '').trim();
   if (!v) return false;
   if (v.length < 2 || v.length > 64) return false;
   if (!/[0-9A-Za-z]/.test(v)) return false;
   if (/\s{2,}/.test(v)) return false;
   if (/^pdf-?1(\.\d+)?$/i.test(v)) return false;
   return true;
 }
 
 const KEY_ALIASES = {
   form: ['form', 'contact_form', 'contact_arrangement', 'configuration', 'arrangement', 'poles_form'],
   voltage: ['voltage', 'coil_voltage_vdc', 'voltage_vdc', 'rated_voltage_vdc', 'vdc', 'coil_voltage'],
   case: ['case', 'case_code', 'package', 'pkg'],
+  led: ['led', 'led_code', 'indicator'],
+  cover: ['cover', 'cover_mode', 'cover_code'],
+  mount: ['mount', 'mount_type_code', 'insert_type', 'assembly'],
   capacitance: ['capacitance', 'capacitance_uF', 'capacitance_f', 'c'],
   resistance: ['resistance', 'resistance_ohm', 'r_ohm', 'r'],
   tolerance: ['tolerance', 'tolerance_pct'],
   length_mm: ['length_mm', 'dim_l_mm'],
   width_mm: ['width_mm', 'dim_w_mm'],
   height_mm: ['height_mm', 'dim_h_mm'],
   series: ['series', 'series_code']
 };
 
 const ENUM_MAP = {
   form: { SPST: '1A', SPDT: '1C', DPDT: '2C' }
 };
 
 function normalizeKeyName(v) {
   return String(v || '')
     .normalize('NFKC')
     .toLowerCase()
     .replace(/[^a-z0-9]+/g, '_')
     .replace(/_+/g, '_')
     .replace(/^_|_$/g, '');
 }
 function normalizeAlias(v) {
   return String(v || '')
     .normalize('NFKC')
     .toLowerCase()
@@ -2386,66 +2408,91 @@ async function doIngestPipeline(input = {}, runIdParam = null) {
                 seen.add(marker);
                 list.push(str);
               }
               if (list.length) normalizedDomains[key] = list;
             }
           }
           if (Object.keys(normalizedDomains).length) {
             orderingDomains = normalizedDomains;
             if (!pnTemplate && typeof recipe?.pn_template === 'string' && recipe.pn_template.trim()) {
               pnTemplate = recipe.pn_template.trim();
             }
           }
         } catch (err) {
           console.warn('[ordering] recipe extract failed:', err?.message || err);
         }
       }
     }
   }
 
   if (orderingDomains) {
     const orderingKeys = Object.keys(orderingDomains)
       .map((key) => String(key || '').trim())
       .filter(Boolean);
     if (orderingKeys.length) {
       const orderingTemplate = extractOrderingTemplate(extracted?.ordering_info);
-      if (!pnTemplate && orderingTemplate) pnTemplate = orderingTemplate;
-      const templateForOrdering = orderingTemplate
-        || orderingOverride?.pnTemplate
-        || pnTemplate
-        || blueprint?.ingestOptions?.pn_template
-        || blueprint?.ingestOptions?.pnTemplate
-        || null;
       const baseSeriesForOrdering = (
         orderingOverride?.series
           || extracted?.rows?.[0]?.series_code
           || extracted?.rows?.[0]?.series
           || baseSeries
           || series
           || code
           || null
       );
+      if (!pnTemplate && orderingTemplate) pnTemplate = orderingTemplate;
+      // 템플릿이 여전히 없으면, 여기서 즉시 학습해 폭발 단계에 반영
+      if (USE_PN_TEMPLATE && !pnTemplate) {
+        try {
+          const fullText = await readText(gcsUri, 300 * 1024).catch(() => '');
+          if (fullText) {
+            const { learnPnTemplate, upsertExtractionRecipe } = require('./pn-grammar');
+            const tpl = await learnPnTemplate({
+              family,
+              brand: brandName,
+              series: baseSeriesForOrdering,
+              docText: fullText,
+              rows: Array.isArray(extracted?.rows) && extracted.rows.length ? extracted.rows : rawRows,
+            });
+            if (tpl) {
+              pnTemplate = tpl;
+              await upsertExtractionRecipe({
+                family,
+                brand: brandName,
+                series: baseSeriesForOrdering,
+                pnTemplate: tpl,
+              });
+            }
+          }
+        } catch (_) {}
+      }
+      const templateForOrdering = orderingTemplate
+        || orderingOverride?.pnTemplate
+        || pnTemplate
+        || blueprint?.ingestOptions?.pn_template
+        || blueprint?.ingestOptions?.pnTemplate
+        || null;
       const orderingBase = {
         brand: brandName,
         series: baseSeriesForOrdering,
         series_code: baseSeriesForOrdering,
         values: orderingDomains,
       };
       const explodedOrdering = explodeToRows(orderingBase, {
         variantKeys: orderingKeys,
         pnTemplate: templateForOrdering,
       });
       if (Array.isArray(explodedOrdering) && explodedOrdering.length) {
         const existingCodes = new Set();
         for (const row of rawRows) {
           if (!row || typeof row !== 'object') continue;
           const seed = row.code ?? row.pn ?? row.part_number;
           if (!seed) continue;
           const norm = String(seed).trim().toLowerCase();
           if (norm) existingCodes.add(norm);
         }
         const appendedRows = [];
         for (const generated of explodedOrdering) {
           if (!generated || typeof generated !== 'object') continue;
           const codeValue = typeof generated.code === 'string' ? generated.code.trim() : '';
           if (!codeValue) continue;
           const codeNorm = codeValue.toLowerCase();