diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index 6aee5cff60ca6bee2832ba97740bebce7c8302b6..6c9eae37a23b4d2d9f2d32cadd33f06bbec48e03 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -1,44 +1,43 @@
 'use strict';
 
 const path = require('node:path');
 const fs = require('node:fs/promises');
 const os = require('node:os');
 const { execFile } = require('node:child_process');
 const { promisify } = require('node:util');
 const execFileP = promisify(execFile);
 
 const db = require('../../db');
 const { storage, parseGcsUri, readText, canonicalCoverPath } = require('../utils/gcs');
 const { extractText } = require('../utils/extract');
 const { getBlueprint } = require('../utils/blueprint');
 const { resolveBrand } = require('../utils/brand');
 const { detectVariantKeys } = require('../utils/ordering');
 const { extractPartsAndSpecsFromPdf } = require('../ai/datasheetExtract');
 const { extractFields } = require('./extractByBlueprint');
 const { aiCanonicalizeKeys } = require('./ai/canonKeys');
-const { canonicalize } = require('./specKeyMap');
 const { saveExtractedSpecs } = require('./persist');
 const { explodeToRows } = require('../ingest/mpn-exploder');
 const { splitAndCarryPrefix } = require('../utils/mpn-exploder');
 const { ensureSpecColumnsForBlueprint } = require('./ensure-spec-columns');
 const { inferVariantKeys, normalizeSlug } = require('./variant-keys');
 const { classifyByGcs, extractValuesByGcs } = require('../services/vertex');
 const { processDocument: processDocAi } = require('../services/docai');
 
 const HARD_CAP_MS = Number(process.env.EXTRACT_HARD_CAP_MS || 120000);
 
 function withDeadline(promise, ms = HARD_CAP_MS, label = 'op') {
   const timeout = Number.isFinite(ms) && ms > 0 ? ms : HARD_CAP_MS;
   return new Promise((resolve, reject) => {
     const timer = setTimeout(() => {
       clearTimeout(timer);
       reject(new Error(`${label}_TIMEOUT`));
     }, timeout);
     Promise.resolve(promise)
       .then((value) => {
         clearTimeout(timer);
         resolve(value);
       })
       .catch((err) => {
         clearTimeout(timer);
         reject(err);
diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index 6aee5cff60ca6bee2832ba97740bebce7c8302b6..6c9eae37a23b4d2d9f2d32cadd33f06bbec48e03 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -906,51 +905,51 @@ async function runAutoIngest(input = {}) {
   const canonicalRuntimeSpecKeys = new Set();
   const sanitizeSpecRows = (rows) => {
     if (!Array.isArray(rows)) return [];
     return rows.map((row) => {
       if (!row || typeof row !== 'object') return {};
       const out = {};
       for (const [rawKey, rawValue] of Object.entries(row)) {
         const key = String(rawKey || '').trim();
         if (!key) continue;
         const lower = key.toLowerCase();
         if (META_KEYS.has(lower) || BASE_KEYS.has(lower) || SKIP_SPEC_KEYS.has(lower)) {
           const existing = Object.prototype.hasOwnProperty.call(out, lower) ? out[lower] : undefined;
           if (!Object.prototype.hasOwnProperty.call(out, lower) || existing == null || existing === '') {
             out[lower] = rawValue;
           }
           continue;
         }
         if (lower.startsWith('_')) {
           const metaKey = lower;
           const existing = Object.prototype.hasOwnProperty.call(out, metaKey) ? out[metaKey] : undefined;
           if (!Object.prototype.hasOwnProperty.call(out, metaKey) || existing == null || existing === '') {
             out[metaKey] = rawValue;
           }
           continue;
         }
-        const canon = canonicalize(key);
+        const canon = normalizeSpecKeyName(key);
         if (!canon) continue;
         canonicalRuntimeSpecKeys.add(canon);
         const existing = Object.prototype.hasOwnProperty.call(out, canon) ? out[canon] : undefined;
         if (!Object.prototype.hasOwnProperty.call(out, canon) || existing == null || existing === '') {
           out[canon] = rawValue;
         }
       }
       return out;
     });
   };
 
   if (Array.isArray(extracted?.rows) && extracted.rows.length) {
     extracted.rows = sanitizeSpecRows(extracted.rows);
   }
 
   const autoAddKeys = Array.from(canonicalRuntimeSpecKeys);
   if (process.env.AUTO_ADD_FIELDS === '1' && family && autoAddKeys.length) {
     try {
       const { rows } = await db.query(
         'SELECT public.ensure_dynamic_spec_columns($1, $2::jsonb) AS created',
         [family, JSON.stringify(autoAddKeys)]
       );
       const created = rows?.[0]?.created;
       if (Array.isArray(created) && created.length) {
         console.log('[schema] added columns', created);
