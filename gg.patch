diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index cdd75999317172da9671f8992b0b7f99e7d3a850..f5fd4174d4c5191bfa29f1f06f35e1f8d59df942 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -1020,55 +1020,73 @@ async function persistProcessedData(processed = {}, overrides = {}) {
   const brandSeed = (processedBrand && String(processedBrand).trim().toLowerCase() !== 'unknown')
     ? processedBrand
     : null;
   if ((docText && docText.length) || brandSeed) {
     const applyRowHints = (row) => {
       if (!row || typeof row !== 'object') return;
       if (docText && (row._doc_text == null || row._doc_text === '')) {
         row._doc_text = docText;
       }
       if (brandSeed && (!row.brand || !String(row.brand).trim())) {
         row.brand = brandSeed;
       }
     };
     for (const row of records) applyRowHints(row);
     if (Array.isArray(processedRowsInput) && processedRowsInput !== records) {
       for (const row of processedRowsInput) applyRowHints(row);
     }
   }
 
   const qualified = qualifiedInput || (table ? (table.startsWith('public.') ? table : `public.${table}`) : null);
   const runId = processed?.runId ?? processed?.run_id ?? overrides?.runId ?? overrides?.run_id ?? null;
   const jobId = processed?.jobId ?? processed?.job_id ?? overrides?.jobId ?? overrides?.job_id ?? null;
 
   let persistResult = { upserts: 0, written: [], skipped: [], warnings: [] };
   if (qualified && family && records.length) {
+    const allowMinimal = /^(1|true|on)$/i.test(process.env.ALLOW_MINIMAL_INSERT || '0');
+    const requiredList = Array.isArray(requiredFields) ? requiredFields : [];
+    const effectiveRequired = allowMinimal ? [] : requiredList;
+
+    const normalizeBrand = (value) => {
+      if (value == null) return null;
+      const trimmed = String(value).trim();
+      if (!trimmed) return null;
+      if (trimmed.toLowerCase() === 'unknown') return null;
+      return trimmed;
+    };
+
+    const brandOverride = normalizeBrand(overrides?.brand)
+      || normalizeBrand(processedBrand)
+      || normalizeBrand(brandName)
+      || normalizeBrand(extractedBrand)
+      || null;
+
     persistResult = await saveExtractedSpecs(qualified, family, records, {
-      brand: overrides?.brand ?? null, // 폼/페이로드 브랜드 우선 활용
+      brand: brandOverride,
       pnTemplate,
-      requiredKeys: Array.isArray(requiredFields) ? requiredFields : [],
-      coreSpecKeys: Array.isArray(requiredFields) ? requiredFields : [],
+      requiredKeys: effectiveRequired,
+      coreSpecKeys: effectiveRequired,
       runId,
       run_id: runId,
       jobId,
       job_id: jobId,
     }) || persistResult;
   } else if (!records.length) {
     persistResult.skipped = [{ reason: 'missing_pn' }];
   }
 
   const persistedCodes = new Set(
     (persistResult.written || [])
       .map((pn) => String(pn || '').trim())
       .filter(Boolean)
   );
 
   if (!persistedCodes.size && records.length) {
     for (const rec of records) {
       const pn = String(rec.pn || rec.code || '').trim();
       if (pn) persistedCodes.add(pn);
     }
   }
 
   const persistedList = Array.from(persistedCodes);
   const mpnListSafe = Array.isArray(mpnList) ? mpnList : [];
   const mergedMpns = Array.from(new Set([...persistedList, ...mpnListSafe]));
