diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index dd1825fc963f8b46c906fa2197e17be1562297a0..818a98bb77eaeeac781d6c96ed1f7bf30a21d85f 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -1,94 +1,80 @@
 'use strict';
 
 const path = require('node:path');
 const fs = require('node:fs/promises');
 const os = require('node:os');
 const { execFile } = require('node:child_process');
 const { promisify } = require('node:util');
 const execFileP = promisify(execFile);
 
 const db = require('../utils/db');
 const { storage, parseGcsUri, readText, canonicalCoverPath } = require('../utils/gcs');
-const { upsertByBrandCode } = require('../utils/schema');
 const { getBlueprint } = require('../utils/blueprint');
 const { extractPartsAndSpecsFromPdf } = require('../ai/datasheetExtract');
 const { extractFields } = require('./extractByBlueprint');
 const { saveExtractedSpecs } = require('./persist');
 
 const FAST = String(process.env.INGEST_MODE || '').toUpperCase() === 'FAST' || process.env.FAST_INGEST === '1';
 const FAST_PAGES = [0, 1, -1]; // ì²« í˜ì´ì§€, 2í˜ì´ì§€, ë§ˆì§€ë§‰ í˜ì´ì§€ë§Œ
 
 // familyë³„ "ìµœì†Œ í‚¤ì…‹" (í•„ìš” ìµœì†Œì¹˜ë§Œ ì €ì¥)
 const MIN_KEYS = {
   relay_power: [
     'contact_form','contact_rating_ac','contact_rating_dc',
     'coil_voltage_vdc','size_l_mm','size_w_mm','size_h_mm'
   ],
   relay_signal: [
     'contact_form','contact_rating_ac','contact_rating_dc','coil_voltage_vdc'
   ]
 };
 
 const META_KEYS = new Set(['variant_keys','pn_template','ingest_options']);
 const BASE_KEYS = new Set([
   'family_slug','brand','code','brand_norm','code_norm','series_code',
   'datasheet_uri','image_uri','datasheet_url','display_name','displayname',
   'cover','verified_in_doc','updated_at'
 ]);
 
 function normLower(s){ return String(s||'').trim().toLowerCase(); }
 
 function harvestMpnCandidates(text, series){
   const hay = String(text||'');
   if (!hay) return [];
   const ser = String(series||'').toUpperCase().replace(/[^A-Z0-9]/g,'');
   const lines = hay.split(/\n+/);
   const near = [];
   for (const ln of lines){
     if (/ordering|part\s*number|order code|å“ç•ª|å‹ç•ª/i.test(ln)) near.push(ln);
   }
   const src = (near.length? near.join(' ') : hay).toUpperCase();
   const rx = ser ? new RegExp(`\\b${ser}[A-Z0-9\\-]+\\b`,'g') : /\b[A-Z][A-Z0-9\-]{3,}\b/g;
   const set = new Set();
   let m; while((m = rx.exec(src))) set.add(m[0]);
   return [...set];
 }
 
-async function getTableColumns(qualified) {
-  const [schema, table] = qualified.includes('.') ? qualified.split('.') : ['public', qualified];
-  const q = `
-    SELECT a.attname AS col
-      FROM pg_attribute a
-      JOIN pg_class c ON a.attrelid = c.oid
-      JOIN pg_namespace n ON c.relnamespace = n.oid
-     WHERE n.nspname = $1 AND c.relname = $2
-       AND a.attnum > 0 AND NOT a.attisdropped`;
-  const r = await db.query(q, [schema, table]);
-  return new Set(r.rows.map(x=>x.col));
-}
-
 // DB ì»¬ëŸ¼ íƒ€ì… ì¡°íšŒ (fallbackìš©)
 async function getColumnTypes(qualified) {
   const [schema, table] = qualified.includes('.') ? qualified.split('.') : ['public', qualified];
   const q = `
     SELECT lower(column_name) AS col, lower(data_type) AS dt
     FROM information_schema.columns
     WHERE table_schema=$1 AND table_name=$2`;
   const { rows } = await db.query(q, [schema, table]);
   const out = new Map();
   for (const { col, dt } of rows) {
     if (/(integer|bigint|smallint)/.test(dt)) out.set(col, 'int');
     else if (/(numeric|decimal|double precision|real)/.test(dt)) out.set(col, 'numeric');
     else if (/boolean/.test(dt)) out.set(col, 'bool');
     else out.set(col, 'text');
   }
   return out;
 }
 
 // ìˆ«ì ê°•ì œì •ê·œí™”(ì½¤ë§ˆ/ë‹¨ìœ„/ë¦¬ìŠ¤íŠ¸/ë²”ìœ„ í—ˆìš© â†’ ì²« ìˆ«ìë§Œ)
 function coerceNumeric(x) {
   if (x == null || x === '') return null;
   if (typeof x === 'number') return x;
   let s = String(x).toLowerCase().replace(/(?<=\d),(?=\d{3}\b)/g, '').replace(/\s+/g, ' ').trim();
   if (/-?\d+(?:\.\d+)?\s*(?:to|~|â€“|â€”|-)\s*-?\d+(?:\.\d+)?/.test(s)) return null;
   const m = s.match(/(-?\d+(?:\.\d+)?)(?:\s*([kmgmunpÂµ]))?/i);
diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index dd1825fc963f8b46c906fa2197e17be1562297a0..818a98bb77eaeeac781d6c96ed1f7bf30a21d85f 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -150,86 +136,50 @@ function expandFromCodeSystem(extracted, bp) {
   return out;
 }
 
 function applyCodeRules(code, out, rules, colTypes) {
   if (!Array.isArray(rules)) return;
   const src = String(code || '');
   for (const r of rules) {
     const re = new RegExp(r.pattern, r.flags || 'i');
     const m = src.match(re);
     if (!m) continue;
     for (const [col, spec] of Object.entries(r.set || {})) {
       if (!colTypes.has(col)) continue;
       let v;
       const gname = spec.from || '1';
       v = (m.groups && m.groups[gname]) || m[gname] || m[1] || null;
       if (v == null) continue;
       if (spec.map) v = spec.map[v] ?? v;
       if (spec.numeric) v = coerceNumeric(v);
       if (v == null || v === '') continue;
       out[col] = v;
     }
   }
 }
 
 
-// ì»¬ëŸ¼ íƒ€ì…ì— ë§ì¶° ê°’ ì •ë¦¬: ìˆ«ì/ì •ìˆ˜/ë¶ˆë¦¬ì–¸ë§Œ ê°•ì œ ë³€í™˜, ì‹¤íŒ¨í•˜ë©´ í•´ë‹¹ í‚¤ ì œê±°
-function sanitizeByColTypes(obj, colTypes) {
-  for (const [k, v] of Object.entries({ ...obj })) {
-    const t = colTypes.get(k);
-    if (t === 'numeric') {
-      const n = coerceNumeric(v);
-      if (n == null) delete obj[k]; else obj[k] = n;
-    } else if (t === 'int') {
-      const n = coerceNumeric(v);
-      if (n == null) delete obj[k]; else obj[k] = Math.round(n);
-    } else if (t === 'bool') {
-      if (typeof v === 'boolean') continue;
-      const s = String(v ?? '').toLowerCase().trim();
-      if (!s) delete obj[k];
-      else obj[k] = /^(true|yes|y|1|on|enable|enabled|pass)$/i.test(s);
-    }
-  }
-  return obj;
-}
-
-function normalizeKeysOnce(obj = {}) {
-  const out = {};
-  for (const [key, value] of Object.entries(obj || {})) {
-    const normalized = String(key || '')
-      .trim()
-      .toLowerCase()
-      .replace(/[^a-z0-9_]+/g, '_')
-      .replace(/^_+|_+$/g, '');
-    if (!normalized) continue;
-    if (!(normalized in out)) out[normalized] = value;
-  }
-  return out;
-}
-
-
-
 // DB í•¨ìˆ˜ë¡œ ìŠ¤í‚¤ë§ˆ ë³´ì¥ (ensure_specs_table)
 async function ensureSpecsTableByFamily(family){
   await db.query(`SELECT public.ensure_specs_table($1)`, [family]);
 }
 
 async function extractCoverToGcs(gcsPdfUri, { family, brand, code }) {
   try {
     const { bucket, name } = parseGcsUri(gcsPdfUri);
     const tmp = path.join(os.tmpdir(), 'pdf-'+Date.now());
     const pdf = path.join(tmp, 'doc.pdf');
     await fs.mkdir(tmp, { recursive: true });
     const [buf] = await storage.bucket(bucket).file(name).download();
     await fs.writeFile(pdf, buf);
 
     // ì¼ë¶€ PDFì—ì„œ pdfimagesê°€ ë§¤ìš° ì˜¤ë˜ ê±¸ë¦¬ê±°ë‚˜ ë©ˆì¶”ëŠ” ì‚¬ë¡€ ë°©ì§€
     await execFileP('pdfimages', ['-f','1','-l','2','-png', pdf, path.join(tmp,'img')], {
       timeout: Number(process.env.COVER_EXTRACT_TIMEOUT_MS || 45000), // 45s
       maxBuffer: 16 * 1024 * 1024,
     });
     const list = (await fs.readdir(tmp)).filter(f => /^img-\d+-\d+\.png$/i.test(f));
     if (!list.length) return null;
     let pick=null, size=-1;
     for (const f of list) {
       const st = await fs.stat(path.join(tmp, f));
       if (st.size > size) { pick=f; size=st.size; }
diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index dd1825fc963f8b46c906fa2197e17be1562297a0..818a98bb77eaeeac781d6c96ed1f7bf30a21d85f 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -455,57 +405,54 @@ async function runAutoIngest({
       .catch((err) => { clearTimeout(timer); reject(err); });
   });
 
 
     // family ì¶”ì • (ë¯¸ì§€ì • ì‹œ ì¼ë¶€ í…ìŠ¤íŠ¸ë§Œ ì½ì–´ ë¹ ë¥´ê²Œ ì¶”ì •)
   let fileName = '';
   try { const { name } = parseGcsUri(gcsUri); fileName = path.basename(name); } catch {}
   let family = (family_slug||'').toLowerCase() || guessFamilySlug({ fileName }) || 'relay_power';
   if (!family && !FAST) {
     try {
      const text = await readText(gcsUri, 256*1024);
      family = guessFamilySlug({ fileName, previewText: text }) || 'relay_power';
      // â˜… ê°•ì œ ë³´ì •: ì œëª©/ë³¸ë¬¸ì— Signal Relayê°€ ìˆìœ¼ë©´ ë¬´ì¡°ê±´ signalë¡œ
      if (/subminiature\s+signal\s+relay|signal\s+relay/i.test(text)) family = 'relay_signal';
    } catch { family = 'relay_power'; }
   }
 
   // ëª©ì  í…Œì´ë¸”
   const reg = await db.query(
     `SELECT specs_table FROM public.component_registry WHERE family_slug=$1 LIMIT 1`,
     [family]
   );
   const table = reg.rows[0]?.specs_table || 'relay_power_specs';
   const qualified = table.startsWith('public.')? table : `public.${table}`;
 
-  // ìŠ¤í‚¤ë§ˆ ë³´ì¥ (DB í•¨ìˆ˜) + ì»¬ëŸ¼ì…‹ í™•ë³´
-    if (!/^(1|true|on)$/i.test(process.env.NO_SCHEMA_ENSURE || '0')) {
+  // ìŠ¤í‚¤ë§ˆ ë³´ì¥ (DB í•¨ìˆ˜) + ì»¬ëŸ¼ íƒ€ì… í™•ë³´
+  if (!/^(1|true|on)$/i.test(process.env.NO_SCHEMA_ENSURE || '0')) {
     await ensureSpecsTableByFamily(family);
   }
-  const colsSet = new Set([
-    ...await getTableColumns(qualified)
-  ].map((c) => String(c || '').toLowerCase()));
   const colTypes = await getColumnTypes(qualified);
 
   // ë¸”ë£¨í”„ë¦°íŠ¸ í—ˆìš© í‚¤
   const blueprint = await getBlueprint(family);
   const allowedKeys = blueprint?.allowedKeys || [];
   const variantKeys = Array.isArray(blueprint?.ingestOptions?.variant_keys)
     ? blueprint.ingestOptions.variant_keys.map((k) => String(k || '').trim().toLowerCase()).filter(Boolean)
     : (Array.isArray(blueprint?.variant_keys)
       ? blueprint.variant_keys.map((k) => String(k || '').trim().toLowerCase()).filter(Boolean)
       : []);
 
   // -------- ê³µìš© ê°•ì œì •ê·œí™” ìœ í‹¸ --------
 
   if (code && !/\d/.test(String(code))) {
     // "AGN","TQ" ì²˜ëŸ¼ ìˆ«ì ì—†ëŠ” ì‹œë¦¬ì¦ˆëŠ” seriesë¡œ ë„˜ê¸°ê³  codeëŠ” ë¹„ì›€
     series = code; code = null;
   }
 
 
   // â¶ PDF í…ìŠ¤íŠ¸ ì¼ë¶€ì—ì„œ í’ˆë²ˆ í›„ë³´ ìš°ì„  í™•ë³´
   let previewText = '';
   try { previewText = await readText(gcsUri, PREVIEW_BYTES) || ''; } catch {}
   let candidates = [];
   try {
     candidates = await extractPartNumbersFromText(previewText, { series: series || code });
diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index dd1825fc963f8b46c906fa2197e17be1562297a0..818a98bb77eaeeac781d6c96ed1f7bf30a21d85f 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -798,77 +745,87 @@ async function runAutoIngest({
 
   // ìµœí›„ í´ë°± ì¤„ì´ê¸°
   if (!records.length) {
     const tmp = 'TMP_' + (Math.random().toString(16).slice(2, 8)).toUpperCase();
     records.push({
       family_slug: family,
       brand: brand || extracted.brand || 'unknown',
       code: tmp,
       series_code: series || code || null,
       datasheet_uri: gcsUri,
       image_uri: coverUri || null,
       display_name: `${brand || extracted.brand || 'unknown'} ${tmp}`,
       verified_in_doc: false,
       updated_at: now,
     });
   }
 
   console.log('[MPNDBG]', {
     picks: candidateMap.length,
     vkeys: Array.isArray(blueprint?.ingestOptions?.variant_keys) ? blueprint.ingestOptions.variant_keys : [],
     expanded: expandedRows.length,
     recs: records.length,
     colsSanitized: colTypes?.size || 0,
   });
 
-  // ì—…ì„œíŠ¸
+  const persistedCodes = new Set();
   let upserted = 0;
   for (const rec of records) {
-    const safe = {};
-    // ê³µí†µ í‚¤
-    if (colsSet.has('family_slug')) safe.family_slug = rec.family_slug;
-    if (colsSet.has('brand'))       safe.brand = rec.brand;
-    if (colsSet.has('code'))        safe.code  = rec.code;
-    if (colsSet.has('brand_norm'))  safe.brand_norm = normLower(rec.brand);
-    if (colsSet.has('code_norm'))   safe.code_norm  = normLower(rec.code);
-    if (colsSet.has('series_code')) safe.series_code = rec.series_code;
-    if (colsSet.has('datasheet_uri')) safe.datasheet_uri = rec.datasheet_uri;
-    if (colsSet.has('image_uri'))     safe.image_uri     = rec.image_uri;
-    if (colsSet.has('datasheet_url')) safe.datasheet_url = rec.datasheet_uri; // ë³„ì¹­ í˜¸í™˜
-    if (colsSet.has('display_name'))  safe.display_name  = rec.display_name;
-    if (colsSet.has('displayname'))   safe.displayname   = rec.display_name;
-    if (colsSet.has('cover') && rec.image_uri) safe.cover = rec.image_uri;
-    if (colsSet.has('verified_in_doc')) safe.verified_in_doc = !!rec.verified_in_doc;
-
-    // ë¸”ë£¨í”„ë¦°íŠ¸ ê°’
-    for (const [k,v] of Object.entries(rec)) {
-      const kk = String(k || '').toLowerCase();
-      if (BASE_KEYS.has(kk)) continue;
-      if (!colsSet.has(kk)) continue;
-      if (META_KEYS.has(kk)) continue;
-      safe[kk] = v;
+    const codeValue = String(rec.code || '').trim();
+    if (!codeValue) continue;
+
+    const base = {
+      brand: rec.brand || brandName,
+      code: codeValue,
+      series_code: rec.series_code ?? null,
+      datasheet_uri: rec.datasheet_uri || gcsUri,
+      verified_in_doc: !!rec.verified_in_doc,
+    };
+    if (rec.mfr_full) base.mfr_full = rec.mfr_full;
+
+    const specs = {};
+    for (const [rawKey, rawValue] of Object.entries(rec)) {
+      const key = String(rawKey || '').trim().toLowerCase();
+      if (!key || BASE_KEYS.has(key) || META_KEYS.has(key)) continue;
+      if (!Object.prototype.hasOwnProperty.call(specs, key)) {
+        specs[key] = rawValue;
+      }
+    }
+    if (rec.display_name) {
+      if (specs.display_name == null) specs.display_name = rec.display_name;
+      if (specs.displayname == null) specs.displayname = rec.display_name;
+    }
+    if (rec.image_uri) {
+      if (specs.image_uri == null) specs.image_uri = rec.image_uri;
+      if (specs.cover == null) specs.cover = rec.image_uri;
+    } else if (coverUri && specs.cover == null) {
+      specs.cover = coverUri;
+    }
+    if (specs.datasheet_url == null && (rec.datasheet_uri || gcsUri)) {
+      specs.datasheet_url = rec.datasheet_uri || gcsUri;
     }
-    if (colsSet.has('updated_at')) safe.updated_at = now;
 
-    // â† ì—…ì„œíŠ¸ ì „ì— ìˆ«ì/ì •ìˆ˜/ë¶ˆë¦¬ì–¸ ì»¬ëŸ¼ì„ íƒ€ì…ì— ë§ì¶° ì •ë¦¬(ì‹¤íŒ¨ í‚¤ëŠ” ì‚­ì œ)
-    sanitizeByColTypes(safe, colTypes);
-    await upsertByBrandCode(table, normalizeKeysOnce(safe));
+    await saveExtractedSpecs(family, base, specs);
+    persistedCodes.add(codeValue);
     upserted++;
   }
 
+  const persistedList = Array.from(persistedCodes);
+  const mpnList = Array.isArray(extracted?.mpn_list) ? extracted.mpn_list : [];
+  const mergedMpns = Array.from(new Set([...persistedList, ...mpnList]));
+
   return {
     ok: true,
     ms: Date.now() - started,
     family,
     final_table: table,
     brand: records[0]?.brand,
     code:  records[0]?.code,
     datasheet_uri: gcsUri,
-    cover: records[0]?.image_uri || null,
+    cover: coverUri || records[0]?.image_uri || null,
     rows: upserted,
-    // ğŸ”¹ í˜¸ì¶œìê°€ â€œì´ë²ˆ PDFì—ì„œ ë½‘íŒ ëª¨ë“  MPN ë¦¬ìŠ¤íŠ¸â€ë¥¼ ë°”ë¡œ í™•ì¸ ê°€ëŠ¥
-    codes: Array.isArray(extracted?.codes) ? extracted.codes : [],
-    mpn_list: Array.isArray(extracted?.mpn_list) ? extracted.mpn_list : [],
+    codes: persistedList,
+    mpn_list: mergedMpns,
   };
 }
 
 module.exports = { runAutoIngest };
