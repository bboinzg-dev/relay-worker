diff --git a/server.retail.import.js b/server.retail.import.js
index 60e9df333524a9af19c5270605929aeaaaf52fbe..59ec722a88bb4afdccda6424874c534c11700e6b 100644
--- a/server.retail.import.js
+++ b/server.retail.import.js
@@ -46,41 +46,46 @@ router.post('/api/retail/import', async (req, res, next) => {
 
   try {
     const query = new QueryStream('SELECT line FROM retail.export_products_ndjson()');
     const pgStream = dbClient.query(query);
 
     let count = 0;
     const toNdjson = new Transform({
       objectMode: true,
       transform(row, _enc, callback) {
         count += 1;
         callback(null, `${row.line}\n`);
       },
     });
 
     await new Promise((resolve, reject) => {
       pgStream
         .pipe(toNdjson)
         .pipe(gcsFile.createWriteStream({
           resumable: false,
           contentType: 'application/x-ndjson',
         }))
         .on('finish', resolve)
         .on('error', reject);
     });
 
+    const errorsPrefix = process.env.RETAIL_ERRORS_PREFIX || 'retail/errors';
     const [op] = await retail.importProducts({
       parent: BRANCH,
       inputConfig: { gcsSource: { inputUris: [gcsUri] } },
       reconciliationMode: 'INCREMENTAL',
+      // ★ 필수: 에러 로그 저장 경로 (gs://버킷/디렉토리)
+      errorsConfig: { gcsPrefix: `gs://${TEMP_BUCKET}/${errorsPrefix}` },
     });
     const [resp] = await op.promise();
 
     res.json({ done: true, result: resp, gcsUri, branch: BRANCH, count });
   } catch (err) {
-    next(err);
-      } finally {
+    console.error('[retail/import]', err?.message || err);
+    // 서버 크래시 방지: 500 JSON으로 돌려보냄
+    res.status(500).json({ done: false, error: String(err?.message || err), gcsUri });
+  } finally {
     dbClient.release();
   }
 });
 
-module.exports = router;
\ No newline at end of file
+module.exports = router;