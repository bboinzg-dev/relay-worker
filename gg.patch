diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index 121109ac8a7011a826b6b4d1fa84f1223f269950..d86c9bfaa393acf4bb130e82a7e582ec5f2070de 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -145,50 +145,58 @@ const MERGE_SKIP_KEYS = new Set([
   'display_name',
   'displayname',
   'image_uri',
   'datasheet_uri',
   'cover',
   'verified_in_doc',
   'raw_json',
   'text',
   'tables',
   'mpn',
   'mpn_list',
   'codes',
   'candidates',
   '_doc_text',
   'last_error',
   'run_id',
   'job_id',
   'runid',
   'jobid',
 ]);
 
 const SPEC_MERGE_OVERRIDES = new Set(['code', 'code_norm', 'pn', 'pn_norm', 'series', 'series_code']);
 
 const DOC_AI_CODE_HEADER_RE =
   /(part\s*(?:no\.?|number|name)|type\s*(?:no\.?|number)?|model|品番|型式|型番|品號|部品番号|품번|형명|주문\s*번호|order(?:ing)?\s*code)/i;
+const DOC_TABLE_ORDERING_HINT_RE =
+  /(ordering|order\s*info|order\s*code|types?\b|type\s*(?:no\.?|number)|selection|品番|型式|型番|형명)/i;
+const DOC_TABLE_HEADER_FOOTER_RE = /(header|footer|page\s*\d+)/i;
+const PN_CANON_KEY_RE = /(^|_)(part|pn|code|model|type)(_|$)/;
+const PN_HEADER_LABEL_RE = /(part\s*(?:no\.?|number)|type\s*(?:no\.?|number)?|catalog\s*(?:no\.?|number)|model|品番|型式|형名|型番)/i;
+const PN_CANDIDATE_RE = /[0-9A-Z][0-9A-Z\-_/().#]{3,63}[0-9A-Z)#]/gi;
+const PN_BLACKLIST_RE = /(pdf|font|xref|object|type0|ffff)/i;
+const PN_STRICT = /^[A-Z0-9][A-Z0-9\-_.()/#]{1,62}[A-Z0-9)#]$/i;
 
   function gatherRuntimeSpecKeys(rows) {
   const set = new Set();
   const list = Array.isArray(rows) ? rows : [];
   for (const row of list) {
     if (!row || typeof row !== 'object') continue;
     for (const rawKey of Object.keys(row)) {
       const trimmed = String(rawKey || '').trim();
       if (!trimmed) continue;
       const lower = trimmed.toLowerCase();
       if (META_KEYS.has(lower) || BASE_KEYS.has(lower)) continue;
       set.add(trimmed);
     }
   }
   return set;
 }
 
 async function ensureDynamicColumnsForRows(qualifiedTable, rows) {
   if (!AUTO_ADD_FIELDS || !AUTO_ADD_FIELDS_LIMIT) return;
   const keys = Array.from(gatherRuntimeSpecKeys(rows)).slice(0, AUTO_ADD_FIELDS_LIMIT);
   if (!keys.length) return;
   const sample = {};
   if (Array.isArray(rows)) {
     const remaining = new Set(keys);
     for (const row of rows) {
@@ -234,74 +242,85 @@ function getValueIgnoreCase(row, keyLower) {
 
 function isEmptyValue(value) {
   if (value == null) return true;
   if (typeof value === 'string') return value.trim() === '';
   if (Array.isArray(value)) return value.length === 0;
   return false;
 }
 
 function normalizeDocAiCell(value) {
   return String(value ?? '')
     .normalize('NFKC')
     .replace(/[\u00A0\u2000-\u200B]/g, ' ')
     .replace(/\s+/g, ' ')
     .trim();
 }
 
 function flattenDocAiTablesForMerge(tables) {
   const records = [];
   const list = Array.isArray(tables) ? tables : [];
   for (let tableIndex = 0; tableIndex < list.length; tableIndex += 1) {
     const table = list[tableIndex];
     if (!table || typeof table !== 'object') continue;
     const headers = Array.isArray(table.headers) ? table.headers : [];
     const rows = Array.isArray(table.rows) ? table.rows : [];
     if (!headers.length || !rows.length) continue;
+
+    const headerNorms = headers.map((h) => normalizeDocAiCell(h));
+    const headerText = headerNorms.join(' ');
+    const isOrderingTable =
+      DOC_TABLE_ORDERING_HINT_RE.test(headerText) || headerNorms.some((h) => PN_HEADER_LABEL_RE.test(h));
+    const isHeaderFooter = !isOrderingTable && DOC_TABLE_HEADER_FOOTER_RE.test(headerText);
     for (let rowIndex = 0; rowIndex < rows.length; rowIndex += 1) {
       const row = rows[rowIndex];
       if (!Array.isArray(row)) continue;
       const values = {};
       const headerUsage = new Map();
       for (let colIndex = 0; colIndex < headers.length; colIndex += 1) {
         const headerRaw = headers[colIndex];
         let key = normalizeDocAiCell(headerRaw);
         if (!key) key = `column_${colIndex}`;
         const seen = headerUsage.get(key) || 0;
         headerUsage.set(key, seen + 1);
         if (seen > 0) {
           key = `${key}_${seen + 1}`;
         }
         const cellValue = normalizeDocAiCell(row[colIndex]);
         if (!cellValue) continue;
         values[key] = cellValue;
       }
       if (!Object.keys(values).length) continue;
       records.push({
         tableIndex,
         rowIndex,
-        headers: headers.map((h) => normalizeDocAiCell(h)),
+        headers: headerNorms,
         values,
+        _tableHints: {
+          headerText,
+          isOrderingTable,
+          isHeaderFooter,
+        },
       });
     }
   }
   return records;
 }
 
 function normalizeVariantDomains(domains) {
   const normalized = {};
   if (!domains || typeof domains !== 'object') return normalized;
   for (const [rawKey, rawValue] of Object.entries(domains)) {
     const key = String(rawKey || '').trim();
     if (!key) continue;
     const values = Array.isArray(rawValue) ? rawValue : [rawValue];
     const seen = new Set();
     const list = [];
     for (const candidate of values) {
       if (candidate == null) continue;
       const str = String(candidate).trim();
       const marker = str === '' ? '__EMPTY__' : str.toLowerCase();
       if (seen.has(marker)) continue;
       seen.add(marker);
       list.push(str);
     }
     if (list.length) normalized[key] = list;
   }
@@ -348,138 +367,474 @@ async function canonicalizeDocAiRecords(family, allowedKeys, records) {
       if (!normalized) continue;
       const info = mapping[normalized] || mapping[header] || {};
       if (info.action !== 'map' || !info.canonical) continue;
       const key = String(info.canonical || '').trim().toLowerCase();
       if (!key || used.has(key)) continue;
       const value = values[i];
       if (value == null || value === '') continue;
       canon[key] = value;
       used.add(key);
     }
     rec._canon = canon;
   }
 
   return list;
 }
 
 function normalizeDocAiTokenForMatch(value) {
   if (value == null) return null;
   const normalized = String(value)
     .toUpperCase()
     .replace(/[^0-9A-Z]/g, '');
   if (normalized.length < 4) return null;
   return normalized;
 }
 
-function bestRowMatchToSpec(row, docAiRecords, used = new Set()) {
+function bestRowMatchToSpec(row, docAiRecords, used = new Set(), options = {}) {
   if (!row || typeof row !== 'object') return null;
   const records = Array.isArray(docAiRecords) ? docAiRecords : [];
   if (!records.length) return null;
 
+  const tokenStats = options && typeof options === 'object' ? options.tokenStats || null : null;
+  const hasTokenFilter = Boolean(
+    tokenStats &&
+      ((tokenStats.orderingTokens && tokenStats.orderingTokens.size) ||
+        (tokenStats.headerOnlyTokens && tokenStats.headerOnlyTokens.size))
+  );
+  const allowToken = (token) => {
+    if (!token) return false;
+    if (tokenStats?.headerOnlyTokens?.has(token)) return false;
+    if (tokenStats?.orderingTokens?.size) {
+      return tokenStats.orderingTokens.has(token);
+    }
+    return true;
+  };
+
   const codeKeys = [
     'code',
     'code_norm',
     'pn',
     'pn_norm',
     'part_no',
     'part_number',
     'type_no',
     'type_number',
     'type',
     'typeno',
     'model',
     'model_no',
   ];
 
   const targetTokens = new Set();
   const rawTargets = new Set();
+  const filteredTargetTokens = new Set();
+  const filteredRawTargets = new Set();
   for (const key of codeKeys) {
     const value = getValueIgnoreCase(row, key);
     if (value == null || value === '') continue;
     const normalized = normalizeDocAiCell(value);
     if (!normalized) continue;
-    rawTargets.add(normalized.toUpperCase());
+    const rawUpper = normalized.toUpperCase();
+    rawTargets.add(rawUpper);
     const token = normalizeDocAiTokenForMatch(normalized);
-    if (token) targetTokens.add(token);
+    if (token) {
+      targetTokens.add(token);
+      if (!hasTokenFilter || allowToken(token)) {
+        filteredTargetTokens.add(token);
+        filteredRawTargets.add(rawUpper);
+      }
+    }
   }
 
   if (!targetTokens.size) return null;
 
+  const tokensForScore = hasTokenFilter ? filteredTargetTokens : targetTokens;
+  if (!tokensForScore.size) return null;
+  const rawTargetsForScore = hasTokenFilter ? filteredRawTargets : rawTargets;
+
   let best = null;
   for (const record of records) {
     if (!record || typeof record !== 'object') continue;
     if (used?.has(record)) continue;
     const values = record.values || {};
     const candidateTokens = new Set();
     const haystackParts = [];
     let headerBoost = 0;
     for (const [key, rawValue] of Object.entries(values)) {
       const value = normalizeDocAiCell(rawValue);
       if (!value) continue;
       haystackParts.push(value.toUpperCase());
       const normToken = normalizeDocAiTokenForMatch(value);
-      if (normToken) candidateTokens.add(normToken);
+      if (normToken && (!hasTokenFilter || allowToken(normToken))) {
+        candidateTokens.add(normToken);
+      }
       if (DOC_AI_CODE_HEADER_RE.test(String(key || ''))) headerBoost += 1;
     }
     if (!candidateTokens.size) continue;
 
     let exact = 0;
     let partial = 0;
-    for (const token of targetTokens) {
+    for (const token of tokensForScore) {
       if (candidateTokens.has(token)) {
         exact += 1;
         continue;
       }
       for (const candidate of candidateTokens) {
         if (candidate.includes(token) || token.includes(candidate)) {
           partial += 1;
           break;
         }
       }
     }
     if (!exact && !partial) continue;
 
     let score = exact * 12 + partial * 5 + headerBoost;
-    if (score <= 0 && rawTargets.size) {
+    if (score <= 0 && rawTargetsForScore.size) {
       const haystack = haystackParts.join(' ');
-      for (const raw of rawTargets) {
+      for (const raw of rawTargetsForScore) {
         if (haystack.includes(raw)) score += 2;
       }
     }
     if (score <= 0) continue;
 
     if (!best || score > best.score) {
       best = { record, score, exact, partial };
     }
   }
 
   if (!best) return null;
   if (best.exact <= 0 && best.partial <= 0) return null;
   if (best.exact <= 0 && best.score < 12) return null;
   return best.record;
 }
 
+function summarizeDocAiTokenUsage(records = []) {
+  const summary = new Map();
+  for (const record of Array.isArray(records) ? records : []) {
+    if (!record || typeof record !== 'object') continue;
+    const values = record.values && typeof record.values === 'object' ? record.values : {};
+    const isOrdering = Boolean(record?._tableHints?.isOrderingTable);
+    const isHeaderFooter = Boolean(record?._tableHints?.isHeaderFooter);
+    for (const [key, rawValue] of Object.entries(values)) {
+      const value = normalizeDocAiCell(rawValue);
+      if (!value) continue;
+      const token = normalizeDocAiTokenForMatch(value);
+      if (!token) continue;
+      const entry = summary.get(token) || {
+        total: 0,
+        ordering: 0,
+        headerFooter: 0,
+        codeHeader: 0,
+      };
+      entry.total += 1;
+      if (isOrdering) entry.ordering += 1;
+      if (isHeaderFooter) entry.headerFooter += 1;
+      if (DOC_AI_CODE_HEADER_RE.test(String(key || ''))) entry.codeHeader += 1;
+      summary.set(token, entry);
+    }
+  }
+
+  const orderingTokens = new Set();
+  const headerOnlyTokens = new Set();
+  for (const [token, info] of summary.entries()) {
+    if (!info) continue;
+    if (info.ordering > 0) orderingTokens.add(token);
+    const onlyHeaderFooter = info.headerFooter >= info.total && info.total > 0;
+    const onlyCodeHeaders = info.codeHeader >= info.total && info.total > 0;
+    if (info.ordering === 0 && (onlyHeaderFooter || onlyCodeHeaders)) {
+      headerOnlyTokens.add(token);
+    }
+  }
+
+  return { summary, orderingTokens, headerOnlyTokens };
+}
+
+function extractPnCandidatesFromValue(value) {
+  const normalized = normalizeDocAiCell(value);
+  if (!normalized) return [];
+  const results = [];
+  PN_CANDIDATE_RE.lastIndex = 0;
+  let match;
+  while ((match = PN_CANDIDATE_RE.exec(normalized)) != null) {
+    const raw = match[0];
+    if (!raw) continue;
+    if (PN_BLACKLIST_RE.test(raw)) continue;
+    const trimmed = raw.trim();
+    if (!trimmed) continue;
+    if (!PN_STRICT.test(trimmed)) continue;
+    results.push(trimmed);
+  }
+  return results;
+}
+
+function gatherPnCandidatesFromDoc(records = []) {
+  const map = new Map();
+  const orderingNorms = new Set();
+  let order = 0;
+  for (const record of Array.isArray(records) ? records : []) {
+    if (!record || typeof record !== 'object') continue;
+    const canon = record._canon && typeof record._canon === 'object' ? record._canon : {};
+    const isOrdering = Boolean(record?._tableHints?.isOrderingTable);
+    const headerText = String(record?._tableHints?.headerText || '').trim();
+    for (const [rawKey, rawValue] of Object.entries(canon)) {
+      const key = String(rawKey || '').trim().toLowerCase();
+      if (!key || !PN_CANON_KEY_RE.test(key)) continue;
+      const values = Array.isArray(rawValue) ? rawValue : [rawValue];
+      for (const value of values) {
+        const candidates = extractPnCandidatesFromValue(value);
+        for (const candidate of candidates) {
+          const norm = normalizeCode(candidate);
+          if (!norm || norm.length < 4) continue;
+          let entry = map.get(norm);
+          if (!entry) {
+            entry = {
+              norm,
+              total: 0,
+              ordering: 0,
+              headerTextSet: new Set(),
+              samples: new Set(),
+              order: order += 1,
+            };
+            map.set(norm, entry);
+          }
+          entry.total += 1;
+          if (isOrdering) entry.ordering += 1;
+          if (headerText) entry.headerTextSet.add(headerText);
+          entry.samples.add(candidate);
+        }
+      }
+    }
+  }
+
+  for (const entry of map.values()) {
+    if (!entry.sample) {
+      entry.sample = entry.samples.size ? entry.samples.values().next().value : entry.norm;
+    }
+    if (entry.ordering > 0) orderingNorms.add(entry.norm);
+  }
+
+  return { map, orderingNorms };
+}
+
+function collectVariantSignalsFromRow(row, variantKeys = []) {
+  const digits = new Set();
+  const tokens = new Set();
+  const pushValue = (raw) => {
+    if (raw == null) return;
+    if (Array.isArray(raw)) {
+      for (const item of raw) pushValue(item);
+      return;
+    }
+    if (typeof raw === 'number') {
+      if (!Number.isFinite(raw)) return;
+      const str = String(Math.round(raw * 1000) / 1000);
+      const digitsOnly = str.replace(/[^0-9]/g, '');
+      if (digitsOnly.length >= 2) digits.add(digitsOnly);
+      return;
+    }
+    const str = normalizeDocAiCell(raw);
+    if (!str) return;
+    const digitMatches = str.match(/\d+/g) || [];
+    for (const m of digitMatches) {
+      if (m.length >= 2) digits.add(m);
+    }
+    const tokenMatches = str.match(/[A-Z]{1,4}/gi) || [];
+    for (const t of tokenMatches) {
+      const upper = t.toUpperCase();
+      if (!upper) continue;
+      if (upper.length > 4) continue;
+      tokens.add(upper);
+    }
+  };
+
+  const lowerKeys = Array.isArray(variantKeys)
+    ? variantKeys.map((k) => String(k || '').trim().toLowerCase()).filter(Boolean)
+    : [];
+  const keySet = new Set([
+    ...lowerKeys,
+    'coil_voltage_vdc',
+    'coil_voltage_vac',
+    'coil_voltage',
+    'coil_voltage_code',
+    'coil_power_code',
+    'contact_form',
+    'suffix',
+  ]);
+  for (const key of keySet) {
+    const value = getValueIgnoreCase(row, key);
+    if (value != null) pushValue(value);
+  }
+
+  const decodedCoil = decodeCoilVoltageVdc(getValueIgnoreCase(row, 'coil_voltage_code'));
+  if (decodedCoil != null) pushValue(decodedCoil);
+
+  return {
+    digits: Array.from(digits),
+    tokens: Array.from(tokens),
+  };
+}
+
+function collectSeriesTokens(row, seriesHints = []) {
+  const tokens = new Set();
+  const pushToken = (value) => {
+    const normalized = normalizeDocAiCell(value);
+    if (!normalized) return;
+    const cleaned = normalized.replace(/[^0-9A-Z]/gi, '').toUpperCase();
+    if (cleaned.length >= 2 && cleaned.length <= 8) tokens.add(cleaned);
+    const parts = normalized.split(/[^0-9A-Za-z]+/g);
+    for (const part of parts) {
+      const piece = part.replace(/[^0-9A-Z]/gi, '').toUpperCase();
+      if (piece.length >= 2 && piece.length <= 8) tokens.add(piece);
+    }
+  };
+
+  const hints = [];
+  if (Array.isArray(seriesHints)) hints.push(...seriesHints);
+  if (row) {
+    hints.push(row.series, row.series_code);
+  }
+  for (const hint of hints) {
+    if (hint == null) continue;
+    pushToken(hint);
+  }
+
+  return Array.from(tokens);
+}
+
+function collectBrandTokens(brand) {
+  const tokens = new Set();
+  const normalized = normalizeDocAiCell(brand);
+  if (!normalized) return tokens;
+  const cleaned = normalized.replace(/[^0-9A-Z]/gi, '').toUpperCase();
+  if (cleaned.length >= 2 && cleaned.length <= 8) tokens.add(cleaned);
+  const parts = normalized.split(/[^0-9A-Za-z]+/g);
+  for (const part of parts) {
+    const piece = part.replace(/[^0-9A-Z]/gi, '').toUpperCase();
+    if (piece.length >= 2 && piece.length <= 8) tokens.add(piece);
+  }
+  return tokens;
+}
+
+function scoreOrderingPnCandidate(entry, sample, ctx = {}) {
+  if (!sample) return Number.NEGATIVE_INFINITY;
+  const pnUpper = sample.toUpperCase();
+  let score = 0;
+  if (entry) {
+    score += entry.ordering * 12;
+    score += entry.total * 2;
+  }
+  for (const digit of Array.isArray(ctx.variantDigits) ? ctx.variantDigits : []) {
+    const str = String(digit || '');
+    if (str && pnUpper.includes(str)) score += 6;
+  }
+  for (const token of Array.isArray(ctx.variantTokens) ? ctx.variantTokens : []) {
+    if (token && pnUpper.includes(token)) score += 3;
+  }
+  for (const token of Array.isArray(ctx.seriesTokens) ? ctx.seriesTokens : []) {
+    if (token && pnUpper.includes(token)) score += 4;
+  }
+  for (const token of Array.isArray(ctx.brandTokens) ? ctx.brandTokens : []) {
+    if (token && pnUpper.includes(token)) score += 2;
+  }
+  return score;
+}
+
+function pickOrderingPreferredPn(row, options = {}) {
+  const info = options && typeof options === 'object' ? options.candidateInfo || null : null;
+  const map = info && info.map instanceof Map ? info.map : null;
+  const hintList = [];
+  if (Array.isArray(options?.hints)) {
+    for (const hint of options.hints) hintList.push(hint);
+  } else {
+    if (options?.hintPn != null) hintList.push(options.hintPn);
+    if (options?.hintCode != null) hintList.push(options.hintCode);
+  }
+  const firstHint = hintList.find((hint) => typeof hint === 'string' && hint.trim());
+
+  if (!map || !map.size) {
+    return firstHint ? String(firstHint).trim() : null;
+  }
+
+  const normalizedHints = hintList
+    .map((value) => {
+      if (value == null) return null;
+      const raw = String(value).trim();
+      if (!raw) return null;
+      const norm = normalizeCode(raw);
+      if (!norm) return null;
+      return { raw, norm };
+    })
+    .filter(Boolean);
+
+  const variantSignals = collectVariantSignalsFromRow(row, options.variantKeys || []);
+  const seriesTokens = collectSeriesTokens(row, options.seriesHints || []);
+  const brandTokens = Array.from(collectBrandTokens(options.brand));
+  const context = {
+    variantDigits: variantSignals.digits,
+    variantTokens: variantSignals.tokens,
+    seriesTokens,
+    brandTokens,
+  };
+
+  const candidateEntries = [];
+  for (const [norm, entry] of map.entries()) {
+    if (entry && entry.ordering > 0) candidateEntries.push({ norm, entry });
+  }
+  if (!candidateEntries.length) {
+    for (const [norm, entry] of map.entries()) {
+      candidateEntries.push({ norm, entry });
+    }
+  }
+  if (!candidateEntries.length) {
+    return firstHint ? String(firstHint).trim() : null;
+  }
+
+  let best = null;
+  for (const { norm, entry } of candidateEntries) {
+    if (!entry) continue;
+    const sample = entry.sample || (entry.samples && entry.samples.values().next().value) || norm;
+    if (!sample) continue;
+    const score = scoreOrderingPnCandidate(entry, sample, context);
+    if (best == null || score > best.score) {
+      best = { norm, sample, score };
+    }
+  }
+
+  for (const hint of normalizedHints) {
+    const entry = map.get(hint.norm);
+    if (!entry) continue;
+    const sample = entry.sample || (entry.samples && entry.samples.values().next().value) || hint.raw;
+    const score = scoreOrderingPnCandidate(entry, sample, context);
+    if (!best || score > best.score || (best && score === best.score && hint.norm === best.norm)) {
+      best = { norm: hint.norm, sample, score };
+    }
+  }
+
+  if (best && best.sample) return best.sample;
+  return firstHint ? String(firstHint).trim() : null;
+}
+
 function bestAttributeMatchToSpec(row, docAiRecords, variantKeys = []) {
   if (!row || typeof row !== 'object') return null;
   const records = Array.isArray(docAiRecords) ? docAiRecords : [];
   if (!records.length) return null;
   const keys = Array.isArray(variantKeys)
     ? variantKeys.map((key) => String(key || '').toLowerCase()).filter(Boolean)
     : [];
   if (!keys.length) return null;
 
   const desired = new Map();
   for (const key of keys) {
     const value = getValueIgnoreCase(row, key);
     if (value == null || value === '') continue;
     const normalized = String(value).trim().toLowerCase();
     if (!normalized) continue;
     desired.set(key, normalized);
   }
   if (!desired.size) return null;
 
   let best = null;
   for (const record of records) {
     if (!record || typeof record !== 'object') continue;
     const canon = record._canon && typeof record._canon === 'object' ? record._canon : {};
     let matches = 0;
     let fields = 0;
@@ -865,54 +1220,50 @@ async function expandRowsWithVariants(baseRows, options = {}) {
           return re.test(String(text || ''));
         },
       }) || [];
     if (Array.isArray(exploded) && exploded.length) {
       for (const item of exploded) {
         if (!item || typeof item !== 'object') continue;
         const values = item.values && typeof item.values === 'object' ? item.values : {};
         const merged = { ...baseRow, ...values };
         if (item.code) merged.code = item.code;
         if (item.code_norm) merged.code_norm = item.code_norm;
         expanded.push(merged);
       }
       continue;
     }
 
     expanded.push(baseRow);
   }
 
   return {
     rows: expanded.length ? expanded : rows,
     variantKeys: effectiveVariantKeys,
     pnTemplate: effectivePnTemplate,
   };
 }
 
-const PN_CANDIDATE_RE = /[0-9A-Z][0-9A-Z\-_/().#]{3,63}[0-9A-Z)#]/gi;
-const PN_BLACKLIST_RE = /(pdf|font|xref|object|type0|ffff)/i;
-const PN_STRICT = /^[A-Z0-9][A-Z0-9\-_.()/#]{1,62}[A-Z0-9)#]$/i;
-
 function sanitizeDatasheetUrl(url) {
   if (url == null) return null;
   const str = typeof url === 'string' ? url.trim() : String(url || '').trim();
   if (!str) return null;
   try {
     const parsed = new URL(str);
     const pathname = (parsed.pathname || '').trim();
     if (!pathname) return null;
     const lowerPath = pathname.toLowerCase();
     if (!lowerPath.endsWith('.pdf')) return null;
     return parsed.toString();
   } catch {
     return null;
   }
 }
 
 function pickDatasheetUrl(rawUrl, fallbackUrl) {
   const sanitized = sanitizeDatasheetUrl(rawUrl);
   if (sanitized) return sanitized;
   const fallback = typeof fallbackUrl === 'string' ? fallbackUrl.trim() : String(fallbackUrl || '').trim();
   return fallback || null;
 }
 
 const RESERVED_SPEC_KEYS = new Set([
   'id',
@@ -2793,86 +3144,93 @@ async function doIngestPipeline(input = {}, runIdParam = null) {
   }
 
   if (docAiText) {
     const existing = typeof extracted.text === 'string' ? extracted.text : '';
     if (!existing || docAiText.length > existing.length) {
       extracted.text = docAiText;
     }
   }
   if (docAiTables.length && !extracted.tables.length) {
     extracted.tables = docAiTables;
   }
 
   const docAiRecordsFlat = flattenDocAiTablesForMerge(docAiTables);
   let docAiRecordsForMerge = docAiRecordsFlat;
   if (docAiRecordsForMerge.length) {
     try {
       docAiRecordsForMerge = await canonicalizeDocAiRecords(
         family,
         Array.isArray(allowedKeys) ? allowedKeys : [],
         docAiRecordsForMerge,
       );
     } catch (err) {
       console.warn('[canon] docAiRecordsForMerge canonicalization failed:', err?.message || err);
     }
   }
+  const docAiTokenStats = summarizeDocAiTokenUsage(docAiRecordsForMerge);
+  const docPnCandidatesInfo = gatherPnCandidatesFromDoc(docAiRecordsForMerge);
+  const docOrderingNorms = docPnCandidatesInfo?.orderingNorms instanceof Set
+    ? docPnCandidatesInfo.orderingNorms
+    : new Set();
   const vertexSpecValues = (() => {
     if (!vertexExtractValues || typeof vertexExtractValues !== 'object') return null;
     const filtered = {};
     for (const [rawKey, rawValue] of Object.entries(vertexExtractValues)) {
       const key = String(rawKey || '').trim();
       if (!key) continue;
       if (rawValue == null) continue;
       if (typeof rawValue === 'string' && rawValue.trim() === '') continue;
       filtered[key] = rawValue;
     }
     return Object.keys(filtered).length ? filtered : null;
   })();
 
   ensureExtractedShape(extracted);
 
   const usedDocAiRecords = new Set();
   if (!Array.isArray(extracted.rows)) extracted.rows = [];
 
   if (!extracted.rows.length && docAiRecordsForMerge.length) {
     for (const record of docAiRecordsForMerge) {
       if (!record || typeof record !== 'object') continue;
       const values = record.values || {};
       if (!values || typeof values !== 'object' || !Object.keys(values).length) continue;
       extracted.rows.push({ ...values });
       usedDocAiRecords.add(record);
     }
   }
 
   if (!extracted.rows.length && vertexSpecValues) {
     extracted.rows.push({ ...vertexSpecValues });
   }
 
   if (Array.isArray(extracted.rows) && extracted.rows.length) {
     for (const row of extracted.rows) {
       if (!row || typeof row !== 'object') continue;
-      let docMatch = bestRowMatchToSpec(row, docAiRecordsForMerge, usedDocAiRecords);
+      let docMatch = bestRowMatchToSpec(row, docAiRecordsForMerge, usedDocAiRecords, {
+        tokenStats: docAiTokenStats,
+      });
       if (!docMatch) {
         docMatch = bestAttributeMatchToSpec(row, docAiRecordsForMerge, variantKeys);
       }
       if (!docMatch && String(family || '').toLowerCase() === 'relay_signal') {
         docMatch = findCoilRowMatchForRelaySignal(row, docAiRecordsFlat);
       }
       if (docMatch && docMatch.values) {
         const patch = safeMergeSpec(row, docMatch.values);
         if (patch && Object.keys(patch).length) {
           Object.assign(row, patch);
         }
         usedDocAiRecords.add(docMatch);
       }
       if (vertexSpecValues) {
         const patch = safeMergeSpec(row, vertexSpecValues);
         if (patch && Object.keys(patch).length) {
           Object.assign(row, patch);
         }
       }
     }
   }
   
   if (docAiRecordsForMerge.length && Array.isArray(extracted.rows)) {
     for (const record of docAiRecordsForMerge) {
       if (!record || typeof record !== 'object') continue;
@@ -3321,50 +3679,89 @@ async function doIngestPipeline(input = {}, runIdParam = null) {
               stats,
             });
           }
         }
       }
     } catch (err) {
       console.warn('[variant] inferVariantKeys failed:', err?.message || err);
     }
   }
 
   if (!disableEnsure) {
     await ensureSpecsTableByFamily(family, qualified);
     if (!variantColumnsEnsured) {
       try {
         await ensureBlueprintVariantColumns(family);
         variantColumnsEnsured = true;
       } catch (err) {
         console.warn('[variant] ensure_blueprint_variant_columns fallback failed:', err?.message || err);
       }
     }
   }
 
   await ensureSpecColumnsForBlueprint(qualified, blueprint);
 
   const rawRows = Array.isArray(extracted?.rows) && extracted.rows.length ? extracted.rows : [];
+  if (docPnCandidatesInfo?.map instanceof Map && docPnCandidatesInfo.map.size && rawRows.length) {
+    const variantKeyUnion = Array.from(
+      new Set([
+        ...(Array.isArray(variantKeys) ? variantKeys : []),
+        ...(Array.isArray(runtimeVariantKeys) ? runtimeVariantKeys : []),
+      ])
+    );
+    for (const row of rawRows) {
+      if (!row || typeof row !== 'object') continue;
+      const hints = [row.pn, row.code, row.part_number, row.part_no, row.code_norm, code]
+        .map((value) => (value == null ? null : String(value)))
+        .filter((value) => value && value.trim());
+      const bestPn = pickOrderingPreferredPn(row, {
+        candidateInfo: docPnCandidatesInfo,
+        hints,
+        variantKeys: variantKeyUnion,
+        seriesHints: [baseSeries, series],
+        brand: row.brand || brandName,
+      });
+      if (!bestPn) continue;
+      const bestNorm = normalizeCode(bestPn);
+      if (!bestNorm) continue;
+      const existingCode = typeof row.code === 'string' ? row.code.trim() : '';
+      const existingCodeNorm = existingCode ? normalizeCode(existingCode) : null;
+      if (!existingCodeNorm || existingCodeNorm !== bestNorm) {
+        if (existingCode && existingCodeNorm && existingCodeNorm !== bestNorm && row._code_hint == null) {
+          row._code_hint = existingCode;
+        }
+        row.code = bestPn;
+      }
+      const existingPn = typeof row.pn === 'string' ? row.pn.trim() : '';
+      const existingPnNorm = existingPn ? normalizeCode(existingPn) : null;
+      if (!existingPnNorm || existingPnNorm !== bestNorm) {
+        row.pn = bestPn;
+      }
+      if (!row.part_number || normalizeCode(row.part_number) !== bestNorm) row.part_number = bestPn;
+      if (!row.part_no || normalizeCode(row.part_no) !== bestNorm) row.part_no = bestPn;
+    }
+  }
 
   let orderingDomains = null;
   let orderingOverride = null;
   let orderingTextSources = [];
   let orderingLegendRecipe = null;
   if (USE_CODE_RULES) {
     const orderingCollection = collectOrderingDomains({
       orderingInfo: extracted?.ordering_info,
       previewText,
       docAiText,
       docAiTables,
     });
     orderingDomains = orderingCollection?.domains ?? null;
     orderingTextSources = Array.isArray(orderingCollection?.textSources)
       ? orderingCollection.textSources
           .map((txt) => (typeof txt === 'string' ? txt : String(txt ?? '')))
           .map((txt) => txt.trim())
           .filter(Boolean)
       : [];
     if (!orderingDomains) {
       orderingOverride = buildTyOrderingFallback({
         baseSeries,
         orderingInfo: extracted?.ordering_info,
         previewText,
         docAiText,
@@ -3864,50 +4261,55 @@ async function doIngestPipeline(input = {}, runIdParam = null) {
           }
         }
       }
 
       const minCanonConf = Number(process.env.AUTO_CANON_MIN_CONF || '0.66');
       for (const [orig, info] of aiCanonicalMap.entries()) {
         if (info.action !== 'map' || !info.canonical || info.conf < minCanonConf) continue;
         try {
           await db.query('SELECT public.upsert_spec_alias($1,$2,$3)', [family, orig, info.canonical]);
         } catch (_) {
           /* ignore alias cache errors */
         }
       }
     } catch (err) {
       console.warn('[canon] aiCanonicalizeKeys failed:', err?.message || err);
       aiCanonicalMap.clear();
       aiCanonicalMapLower.clear();
     }
   }
 
   const mpnsFromDoc = harvestMpnCandidates(
     extracted?.text ?? '',
     (baseSeries || series || code || '')
   );
   const mpnNormFromDoc = new Set(mpnsFromDoc.map((m) => normalizeCode(m)).filter(Boolean));
+  if (docOrderingNorms.size) {
+    for (const norm of docOrderingNorms) {
+      if (norm) mpnNormFromDoc.add(norm);
+    }
+  }
 
   const candidateMap = [];
   const candidateNormSet = new Set();
   for (const cand of candidates) {
     const trimmed = typeof cand === 'string' ? cand.trim() : String(cand || '');
     if (!trimmed) continue;
     const norm = normalizeCode(trimmed);
     if (!norm || candidateNormSet.has(norm)) continue;
     candidateNormSet.add(norm);
     candidateMap.push({ raw: trimmed, norm });
   }
 
   const baseRows = (rawRows.length ? rawRows : [{}]).map((row) => {
     const rowObj = row && typeof row === 'object' ? { ...row } : {};
     if (variantDomainEntries.length) {
       for (const [domainKey, domainValues] of variantDomainEntries) {
         if (!Array.isArray(domainValues) || !domainValues.length) continue;
         const current = rowObj[domainKey];
         if (current == null || (typeof current === 'string' && current.trim() === '')) {
           rowObj[domainKey] = domainValues;
         }
       }
     }
     if (rowObj.brand == null) rowObj.brand = brandName;
     const fallbackSeries = rowObj.series_code || rowObj.series || baseSeries || null;
@@ -3944,51 +4346,51 @@ async function doIngestPipeline(input = {}, runIdParam = null) {
             ],
           );
           variantKeys = Array.from(combined);
         }
         if (expandedTemplate) {
           pnTemplate = expandedTemplate || pnTemplate;
         }
       }
     } catch (err) {
       console.warn('[variant] expandRowsWithVariants failed:', err?.message || err);
     }
   }
 
   explodedRows = Array.isArray(explodedRows) ? explodedRows : [];
   if (explodedRows.length) {
     const flatRecs = Array.isArray(docAiRecordsFlat) ? docAiRecordsFlat : [];
     const canonRecs = Array.isArray(docAiRecordsForMerge) ? docAiRecordsForMerge : [];
     if (flatRecs.length || canonRecs.length) {
       const usedRecords = new Set();
       const canonicalRefs = new Set(canonRecs);
       for (const row of explodedRows) {
         if (!row || typeof row !== 'object') continue;
         let match = null;
         if (canonRecs.length) {
           match =
-            bestRowMatchToSpec(row, canonRecs, usedRecords) ||
+            bestRowMatchToSpec(row, canonRecs, usedRecords, { tokenStats: docAiTokenStats }) ||
             bestAttributeMatchToSpec(row, canonRecs, variantKeys);
         }
         if (!match && String(family || '').toLowerCase() === 'relay_signal') {
           match = findCoilRowMatchForRelaySignal(row, flatRecs);
         }
         if (match && match.values) {
           Object.assign(row, safeMergeSpec(row, match.values));
           if (canonicalRefs.has(match)) {
             usedRecords.add(match);
           }
         }
       }
     }
     try {
       await ensureDynamicColumnsForRows(qualified, explodedRows);
     } catch (err) {
       console.warn('[schema] ensureDynamicColumnsForRows explodedRows failed:', err?.message || err);
     }
   }
   if (
     Array.isArray(explodedRows) &&
     explodedRows.length &&
     blueprint?.fields &&
     Object.keys(blueprint.fields).length
   ) {
@@ -4002,50 +4404,89 @@ async function doIngestPipeline(input = {}, runIdParam = null) {
         try {
           const llmValues = await extractFields(
             docTextForLlm,
             target.row?.pn || target.row?.code || '',
             blueprint.fields,
           );
           if (llmValues && typeof llmValues === 'object') {
             const patch = safeMergeSpec(target.row, llmValues);
             if (patch && Object.keys(patch).length) {
               Object.assign(target.row, patch);
             }
           }
         } catch (err) {
           console.warn('[llm] extractFields backfill failed:', err?.message || err);
         }
       }
       if (llmTargets.length) {
         try {
           await ensureDynamicColumnsForRows(qualified, explodedRows);
         } catch (err) {
           console.warn('[schema] ensureDynamicColumnsForRows llm failed:', err?.message || err);
         }
       }
     }
   }
+  if (docPnCandidatesInfo?.map instanceof Map && docPnCandidatesInfo.map.size && explodedRows.length) {
+    const variantKeyUnion = Array.from(
+      new Set([
+        ...(Array.isArray(variantKeys) ? variantKeys : []),
+        ...(Array.isArray(runtimeVariantKeys) ? runtimeVariantKeys : []),
+      ])
+    );
+    for (const row of explodedRows) {
+      if (!row || typeof row !== 'object') continue;
+      const hints = [row.pn, row.code, row.part_number, row.part_no, row.code_norm, code]
+        .map((value) => (value == null ? null : String(value)))
+        .filter((value) => value && value.trim());
+      const bestPn = pickOrderingPreferredPn(row, {
+        candidateInfo: docPnCandidatesInfo,
+        hints,
+        variantKeys: variantKeyUnion,
+        seriesHints: [baseSeries, series, row.series, row.series_code],
+        brand: row.brand || brandName,
+      });
+      if (!bestPn) continue;
+      const bestNorm = normalizeCode(bestPn);
+      if (!bestNorm) continue;
+      const existingCode = typeof row.code === 'string' ? row.code.trim() : '';
+      const existingCodeNorm = existingCode ? normalizeCode(existingCode) : null;
+      if (!existingCodeNorm || existingCodeNorm !== bestNorm) {
+        if (existingCode && existingCodeNorm && existingCodeNorm !== bestNorm && row._code_hint == null) {
+          row._code_hint = existingCode;
+        }
+        row.code = bestPn;
+      }
+      const existingPn = typeof row.pn === 'string' ? row.pn.trim() : '';
+      const existingPnNorm = existingPn ? normalizeCode(existingPn) : null;
+      if (!existingPnNorm || existingPnNorm !== bestNorm) {
+        row.pn = bestPn;
+      }
+      if (!row.part_number || normalizeCode(row.part_number) !== bestNorm) row.part_number = bestPn;
+      if (!row.part_no || normalizeCode(row.part_no) !== bestNorm) row.part_no = bestPn;
+    }
+  }
   const physicalCols = new Set(colTypes ? [...colTypes.keys()] : []);
   const allowedSet = new Set((allowedKeys || []).map((k) => String(k || '').trim().toLowerCase()).filter(Boolean));
   const variantSet = new Set(variantKeys);
 
   const seenCodes = new Set();
   for (const row of explodedRows) {
     const seeds = [];
     const seenSeed = new Set();
     const pushSeed = (val) => {
       if (val == null) return;
       if (Array.isArray(val)) { val.forEach(pushSeed); return; }
       const str = String(val).trim();
       if (!str) return;
       const parts = splitAndCarryPrefix(str);
       if (parts.length > 1) { parts.forEach(pushSeed); return; }
       const normed = str.toLowerCase();
       if (seenSeed.has(normed)) return;
       seenSeed.add(normed);
       seeds.push(str);
     };
     pushSeed(row.code);
     pushSeed(row.mpn);
     pushSeed(row.part_number);
     pushSeed(row.part_no);