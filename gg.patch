diff --git a/src/pipeline/persist.js b/src/pipeline/persist.js
index 7f3029fbf0e52b298cbd9be5618549cf9414a5d7..74647d50c1ab2b6cf6ee87a8e82a408d6d4978b7 100644
--- a/src/pipeline/persist.js
+++ b/src/pipeline/persist.js
@@ -803,64 +803,74 @@ function renderAnyTemplate(template, record = {}, ctxOrOptions = {}, maybeOption
   let working = String(template);
   let used = false;
 
   const double = renderTemplateWithPattern(working, context, /\{\{\s*([^{}]+?)\s*\}\}/g);
   working = double.rendered;
   if (double.used) used = true;
 
   const single = renderTemplateWithPattern(working, context, /\{\s*([^{}]+?)\s*\}/g);
   working = single.rendered;
   if (single.used) used = true;
 
   if (!used) return null;
   const collapseWhitespace = options?.collapseWhitespace !== false;
   let cleaned = collapseWhitespace ? working.replace(/\s+/g, '') : working;
   cleaned = cleaned.trim();
   return cleaned || null;
 }
 
 function renderPnTemplateLocal(template, record = {}) {
   return renderAnyTemplate(template, record);
 }
 
 const renderPnTemplate =
   typeof renderPnTemplateFromOrdering === 'function' ? renderPnTemplateFromOrdering : renderPnTemplateLocal;
 
+function fuzzyContainsPn(text, pn) {
+  if (!pn) return false;
+  const template = String(pn || '').trim();
+  if (!template) return false;
+  const haystack = typeof text === 'string' ? text : String(text ?? '');
+  if (!haystack) return false;
+  const pattern = template
+    .replace(/[-\s]+/g, '[-\\s]*')
+    .replace(/V$/i, 'V(?:DC)?');
+  if (!pattern) return false;
+  const re = new RegExp(`(^|[^A-Za-z0-9])${pattern}(?=$|[^A-Za-z0-9])`, 'i');
+  return re.test(haystack);
+}
+
 function buildPnIfMissing(record = {}, pnTemplate) {
   const existing = String(record.pn || '').trim();
   if (existing) return;
   const fromTemplate = renderPnTemplate(pnTemplate, record);
   // 본문 검증: 템플릿 결과가 실제 문서 텍스트에 존재할 때만 채택
   const ctxText = String(record._doc_text || record.doc_text || '');
-  if (fromTemplate && ctxText) {
-    const normalizedContext = norm(ctxText);
-    const normalizedTemplate = norm(fromTemplate);
-    if (normalizedTemplate && normalizedContext.includes(normalizedTemplate)) {
-      record.pn = fromTemplate;
-      if (!record.code) record.code = fromTemplate;
-      return;
-    }
+  if (fromTemplate && ctxText && fuzzyContainsPn(ctxText, fromTemplate)) {
+    record.pn = fromTemplate;
+    if (!record.code) record.code = fromTemplate;
+    return;
   }
   const code = String(record.code || '').trim();
   if (code) record.pn = code;
 }
 
 function buildBestIdentifiers(family, spec = {}, blueprint) {
   if (!spec || typeof spec !== 'object') return spec;
 
   let codeCandidate = null;
   const localTemplate = blueprint?.pn_template || spec?._pn_template || null;
   if (localTemplate) {
     try {
       codeCandidate = renderPnTemplate(localTemplate, spec);
     } catch (_) {}
   }
 
   const docText = String(spec._doc_text || spec.doc_text || '');
   if (!codeCandidate && family === 'relay_signal') {
     const fallback = codeForRelaySignal(spec);
     if (fallback && norm(docText).includes(norm(fallback))) {
       codeCandidate = fallback;
     }
   }
   if (codeCandidate && norm(docText).includes(norm(codeCandidate))) {
     spec.pn = codeCandidate;