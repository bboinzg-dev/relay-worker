diff --git a/server.js b/server.js
index 0f2855f5b065180ce028fb7dfac2d95bda14724e..e68ed0c5f4cf1606a3eb019c1de95ed878fd705b 100644
--- a/server.js
+++ b/server.js
@@ -29,61 +29,74 @@ const { generateRunId } = require('./src/utils/run-id');
  try { require('./src/tasks/embedFamilies').run().catch(console.error); } catch {}
 
  // lazy init: gRPC 문제 대비 regional endpoint + REST fallback
  let _tasks = null;
  let _queuePath = null;
  function getTasks() {
    if (!_tasks) {
     // 글로벌 엔드포인트 + REST fallback(HTTP/1)
     _tasks = new CloudTasksClient({ fallback: true });
      _queuePath = _tasks.queuePath(PROJECT_ID, TASKS_LOCATION, QUEUE_NAME);
    }
    return { tasks: _tasks, queuePath: _queuePath };
  }
 
 async function enqueueWorkerStep(payload = {}) {
   const { tasks, queuePath } = getTasks();
   if (!TASKS_INVOKER_SA) throw new Error('TASKS_INVOKER_SA not set');
   const audience = process.env.WORKER_AUDIENCE || new URL(WORKER_STEP_URL).origin;
 
   const bodyPayload = { ...payload };
   const runId = bodyPayload.runId || bodyPayload.run_id || generateRunId();
   bodyPayload.runId = runId;
   bodyPayload.run_id = runId;
 
   const body = Buffer.from(JSON.stringify(bodyPayload)).toString('base64');
+  const dispatchDeadline = process.env.TASKS_DISPATCH_DEADLINE || '150s';
+  const scheduleDelaySeconds = Number.isFinite(Number(process.env.TASKS_SCHEDULE_DELAY_SECONDS))
+    ? Math.max(0, Number(process.env.TASKS_SCHEDULE_DELAY_SECONDS))
+    : 5;
+  const scheduledSeconds = Math.floor(Date.now() / 1000) + scheduleDelaySeconds;
 
   const task = {
     httpRequest: {
       httpMethod: 'POST',
       url: WORKER_STEP_URL,
       headers: { 'Content-Type': 'application/json' },
       body,
       ...(TASKS_INVOKER_SA
         ? { oidcToken: { serviceAccountEmail: TASKS_INVOKER_SA, audience } }
         : {}),
     },
+    dispatchDeadline,
+    scheduleTime: { seconds: scheduledSeconds },
+    retryConfig: {
+      maxAttempts: 12,
+      minBackoff: { seconds: 1 },
+      maxBackoff: { seconds: 60 },
+      maxDoublings: 4,
+    },
   };
 
   // (선택) 10초로 RPC 타임아웃 단축 — 실패 시 바로 catch → DB만 FAILED 마킹
   await tasks.createTask({ parent: queuePath, task }, { timeout: 10000 });
   return runId;
 }
 
 
 const app = express();
 
 app.use(bodyParser.json({ limit: '25mb' }));
 app.use(bodyParser.urlencoded({ extended: true }));
 app.disable('x-powered-by');
 
 /* ---------------- Env / Config ---------------- */
 const PORT = process.env.PORT || 8080;
 const JWT_SECRET = process.env.JWT_SECRET || 'dev-secret';
 
 function parseCorsOrigins(envStr) {
   if (!envStr) return null;
   const items = envStr.split(',').map(s => s.trim()).filter(Boolean);
   return items.map(p => {
     if (p.startsWith('/') && p.endsWith('/')) {
       const body = p.slice(1, -1);
       return new RegExp(body);
diff --git a/server.js b/server.js
index 0f2855f5b065180ce028fb7dfac2d95bda14724e..e68ed0c5f4cf1606a3eb019c1de95ed878fd705b 100644
--- a/server.js
+++ b/server.js
@@ -574,69 +587,69 @@ async function handleWorkerStep(req, res) {
     payload?.gcsUri,
     payload?.gcs_uri,
     payload?.gsUri,
     payload?.gcsPdfUri,
     payload?.gcs_pdf_uri,
     payload?.uri,
     payload?.url,
   ].map((value) => (typeof value === 'string' ? value.trim() : '')).find((value) => !!value);
   const gcsUri = rawUri || '';
 
   let runId = [payload?.runId, payload?.run_id]
     .map((val) => (typeof val === 'string' && val.trim()) ? val.trim() : null)
     .find(Boolean) || null;
   if (!runId) {
     runId = generateRunId();
     console.warn('[ingest-step] runId missing -> created', { runId, taskName, phase });
   }
 
   const respondNoContent = () => {
     if (!res.headersSent) res.status(204).send();
   };
 
   const markProcessing = async () => {
     const update = await db.query(
       `UPDATE public.ingest_run_logs
-          SET status = 'PROCESSING',
+          SET status = 'RUNNING',
               task_name = $2,
               retry_count = $3,
               gcs_uri = COALESCE($4, gcs_uri),
               error_message = NULL,
               finished_at = NULL,
               duration_ms = NULL,
               final_table = NULL,
               final_family = NULL,
               final_brand = NULL,
               final_code = NULL,
               final_datasheet = NULL
         WHERE id = $1`,
       [ runId, taskName, retryCnt, gcsUri ]
     );
     if (!update.rowCount) {
       await db.query(
         `INSERT INTO public.ingest_run_logs (id, task_name, retry_count, gcs_uri, status)
-           VALUES ($1,$2,$3,$4,'PROCESSING')`,
+           VALUES ($1,$2,$3,$4,'RUNNING')`,
         [ runId, taskName, retryCnt, gcsUri ]
       );
     }
   };
 
   const markPersisting = async () => {
     const update = await db.query(
       `UPDATE public.ingest_run_logs
           SET status = 'PERSISTING',
               task_name = $2,
               retry_count = $3,
               gcs_uri = COALESCE($4, gcs_uri),
               error_message = NULL,
               finished_at = NULL,
               duration_ms = NULL,
               final_table = NULL,
               final_family = NULL,
               final_brand = NULL,
               final_code = NULL,
               final_datasheet = NULL
         WHERE id = $1`,
       [ runId, taskName, retryCnt, gcsUri ]
     );
     if (!update.rowCount) {
       await db.query(
