diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index 27da1a3df6c2d3ce978065741196aa161d9b0745..16d2afb6f2a2d6f28caa307907b1dbdab3465636 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -677,55 +677,98 @@ async function runAutoIngest({
       code: specsObj.code ?? fallbackSeries ?? null,
     };
     const expanded = explodeVariants(baseSeed, specsObj, bp).map((entry) => ({
       ...entry,
       brand: entry.brand || brandName,
       series_code: entry.series_code || entry.series || fallbackSeries,
       code: entry.code ?? specsObj.code ?? fallbackSeries ?? null,
     }));
     explodedEntries.push(...expanded);
   }
   if (!explodedEntries.length) {
     explodedEntries = [{ brand: brandName, series_code: baseSeries || null, code: baseSeries || null }];
   }
 
   // ---- 분할 여부 결정 ----
   const pnCands = candidateMap.map((c) => c.raw);
   const seriesCands = (candidates.length && series) ? candidateMap.filter((c) => /\d/.test(c.norm)).map((c) => c.raw) : [];
   const mustSplit = decideSplit({
     pnCandidates: pnCands,
     seriesCandidates: seriesCands,
     variantKeys,
     specs: (rawRows[0] || {})
   });
 
   if (!mustSplit && explodedEntries.length > 1) explodedEntries.splice(1);
-  if (mustSplit && candidateMap.length > 1 && explodedEntries.length <= 1) {
-    const max = Math.min(candidateMap.length, FIRST_PASS_CODES || 20);
-    const tmpl = explodedEntries[0] || { brand: brandName, series_code: baseSeries || null };
-    explodedEntries = candidateMap.slice(0, max)
-      .map((c) => ({ ...tmpl, code: c.raw, code_norm: c.norm }));
+  if (mustSplit && candidateMap.length > 1) {
+    const maxCodes = Math.min(candidateMap.length, FIRST_PASS_CODES || 20);
+    if (maxCodes > 0) {
+      const fallbackNorm = baseSeries ? normalizeCode(baseSeries) : null;
+      const assignedNorms = new Set();
+
+      // 이미 스펙 행에 코드가 정확히 채워져 있으면 그대로 사용
+      for (const entry of explodedEntries) {
+        const existing = entry.code ? normalizeCode(entry.code) : null;
+        if (existing && candidateNormSet.has(existing) && !assignedNorms.has(existing)) {
+          assignedNorms.add(existing);
+        }
+      }
+
+      let idx = 0;
+      const nextCandidate = () => {
+        while (idx < maxCodes && assignedNorms.has(candidateMap[idx].norm)) idx++;
+        if (idx >= maxCodes) return null;
+        const cand = candidateMap[idx++];
+        assignedNorms.add(cand.norm);
+        return cand;
+      };
+
+      for (const entry of explodedEntries) {
+        if (assignedNorms.size >= maxCodes) break;
+        const norm = entry.code ? normalizeCode(entry.code) : null;
+        const needsOverride = !norm || norm === fallbackNorm || assignedNorms.has(norm);
+        if (!needsOverride) continue;
+        const cand = nextCandidate();
+        if (!cand) break;
+        entry.code = cand.raw;
+        entry.code_norm = cand.norm;
+      }
+
+      const templateBase = explodedEntries[0]
+        ? { ...explodedEntries[0] }
+        : { brand: brandName, series_code: baseSeries || null };
+      delete templateBase.code;
+      delete templateBase.code_norm;
+
+      for (let cand = nextCandidate(); cand; cand = nextCandidate()) {
+        explodedEntries.push({
+          ...templateBase,
+          code: cand.raw,
+          code_norm: cand.norm,
+        });
+      }
+    }
   }
 
   const seenCodes = new Set();
   for (const entry of explodedEntries) {
     const baseInfo = entry || {};
     const specs = {};
     for (const k of allowedKeys) if (entry[k] != null) specs[k] = entry[k];
     const pickNumeric = (vals) => {
       for (const v of (Array.isArray(vals) ? vals : [vals])) { const n = coerceNumeric(v); if (Number.isFinite(n)) return n; }
       return null;
     };
     const voltageNum   = pickNumeric(specs.coil_voltage_vdc || specs.coil_voltage || specs.voltage_vdc || specs.voltage_dc || specs.voltage);
     const voltageToken = voltageNum != null ? String(Math.round(voltageNum)).padStart(2,'0') : null;
 
     let mpn = baseInfo.code ? String(baseInfo.code).trim() : null;   // 후보 복제 시 base.code가 곧 MPN
     if (!mpn && candidateMap.length) {
       const match = voltageToken ? candidateMap.find(c => c.norm.includes(voltageToken)) : null;
       mpn = (match || candidateMap[0])?.raw || null;
     }
     if (!mpn) {
       const templated = buildMpn({ ...specs, ...baseInfo }, bp);
       if (templated) mpn = templated;
     }
     if (!mpn && specs.code) mpn = String(specs.code).trim();
 
