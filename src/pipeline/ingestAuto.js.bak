// src/pipeline/ingestAuto.js
'use strict';

const path = require('node:path');
const os = require('node:os');
const fs = require('node:fs/promises');
const { execFile } = require('node:child_process');
const { promisify } = require('node:util');
const execFileP = promisify(execFile);

const db = require('../utils/db');
const { storage, parseGcsUri, canonicalCoverPath } = require('../utils/gcs');
const { ensureSpecsTable, upsertByBrandCode } = require('../utils/schema');
const { chooseCanonicalFamilySlug } = require('../utils/family');

// extractDataset 관대한 로딩 (export 형태가 달라도 동작)
let extractDataset = null;
try {
  const ex = require('../utils/extract');
  extractDataset =
    ex?.extractDataset ||
    ex?.default?.extractDataset ||
    (typeof ex === 'function' ? ex : null);
} catch (_) {}
if (typeof extractDataset !== 'function') {
  throw new Error('extractDataset loader failed: ../utils/extract 에서 함수를 찾지 못했습니다.');
}

// 문자열 정리
const lc = (s) => (s || '').toString().trim().toLowerCase();

// ===== 대표 이미지(cover) 추출: pdfimages → GCS 업로드 =====
// - pdfimages 는 poppler-utils 에 포함 (Dockerfile에서 설치 필요)
// - 1~2페이지의 가장 큰 PNG를 추출하여 GCS에 업로드
async function extractCoverToGcs(gcsPdfUri, { family, brand, code }) {
  try {
    const { bucket, name } = parseGcsUri(gcsPdfUri);

    const tmpDir  = path.join(os.tmpdir(), 'pdf-' + Date.now());
    const pdfPath = path.join(tmpDir, 'doc.pdf');
    await fs.mkdir(tmpDir, { recursive: true });

    // PDF 다운로드
    const [buf] = await storage.bucket(bucket).file(name).download();
    await fs.writeFile(pdfPath, buf);

    // 첫 1~2페이지 이미지 추출 (없으면 건너뜀)
    await execFileP('pdfimages', ['-f','1','-l','2','-png', pdfPath, path.join(tmpDir, 'img')]);

    // 가장 큰 PNG 선택
    const files = (await fs.readdir(tmpDir)).filter(f => /^img-\d+-\d+\.png$/i.test(f));
    if (!files.length) return null;

    let pick = null, size = -1;
    for (const f of files) {
      const st = await fs.stat(path.join(tmpDir, f));
      if (st.size > size) { pick = f; size = st.size; }
    }
    if (!pick) return null;

    // 업로드 경로: gs://<bucket>/images/<family>/<brand_norm>/<code_norm>/cover.png
    const dest = canonicalCoverPath(
      process.env.ASSET_BUCKET || process.env.GCS_BUCKET,
      family, brand, code
    );
    const { bucket: dbkt, name: dname } = parseGcsUri(dest);

    await storage.bucket(dbkt).upload(path.join(tmpDir, pick), {
      destination: dname,
      resumable: false
    });

    return dest;
  } catch {
    // 설치/이미지 없음/권한 문제 등은 조용히 스킵
    return null;
  }
}

// ===== 메인: 자동 인제스트 =====
// opts: { gcsUri, family_slug?, brand?, code?, series?, display_name? }
async function runAutoIngest(opts = {}) {
  const started = Date.now();

  const gcsUri = opts.gcsUri || opts.gcsPdfUri;
  if (!gcsUri || !/^gs:\/\//i.test(gcsUri)) {
    throw new Error('gcsUri required (gs://...)');
  }
  const filename = opts.filename || gcsUri.split('/').pop() || 'doc.pdf';

  // 1) 데이터셋 추출 (브랜드/코드/시리즈/텍스트 등)
  const ds = await extractDataset({
    gcsUri,
    filename,
    brandHint: opts.brand,
    codeHint:  opts.code,
    seriesHint: opts.series
  });

  const brand = (ds.brand || opts.brand || 'unknown').toString();
  const code  = (Array.isArray(ds.rows) && ds.rows[0]?.code)
                  || opts.code
                  || ('TMP_' + Math.random().toString(16).slice(2).toUpperCase());
  const series = ds.series || opts.series || null;
  const displayName = (Array.isArray(ds.rows) && ds.rows[0]?.displayname) || opts.display_name || null;
  const rawText = ds.text || '';

  // 2) family 결정 (명시 > 휴리스틱 > 기본 relay_power)
  const family = lc(opts.family_slug) ||
                 chooseCanonicalFamilySlug({ text: rawText }) ||
                 'relay_power';

  // 3) component_registry에서 스펙 테이블 확인 + 보장
  const reg = await db.query(
    `SELECT specs_table FROM public.component_registry WHERE family_slug=$1 LIMIT 1`,
    [family]
  );
  const tableName = (reg.rows[0]?.specs_table || `${family}_specs`).replace(/[^a-zA-Z0-9_]/g, '');
  await ensureSpecsTable(tableName, {}); // 필요 시 컬럼/테이블 보장

  // 4) 대표 이미지(cover) 추출 (실패해도 인제스트는 계속)
  const coverUri = await extractCoverToGcs(gcsUri, { family, brand, code });

  // 5) UPSERT (존재하는 컬럼만 schema util이 처리)
  const payload = {
    family_slug: family,
    brand, code,
    brand_norm: lc(brand),
    code_norm:  lc(code),
    series,
    display_name: displayName,
    datasheet_uri: gcsUri,
    // 공통 필드 (테이블에 없으면 무시됨)
    image_url: coverUri,
    cover: coverUri,
    width_mm:  null,
    height_mm: null,
    length_mm: null,
    // 원하면 원문 추적/검증용 필드들도 추가 가능(verified_in_doc 등)
  };

  const row = await upsertByBrandCode(tableName, payload);

  const ms = Date.now() - started;
  return {
    ok: true,
    ms,
    family_slug: family,
    specs_table: `public.${tableName}`,
    brand,
    code,
    datasheet_uri: gcsUri,
    image_url: coverUri,
    // 필요 시 반환 확장
    row,
  };
}

module.exports = { runAutoIngest };
