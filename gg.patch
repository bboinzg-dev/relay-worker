diff --git a/src/pipeline/persist.js b/src/pipeline/persist.js
index 39e0609ec415d043401f9d34b91676f6f7258a5e..4c618be16090edbac87ab0d3f1a8dd8b684e8e15 100644
--- a/src/pipeline/persist.js
+++ b/src/pipeline/persist.js
@@ -121,55 +121,67 @@ function findRangeColumn(columnTypes, base, kind) {
 }
 
 const BRAND_LOOKUP_SQL = `
   SELECT brand_norm, brand
     FROM public.manufacturer_alias
    WHERE brand_norm = lower($1)
       OR lower($1) = ANY(aliases)
    LIMIT 1
 `;
 
 const BRAND_ALIAS_SCAN_SQL = `
   SELECT brand_norm, aliases
     FROM public.manufacturer_alias
 `;
 
 const brandCache = new Map();
 let aliasRowsCache = null;
 let aliasRowsFetchedAt = 0;
 
 async function loadAliasRows() {
   const now = Date.now();
   if (aliasRowsCache && now - aliasRowsFetchedAt < 60_000) {
     return aliasRowsCache;
   }
   try {
-    const { rows } = await pool.query(BRAND_ALIAS_SCAN_SQL);
+    let { rows } = await pool.query(BRAND_ALIAS_SCAN_SQL);
     aliasRowsCache = Array.isArray(rows) ? rows : [];
     aliasRowsFetchedAt = now;
   } catch (err) {
-    aliasRowsCache = [];
+    // Fallback: aliases 컬럼이 없으면 alias 단일값을 배열로 대체
+    try {
+      const { rows } = await pool.query(
+        `SELECT brand_norm, alias FROM public.manufacturer_alias`
+      );
+      aliasRowsCache = rows.map((r) => ({
+        brand_norm: String(r.brand_norm || '').toLowerCase(),
+        aliases: r.alias ? [String(r.alias)] : [],
+      }));
+    } catch (e2) {
+      aliasRowsCache = [];
+      console.warn('[persist] alias scan fallback failed:', e2?.message || e2);
+    }
     aliasRowsFetchedAt = now;
     console.warn('[persist] normalizeBrand alias scan failed:', err?.message || err);
   }
   return aliasRowsCache;
 }
 
 async function normalizeBrand(raw, docTextLower = '') {
   const trimmed = String(raw || '').trim();
   if (!trimmed) return null;
   const key = trimmed.toLowerCase();
   if (brandCache.has(key)) return brandCache.get(key);
 
   let resolved = null;
   try {
     const { rows } = await pool.query(BRAND_LOOKUP_SQL, [trimmed]);
     const row = rows?.[0];
     if (row?.brand_norm) {
       resolved = String(row.brand_norm).trim().toLowerCase();
     }
   } catch (err) {
     console.warn('[persist] normalizeBrand query failed:', err?.message || err);
   }
 
   const docLower = String(docTextLower || '').toLowerCase();
   if (!resolved && docLower) {
diff --git a/src/pipeline/persist.js b/src/pipeline/persist.js
index 39e0609ec415d043401f9d34b91676f6f7258a5e..4c618be16090edbac87ab0d3f1a8dd8b684e8e15 100644
--- a/src/pipeline/persist.js
+++ b/src/pipeline/persist.js
@@ -266,51 +278,52 @@ function hasCoreSpec(row, keys = [], candidateKeys = []) {
   }
   for (const key of list) {
     const norm = normKey(key);
     if (!norm) continue;
     if (hasCoreSpecValue(row[norm] ?? row[key])) return true;
   }
   return false;
 }
 
 function shouldInsert(row, { coreSpecKeys, candidateSpecKeys } = {}) {
   if (!row || typeof row !== 'object') {
     return { ok: false, reason: 'empty_row' };
   }
   const brand = String(row.brand || '').trim().toLowerCase();
   if (!brand || brand === 'unknown') {
     if (row && typeof row === 'object') row.last_error = 'missing_brand';
     return { ok: false, reason: 'missing_brand' };
   }
   const pn = String(row.pn || row.code || '').trim();
   if (!isValidPnValue(pn) || FORBIDDEN_RE.test(pn)) {
     if (row && typeof row === 'object') row.last_error = 'invalid_code';
     return { ok: false, reason: 'invalid_code' };
   }
   row.pn = pn;
   if (row.code == null || String(row.code).trim() === '') row.code = pn;
-  if (!hasCoreSpec(row, coreSpecKeys, candidateSpecKeys)) {
+  const allowMinimal = /^(1|true|on)$/i.test(process.env.ALLOW_MINIMAL_INSERT || '0');
+  if (!hasCoreSpec(row, coreSpecKeys, candidateSpecKeys) && !allowMinimal) {
     return { ok: false, reason: 'missing_core_spec' };
   }
   return { ok: true };
 }
 
 async function getColumnTypes(targetTable) {
   const [schema, table] = targetTable.includes('.')
     ? targetTable.split('.', 2)
     : ['public', targetTable];
 
   const { rows } = await pool.query(
     `SELECT lower(column_name) AS column, data_type
        FROM information_schema.columns
       WHERE table_schema = $1
         AND table_name   = $2`,
     [schema, table],
   );
 
   const map = new Map();
   for (const row of rows) {
     map.set(row.column, String(row.data_type || '').toLowerCase());
   }
   return map;
 }
 
