diff --git a/src/services/vertex.js b/src/services/vertex.js
index 773c56592257147fd6094bc8f1f0752f3f5a049e..5763331d47f0f7034cee3388bed852abdf39072f 100644
--- a/src/services/vertex.js
+++ b/src/services/vertex.js
@@ -78,53 +78,51 @@ function safeParseJson(text) {
   let start = -1;
   for (let i = 0; i < stripped.length; i += 1) {
     const ch = stripped[i];
     if (ch === '{') {
       if (depth === 0) start = i;
       depth += 1;
     } else if (ch === '}') {
       depth -= 1;
       if (depth === 0 && start >= 0) {
         const slice = stripped.slice(start, i + 1);
         try {
           return JSON.parse(slice);
         } catch (_) {}
         start = -1;
       }
     }
   }
 
   return null;
 }
 
 function extractCandidateJson(response) {
   const parts = Array.isArray(response?.response?.candidates?.[0]?.content?.parts)
     ? response.response.candidates[0].content.parts
     : [];
-  const text = parts
-    .map((part) => (typeof part?.text === 'string' ? part.text : ''))
-    .join('');
+  const text = parts.map((part) => part?.text || '').join('');
   if (!text || !text.trim()) {
     return { text: '', data: null };
   }
   const data = safeParseJson(text);
   if (!data) {
     if (process.env.DEBUG_ORDERING === '1') {
       console.warn('[vertex:not-json]', text.slice(0, 300));
     }
     const err = new Error('VERTEX_NOT_JSON');
     err.sample = text.slice(0, 500);
     throw err;
   }
   return { text, data };
 }
 
 async function classifyByGcs(gcsUri, filename = 'datasheet.pdf') {
   const fams = await getFamilies();
   const prompt = [
     `PDF 전체를 읽고 {"family_slug","brand","code","series"} JSON만 반환. 파일명: ${filename}`,
     `- family_slug는 반드시 다음 중 하나: ${fams.map((f) => `"${f}"`).join(', ')}`,
   ].join('\n');
   const resp = await callGemini({
     modelName: MODEL_CLASSIFY,
     contents: [
       {