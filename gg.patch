diff --git a/src/ai/datasheetExtract.js b/src/ai/datasheetExtract.js
index 0e0fac3c8ae38f4fc1c5d7fbdb899e3878206dc7..b6dfe836d7b8e82e6ef439dde15548426c62bb77 100644
--- a/src/ai/datasheetExtract.js
+++ b/src/ai/datasheetExtract.js
@@ -637,50 +637,66 @@ async function geminiMapValues({ family, brandHint, codes, allowedKeys, docText,
    }
    return out; 
 }
 
 /* -------------------- Public: main extractor -------------------- */
 async function extractPartsAndSpecsFromPdf({ gcsUri, allowedKeys, family = null, brandHint = null }) {
   const rowAllowedKeySet = new Set();
   const rowAllowedKeys = [];
   const ensureAllowedKey = (value) => {
     const str = value == null ? '' : String(value).trim();
     if (!str) return;
     const lower = str.toLowerCase();
     if (rowAllowedKeySet.has(lower)) return;
     rowAllowedKeySet.add(lower);
     rowAllowedKeys.push(str);
   };
 
   if (Array.isArray(allowedKeys)) {
     for (const key of allowedKeys) ensureAllowedKey(key);
   }
   ensureAllowedKey('series');
   ensureAllowedKey('series_code');
   ensureAllowedKey('pn_jp');
   ensureAllowedKey('pn_aliases');
   ensureAllowedKey('ordering_market');
+  if ((family || '').toLowerCase().includes('capacitor')) {
+    [
+      'capacitance_uf',
+      'rated_voltage_v',
+      'esr_mohm',
+      'df_percent',
+      'dcl_ua',
+      'case_size_code',
+      'product_category',
+      'msl',
+      'rms_current_100khz_45c',
+      'rms_current_100khz_85c',
+      'rms_current_100khz_105c',
+      'rms_current_100khz_125c',
+    ].forEach(ensureAllowedKey);
+  }
 
   const promptAllowedKeys = Array.from(new Set([
     ...rowAllowedKeys,
   ]));
 
   let docai = await processWithDocAI(gcsUri);
   let fullText = docai?.fullText || '';
   if (!fullText) fullText = await parseTextWithPdfParse(gcsUri);
 
   const tableList = Array.isArray(docai?.tables) ? docai.tables : [];
   const typePartMap = extractTypePartPairs(tableList);
 
   const brand = brandHint || (await detectBrandFromText(fullText)) || 'unknown';
   const orderingInfo = extractOrderingInfo(fullText, MAX_PARTS);
 
   // 코드 후보
   let codes = [];
   if (tableList.length) codes = codesFromDocAiTables(tableList);
   if (!codes.length && fullText) codes = codesFromFreeText(fullText);
   const pnRegex = buildPnRegexFromExamples(codes.slice(0, MAX_PARTS));
 
   // 표 프리뷰(LLM 컨텍스트)
   let tablePreview = '';
   let perCodePreviewMap = new Map();
   const baseSegments = [];
@@ -901,52 +917,53 @@ async function extractPartsAndSpecsFromPdf({ gcsUri, allowedKeys, family = null,
       normalizeVariantDomainMap(recipe?.variant_domains),
     );
     if (!pnTemplate && typeof recipe?.pn_template === 'string' && recipe.pn_template.trim()) {
       pnTemplate = recipe.pn_template.trim();
     }
   } catch (err) {
     console.warn('[ordering] extractOrderingRecipe failed:', err?.message || err);
   }
 
   const variantKeys = Object.keys(orderingDomains)
     .map((key) => String(key || '').trim())
     .filter(Boolean);
   if (variantKeys.length) {
     for (const key of variantKeys) ensureAllowedKey(key);
     const baseSeries = orderingDomains.series_code?.[0] || orderingDomains.series?.[0] || null;
     const orderingBase = {
       brand,
       series: baseSeries,
       series_code: baseSeries,
       values: orderingDomains,
     };
     const generatedRows = explodeToRows(orderingBase, { variantKeys, pnTemplate }) || [];
     const beforeCount = out.length;
     for (const generated of generatedRows) {
       if (!generated || typeof generated !== 'object') continue;
+      // 테이블 예시로 학습한 PN-정규식에 안 맞으면 버림
+      if (pnRegex && !pnRegex.test(String(generated.code || ''))) continue;
       const codeNorm = String(generated.code || '').trim().toUpperCase();
-      if (pnRegex && codeNorm && !pnRegex.test(codeNorm)) continue;
       const values = generated.values && typeof generated.values === 'object' ? generated.values : {};
       const v = hasDocEvidence(normalizeCodeKey(generated.code)) || hasOrderingEvidence(generated.code);
       if (values && typeof values === 'object' && !Object.prototype.hasOwnProperty.call(values, '_pn_template')) {
         values._pn_template = pnTemplate || null;
       }
       pushRow({ code: generated.code, values, brand, verified: v });
     }
     orderingExpanded = out.length > beforeCount;
   }
 
   if (!out.length) {
     for (const c of seedCodes) {
       pushRow({ code: c, values: {}, brand, verified: hasDocEvidenceValue(c) });
     }
   }
 
   const codeList = mergedCodes.slice(0, MAX_PARTS);
   const uniqueRowCodes = new Set();
   for (const row of out) {
     if (!row || typeof row !== 'object') continue;
     const code = String(row.code || row.pn || '').trim().toUpperCase();
     if (code) uniqueRowCodes.add(code);
   }
   const uniqueCandidateCodes = new Set(codeList.map((c) => String(c || '').trim().toUpperCase()).filter(Boolean));
   let docType = 'single';