diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index ca5f92b8de8d8b3a579378a2a2ea7d12732cff61..8d6a6e42ac6967eca888e68b6af26bdea1ac71a7 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -1,80 +1,96 @@
 'use strict';
 
 const path = require('node:path');
 const fs = require('node:fs/promises');
 const os = require('node:os');
 const { execFile } = require('node:child_process');
 const { promisify } = require('node:util');
 const execFileP = promisify(execFile);
 
 const db = require('../../db');
 const { storage, parseGcsUri, readText, canonicalCoverPath } = require('../utils/gcs');
 const { extractText } = require('../utils/extract');
 const { getBlueprint } = require('../utils/blueprint');
 const { resolveBrand } = require('../utils/brand');
 const { detectVariantKeys } = require('../utils/ordering');
 const { extractPartsAndSpecsFromPdf } = require('../ai/datasheetExtract');
 const { extractFields } = require('./extractByBlueprint');
+const { canonicalize } = require('./specKeyMap');
 const { saveExtractedSpecs } = require('./persist');
 const { explodeToRows } = require('../ingest/mpn-exploder');
 const { splitAndCarryPrefix } = require('../utils/mpn-exploder');
 const { ensureSpecColumnsForBlueprint } = require('./ensure-spec-columns');
 const { inferVariantKeys, normalizeSlug } = require('./variant-keys');
 const { classifyByGcs, extractValuesByGcs } = require('../services/vertex');
 const { processDocument: processDocAi } = require('../services/docai');
 
 const HARD_CAP_MS = Number(process.env.EXTRACT_HARD_CAP_MS || 120000);
 
 function withDeadline(promise, ms = HARD_CAP_MS, label = 'op') {
   const timeout = Number.isFinite(ms) && ms > 0 ? ms : HARD_CAP_MS;
   return new Promise((resolve, reject) => {
     const timer = setTimeout(() => {
       clearTimeout(timer);
       reject(new Error(`${label}_TIMEOUT`));
     }, timeout);
     Promise.resolve(promise)
       .then((value) => {
         clearTimeout(timer);
         resolve(value);
       })
       .catch((err) => {
         clearTimeout(timer);
         reject(err);
       });
   });
 }
 
 const FAST = String(process.env.INGEST_MODE || '').toUpperCase() === 'FAST' || process.env.FAST_INGEST === '1';
 const FAST_PAGES = [0, 1, -1]; // 첫 페이지, 2페이지, 마지막 페이지만
 
 const META_KEYS = new Set(['variant_keys','pn_template','ingest_options']);
 const BASE_KEYS = new Set([
   'family_slug','brand','code','pn','brand_norm','code_norm','pn_norm','series_code',
   'datasheet_uri','image_uri','datasheet_url','display_name','displayname',
   'cover','verified_in_doc','updated_at'
 ]);
+const SKIP_SPEC_KEYS = new Set([
+  'raw_json',
+  'text',
+  'tables',
+  'mpn_list',
+  'mpn',
+  'codes',
+  'series',
+  'series_code',
+  'raw_text',
+  'raw_specs',
+  'rawspecs',
+  'raw_table',
+  'raw_tables',
+]);
 
 const PN_CANDIDATE_RE = /[0-9A-Z][0-9A-Z\-_/().]{3,63}[0-9A-Z)]/gi;
 const PN_BLACKLIST_RE = /(pdf|font|xref|object|type0|ffff)/i;
 
 function escapeRegex(str) {
   return String(str || '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
 }
 
 function textContainsExact(text, pn) {
   if (!text || !pn) return false;
   const pattern = escapeRegex(String(pn).trim());
   if (!pattern) return false;
   const re = new RegExp(`(^|[^A-Za-z0-9])${pattern}(?=$|[^A-Za-z0-9])`, 'i');
   return re.test(String(text));
 }
 
 function normLower(s){ return String(s||'').trim().toLowerCase(); }
 
 function pickBrandHint(...values) {
   for (const value of values) {
     if (value == null) continue;
     const trimmed = String(value).trim();
     if (!trimmed) continue;
     if (trimmed.toLowerCase() === 'unknown') continue;
     return trimmed;
diff --git a/src/pipeline/ingestAuto.js b/src/pipeline/ingestAuto.js
index ca5f92b8de8d8b3a579378a2a2ea7d12732cff61..8d6a6e42ac6967eca888e68b6af26bdea1ac71a7 100644
--- a/src/pipeline/ingestAuto.js
+++ b/src/pipeline/ingestAuto.js
@@ -819,50 +835,107 @@ async function runAutoIngest(input = {}) {
     }
     for (const row of extracted.rows) {
       if (!row || typeof row !== 'object') continue;
       if (row.raw_json == null) {
         row.raw_json = rawJsonPayload;
       }
     }
   }
 
   if (detectedBrand && extracted && typeof extracted === 'object') {
     const brandValue = String(extracted.brand || '').trim().toLowerCase();
     if (!brandValue || brandValue === 'unknown') {
       extracted.brand = detectedBrand;
     }
     if (Array.isArray(extracted.rows)) {
       for (const row of extracted.rows) {
         if (!row || typeof row !== 'object') continue;
         const rowBrand = String(row.brand || '').trim().toLowerCase();
         if (!rowBrand || rowBrand === 'unknown') {
           row.brand = detectedBrand;
         }
       }
     }
   }
 
+  const runtimeSpecKeys = new Set();
+  const sanitizeSpecRows = (rows) => {
+    if (!Array.isArray(rows)) return [];
+    return rows.map((row) => {
+      if (!row || typeof row !== 'object') return {};
+      const out = {};
+      for (const [rawKey, rawValue] of Object.entries(row)) {
+        const key = String(rawKey || '').trim();
+        if (!key) continue;
+        const lower = key.toLowerCase();
+        if (META_KEYS.has(lower) || BASE_KEYS.has(lower) || SKIP_SPEC_KEYS.has(lower)) {
+          const existing = Object.prototype.hasOwnProperty.call(out, lower) ? out[lower] : undefined;
+          if (!Object.prototype.hasOwnProperty.call(out, lower) || existing == null || existing === '') {
+            out[lower] = rawValue;
+          }
+          continue;
+        }
+        if (lower.startsWith('_')) {
+          const metaKey = lower;
+          const existing = Object.prototype.hasOwnProperty.call(out, metaKey) ? out[metaKey] : undefined;
+          if (!Object.prototype.hasOwnProperty.call(out, metaKey) || existing == null || existing === '') {
+            out[metaKey] = rawValue;
+          }
+          continue;
+        }
+        const canon = canonicalize(key);
+        if (!canon) continue;
+        runtimeSpecKeys.add(canon);
+        const existing = Object.prototype.hasOwnProperty.call(out, canon) ? out[canon] : undefined;
+        if (!Object.prototype.hasOwnProperty.call(out, canon) || existing == null || existing === '') {
+          out[canon] = rawValue;
+        }
+      }
+      return out;
+    });
+  };
+
+  if (Array.isArray(extracted?.rows) && extracted.rows.length) {
+    extracted.rows = sanitizeSpecRows(extracted.rows);
+  }
+
+  const autoAddKeys = Array.from(runtimeSpecKeys);
+  if (process.env.AUTO_ADD_FIELDS === '1' && family && autoAddKeys.length) {
+    try {
+      const { rows } = await db.query(
+        'SELECT public.ensure_dynamic_spec_columns($1, $2::jsonb) AS created',
+        [family, JSON.stringify(autoAddKeys)]
+      );
+      const created = rows?.[0]?.created;
+      if (Array.isArray(created) && created.length) {
+        console.log('[schema] added columns', created);
+      }
+    } catch (err) {
+      console.warn('[schema] ensure_dynamic_spec_columns failed:', err?.message || err);
+    }
+  }
+
   // 🔹 이 변수가 "데이터시트 분석에서 바로 뽑은 MPN 리스트"가 됨
   let codes = [];
   if (!code) {
     const skuFromTable = pickSkuListFromTables(extracted);
     const docText = extracted?.text || previewText || '';
     codes = skuFromTable.length ? skuFromTable : expandFromCodeSystem(extracted, blueprint, docText);
     const maxEnv = Number(process.env.FIRST_PASS_CODES || FIRST_PASS_CODES || 20);
     const maxCodes = Number.isFinite(maxEnv) && maxEnv > 0 ? maxEnv : 20;
     if (codes.length > maxCodes) codes = codes.slice(0, maxCodes);
   }
 
   // 🔹 후보(candidates)가 아직 비었고, 방금 수집한 codes가 있으면 candidates로 승격
   if (!candidates.length && codes.length) {
     const merged = [];
     const seen = new Set();
     for (const raw of codes) {
       const trimmed = typeof raw === 'string' ? raw.trim() : String(raw || '');
       if (!trimmed) continue;
       const norm = normalizeCode(trimmed);
       if (seen.has(norm)) continue;
       seen.add(norm);
       merged.push(trimmed);
     }
     if (merged.length) candidates = merged;
   }
